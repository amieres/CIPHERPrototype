[{"name":"","content":"READ ME!\n\n- Organize your code by snippets, keep them all in one place, have them ready to use for small and big projects\n- Run it immediately with almost zero scaffolding\n- Produce JavaScript using Websharper and run it in your browser immediately\n- Use dependencies to assemble your solution\n- Dependencies are equivalent to `#load \"<file.fsx>\"` or include directives\n- Evaluate F# does not return the last value calculated, only what is printed to the output\n","predecessors":[],"companions":[],"id":{"$":0,"Item":"bc0d0abf-9c94-48bb-b46e-92e5d539b172"},"expanded":true},{"name":"","content":"\nPENDING:\n- Flush MailBoxProcessor if 5 messages are waiting / or add a button for flushing\n- Intellisense\n    - Autocompletion\n    - Code tips\n\n- Give it an icon that says F# Station\n\n- Have non indenting nested elements just for folder organization    \n    - it could be a flag in the name/code\n    - it could be an external attribute, like MIME type/subtype \n    - it could be related to the other type of content considered for the future\n        - Allow non text entries: like images, documents, links(text?) and other resources, maybe using 64 encoding\n        - Allow other modes for some entries: MarkDown, html, etc. \n        - That way different type of content could be integrated into code with different techniques for merging: css, html, javascript, c#, MarkDown and others\n        - Also it could be used as input for some code (although not too clear on how to do this, it may require serving the data as a web file)\n            - To store it in server it would make sense to split the snippets as entry in a DB so the server would not need to read a whole file\n              just to serve a snippet\n            - Some snippet could be generated from others: for instance as js from F#, the snippet maintains the dependence and could also maintain the ages\n              and know when a snippet needs to be regenerated.\n- Create website load/upload/invoke/precompiled code\n- The editor could have dual mode: server DB and local file\n    - For a website definition it would need to track read/write access to snippets\n\n- Eliminate fixit2 hack hardcoded namespace dependency\n\n- Implement Tab(s) & Application deployment including configurable editor(s)\n- Block non local use of Evaluate F# (unless logged in and with permission)\n- add HTTPS\n- add # routing to get to specific snippets\n- Give it a web site look\n\nSOLVED:\n    - Error highlight\n- Create splitter template: grid template with splitters included\n- Change the title so that it says F# Station\n- Implement command start: webserver + editor\n- Think how to mix WebSharper and no WebSharper code without duplicating: they can be shared and use #define WEBSHARPER to add [< JavaScript >]\n- Get rid of undefined message when running JS and maybe show possible result value\n- Get rid of no output warning when Evaluating FS and say Done!\n- Store last state in local storage:  splitter position/ execute/ file name/ dirty state\n- Create non-Javascript invocation (pure .Net F#) version for only local use.\n- Capture Asynchronous exceptions\n- Detect dirty state and not allow Load/close before saving\n    - Download ( Save as ...) with automatic extension\n- make Choose File and Load one action and one button\n- Limit undo to the current field\n- Error:\nCompiling...\nRunning...\nFailed!\nTypeError: Cannot read property 'appendChild' of undefined  // it was due to the busy CPU taking longer than 300ms to load. Changed to 600ms.","predecessors":[],"companions":[],"id":{"$":0,"Item":"b4b48226-deb9-44da-98de-e2bf5b7cd889"},"expanded":true},{"name":"","content":"#if INTERACTIVE\n//#I @\"../WebServer/bin\"\n#nowarn \"40\"\nmodule FSharpStationMD   =\n#else\nnamespace FSharpStationNS\n#nowarn \"1182\"\n\n#endif\n","predecessors":[],"companions":[],"id":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"expanded":true},{"name":"Evaluate F# Code","content":"// Code to be evaluated using FSI: `Evaluate F#`","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"expanded":true},{"name":"Useful","content":"module Useful =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"expanded":false},{"name":"","content":"let doSTA act =\n    let thread = System.Threading.Thread(System.Threading.ThreadStart act)\n    thread.SetApartmentState(System.Threading.ApartmentState.STA)\n    thread.Start()\n    \nlet sCopy       txt = \n    doSTA (fun () -> System.Windows.Forms.Clipboard.SetText txt)\n    sprintf \"Copied to clipboard: %s... (%d characters)\\n\\n\" <| txt.[..min (txt.Length - 1) 100 ] <| txt.Length \n    \nlet Copy        txt = \n    sCopy txt\n    |> printf \"%s\"\n    \nlet Paste f        = doSTA (fun () -> f System.Windows.Forms.Clipboard.GetText)   ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"},"expanded":true},{"name":"type ActionBar","content":"open System\nopen System.Text\nopen System.Drawing\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype GrowLabel (maxHeight:int) =\n  inherit Label() \n  let mutable mGrowing  = false\n  do base.AutoSize     <- false\n  member this.resizeLabel() =\n    if mGrowing then () else\n    try \n      mGrowing <- true\n      let sz       = new Size(base.Width, Int32.MaxValue)\n      let sz2      = TextRenderer.MeasureText(base.Text, base.Font, sz, TextFormatFlags.WordBreak)\n      base.Height <- min sz2.Height maxHeight\n    finally\n      mGrowing <- false\n  override this.OnTextChanged( e) = \n    base.OnTextChanged e\n    this.resizeLabel()\n  override this.OnFontChanged( e) =\n    base.OnFontChanged e\n    this.resizeLabel()\n  override this.OnSizeChanged( e) =\n    base.OnSizeChanged e\n    this.resizeLabel()\n\ntype ActionBar(actions:(string * (unit -> string)) seq) =\n    let label1 = new GrowLabel (Text = \"\", Width = 300, maxHeight = 100)\n    let newButton (txt:string) act =\n        let width = 300\n        if txt.StartsWith \"---\" || txt.StartsWith \"===\" then\n            let lbl = new Label(Text = txt, Width = width)\n            lbl :> Control\n        else\n            let btn = new Button(Text = txt, Width = width)\n            btn.Click.Add act\n            btn :> Control\n    \n    let form = new Form(Text = \"Select Action:\", Width = 400, Height = 800)\n    let panel1 = new Panel(Dock = DockStyle.Fill)\n    do  actions \n        |> Seq.map (fun (txt, f) -> newButton txt (fun _ -> label1.Text <- sprintf \"Processing %s ...\" txt\n                                                            form.Refresh()\n                                                            label1.Text <- f() ))\n        |> Seq.append [ label1 :> Control ]\n        |> Seq.toArray\n        |> panel1.Controls.AddRange\n        let reposition () =\n            panel1.Controls\n            |> Seq.cast\n            |> Seq.fold (fun (height, width) (cts: Control) -> \n                cts.Left <- 20 \n                cts.Top  <- height + 5\n                (height + cts.Height + 5, (max width cts.Width)) ) (0, 0)\n            |> (fun (height, width) -> form.Height <- height + 50 ; form.Width <- width + 50)\n        reposition ()\n        label1.Resize.Add (fun _ -> reposition () )\n        panel1.DockPadding.All <- 10\n        form.Controls.Add(panel1)\n        form.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\n        async {\n          do Application.Run(form) \n        } |> Async.Start\n       ","parent":{"$":0,"Item":"7c4a82bc-58cd-48a7-bd7e-79de148a1cf0"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"},"expanded":true},{"name":"SlowlyChangingDimensions","content":"//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n#r @\"C:\\Users\\Abelardo\\OneDrive - Cipher Business Solutions\\Clientes\\Houston\\CIPHERTool\\FSharp.Data.SqlClient\\FSharp.Data.SqlClient.dll\"\n\nmodule SlowlyChangingDimensions =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[{"$":0,"Item":"c7e56d1e-aea8-483a-a99a-23b7e056de0d"}],"companions":[],"id":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"expanded":false},{"name":"Fields","content":"type TargetField =\n     | CURR_ASSIGNED_VEND\n     | ORIG_ASSIGNED_VEND\n     | ORIG_INV_NUM\n     | POST_DTE_KEY\n     | RECEIVABLE_CURR_BILLING_TO_DTE\n     | RECEIVABLE_CURR_DELINQ_DTE\n     | RECEIVABLE_CURR_DUE_DTE\n     | RECEIVABLE_CURR_ISSUE_DTE\n     | RECEIVABLE_CURR_TO_DTE\n     | RECEIVABLE_KEY\n     | RECEIVABLE_ORIG_BILLING_TO_DTE\n     | RECEIVABLE_ORIG_DELINQ_DTE\n     | RECEIVABLE_ORIG_DUE_DTE\n     | RECEIVABLE_ORIG_ISSUE_DTE\n     | RECEIVABLE_ORIG_TO_DTE\n     | TRANS_DTE_KEY\n     | VERS_BEG_DTE  \n     | VERS_END_DTE \n     | CURR_VERS_FLAG\n     | ITEM_KEY\n     | INCDT_KEY\n     | CUST_KEY\n     | CARRIER_KEY\n     | CARRIER_PROCEDURE_KEY\n     | COLL_PERSON_KEY\n     | EMP_KEY\n     | FIN_TRANS_TYPE_KEY\n     | DTE_KEY\n     | COH_ORG_KEY\n     | SYS_LOAD_KEY       \n     | ORIG_CUST_KEY      \n     | COLL_VEND_CONTR_KEY\n     | GL_COMBO_KEY \n     | GL_ACCT_ID\n     | FUND_ID\n     | FUND_CNTR_ID\n     | FUNC_AREA_ID\n     | ROW_CHG_RSN\n     | Nil\n\ntype FinTransViewField =\n     | INTRA_DAY_ORDER\n     | DEPT_LONG_NAME\n     | CONTR_ID\n     | CUST_PAR_ID\n     | CUST_PAR_NAME\n     | ADJ_FLAG\n     | ALLOC_TRANS_FLAG\n     | BILLED_FLAG\n     | BLK_NUM\n     | BOOT_SERIAL_NUM\n     | BUS_AREA_ID\n     | BUS_CONT_PERSON_NAME\n     | CARRIER_FIN_CLASS\n     | CARRIER_FIN_GRP\n     | CARRIER_GRP\n     | CARRIER_NAME\n     | CARRIER_PROCEDURE_BILL_CODE\n     | CARRIER_PROCEDURE_CODE\n     | CARRIER_PROCEDURE_DESCR\n     | CARRIER_PROCEDURE_SRC\n     | CARRIER_PROCEDURE_TYPE\n     | CARRIER_SRC\n     | COH_EMP_NUM\n     | COLL_PERSON_ID\n     | COLL_PERSON_NAME\n     | COLL_PERSON_TYPE\n     | CONFI_CUST_FLAG\n     | CUST_ADDR_LINE_1\n     | CUST_ADDR_LINE_2\n     | CUST_ADDR_LINE_3\n     | CUST_APT_LOT\n     | CUST_CITY\n     | CUST_CNTY\n     | CUST_CTRY\n     | CUST_EMAIL_ADDR\n     | CUST_FAX_NUM\n     | CUST_GIS_CITY\n     | CUST_GIS_LOCATR_NAME\n     | CUST_GIS_MATCH_SCORE\n     | CUST_GIS_PREFIX\n     | CUST_GIS_ST_NAME\n     | CUST_GIS_ST_NUM\n     | CUST_GIS_ST_PRETYPE\n     | CUST_GIS_ST_TYPE\n     | CUST_GIS_SUFF\n     | CUST_GIS_X\n     | CUST_GIS_Y\n     | CUST_GIS_ZIP\n     | CUST_ID\n     | CUST_IN_CITY_FLAG\n     | CUST_IS_VEND_FLAG\n     | CUST_NAME\n     | CUST_PAR_KEY\n     | CUST_PHN_NUM_1\n     | CUST_PHN_NUM_2\n     | CUST_PHN_NUM_3\n     | CUST_PREFIX\n     | CUST_SERV_LVL\n     | CUST_ST\n     | CUST_STATE\n     | CUST_ST_DIR\n     | CUST_ST_NAME\n     | CUST_ST_NUM\n     | CUST_ST_PRETYPE\n     | CUST_ST_TYPE\n     | CUST_SUFF\n     | CUST_TYPE\n     | CUST_ZIP_CODE\n     | CUST_ZIP_PLUS_4\n     | DEC_CUST_FLAG\n     | DERIVED_TRANS_FLAG\n     | DET_TRANS_CODE\n     | DET_TRANS_DESCR\n     | DIGITECH_ID\n     | DIGITECH_TRANS_TYPE\n     | DIGITECH_TRANS_TYPE_DET\n     | DIV_LONG_NAME\n     | DL_ISSUE_STATE\n     | DL_NUM\n     | DTE\n     | EMP_NAME\n     | EMP_TYPE\n     | FED_TAX_ID\n     | FIRE_ALM_AGING_RST_FLAG\n     | FIRE_ORIG_ISSUE_DTE\n     | FUNC_AREA_ID\n     | FUND_CNTR_ID\n     | FUND_ID\n     | GL_ACCT_ID\n     | HCTO_AD_VAL_ID\n     | INCDT_ADDR_LINE_1\n     | INCDT_ADDR_LINE_2\n     | INCDT_ADDR_LINE_3\n     | INCDT_APT_LOT\n     | INCDT_CAT\n     | INCDT_CITY\n     | INCDT_CNTY\n     | INCDT_CTRY\n     | INCDT_DESCR\n     | INCDT_DTE\n     | INCDT_GIS_CITY\n     | INCDT_GIS_LOCATR_NAME\n     | INCDT_GIS_MATCH_SCORE\n     | INCDT_GIS_PREFIX\n     | INCDT_GIS_ST_NAME\n     | INCDT_GIS_ST_NUM\n     | INCDT_GIS_ST_PRETYPE\n     | INCDT_GIS_ST_TYPE\n     | INCDT_GIS_SUFF\n     | INCDT_GIS_X\n     | INCDT_GIS_Y\n     | INCDT_GIS_ZIP\n     | INCDT_IN_CITY_FLAG\n     | INCDT_PREFIX\n     | INCDT_SEQ_NUM\n     | INCDT_SERV_LVL\n     | INCDT_ST\n     | INCDT_STATE\n     | INCDT_ST_DIR\n     | INCDT_ST_NAME\n     | INCDT_ST_NUM\n     | INCDT_ST_PRETYPE\n     | INCDT_ST_TYPE\n     | INCDT_SUFF\n     | INCDT_TIME\n     | INCDT_TYPE\n     | INCDT_ZIP_CODE\n     | INCDT_ZIP_PLUS_4\n     | INTRA_FUND_TRANS_AMT\n     | INTRA_FUND_TRANS_FLAG\n     | INT_EXT_EMP_FLAG\n     | INV_NUM\n     | ITEM_ADDR_LINE_1\n     | ITEM_ADDR_LINE_2\n     | ITEM_ADDR_LINE_3\n     | ITEM_APT_LOT\n     | ITEM_CITY\n     | ITEM_CNTY\n     | ITEM_CTRY\n     | ITEM_DESCR\n     | ITEM_EXMPT_FLAG\n     | ITEM_GIS_CITY\n     | ITEM_GIS_LOCATR_NAME\n     | ITEM_GIS_MATCH_SCORE\n     | ITEM_GIS_PREFIX\n     | ITEM_GIS_ST_NAME\n     | ITEM_GIS_ST_NUM\n     | ITEM_GIS_ST_PRETYPE\n     | ITEM_GIS_ST_TYPE\n     | ITEM_GIS_SUFF\n     | ITEM_GIS_X\n     | ITEM_GIS_Y\n     | ITEM_GIS_ZIP\n     | ITEM_IN_CITY_FLAG\n     | ITEM_PREFIX\n     | ITEM_SERV_LVL\n     | ITEM_ST\n     | ITEM_STAT\n     | ITEM_STATE\n     | ITEM_STAT_CHG_DTE\n     | ITEM_ST_DIR\n     | ITEM_ST_NAME\n     | ITEM_ST_NUM\n     | ITEM_ST_PRETYPE\n     | ITEM_ST_TYPE\n     | ITEM_SUFF\n     | ITEM_TYPE\n     | ITEM_ZIP_CODE\n     | ITEM_ZIP_PLUS_4\n     | JV_CUST_FLAG\n     | LOAD_DTE\n     | LOAD_TIME\n     | MAN_TRANS_FLAG\n     | MEDICAID_PAYER_CODE\n     | MEDICARE_PAYER_CODE\n     | MSTR_TRANS_TYPE\n     | NAICS_DET_CODE\n     | NAICS_DET_NAME\n     | NAICS_DIV_CODE\n     | NAICS_DIV_NAME\n     | NAICS_INDY_CODE\n     | NAICS_INDY_GRP_CODE\n     | NAICS_INDY_GRP_NAME\n     | NAICS_INDY_NAME\n     | NAICS_MAJ_GRP_CODE\n     | NAICS_MAJ_GRP_NAME\n     | ORIG_BILL_NAME\n     | PAY_METH\n     | PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\n     | PMAM_ADJMT_TO\n     | PMAM_ADJMT_TYPE\n     | PMAM_ID\n     | POST_DTE\n     | PRKG_METER_NUM\n     | PRKG_METER_VIO_FLAG\n     | RECEIVABLE_1ST_PAY_DTE\n     | RECEIVABLE_EVER_TRANS_FLAG\n     | RECEIVABLE_FNL_PAY_DTE\n     | RECEIVABLE_LITIGATION_DTE\n     | RECEIVABLE_MSTR_STAT\n     | RECEIVABLE_MSTR_STAT_CHG_DTE\n     | RECEIVABLE_SETTLEMENT_DTE\n     | RECEIVABLE_STAT\n     | RECEIVABLE_STAT_CHG_DTE\n     | RECEIVABLE_VERS_BILLING_TO_DTE\n     | RECEIVABLE_VERS_DELINQ_DTE\n     | RECEIVABLE_VERS_DUE_DTE\n     | RECEIVABLE_VERS_ISSUE_DTE\n     | RECEIVABLE_VERS_TO_DTE\n     | REINSTATEMENT_DTE\n     | RM_EMP_MSTR_KEY\n     | RM_LOAD_DTE\n     | RM_LOAD_TIME\n     | RSN_INCDT_NOT_BILLED\n     | SAP_BUS_ID\n     | SIC_CODE\n     | SIC_DIV_CODE\n     | SIC_DIV_NAME\n     | SIC_INDY_GRP_CODE\n     | SIC_INDY_GRP_NAME\n     | SIC_MAJ_GRP_CODE\n     | SIC_MAJ_GRP_NAME\n     | SIC_NAME\n     | SMARTCM_IS_ADJMT\n     | SMARTCM_IS_FEE\n     | SMARTCM_IS_PAY\n     | SMARTCM_OTHER_CRITERIA\n     | SMART_CM_ID\n     | SRC_CARRIER_KEY\n     | SRC_CARRIER_PROCEDURE_KEY\n     | SRC_SYS\n     | SRC_SYS_ID\n     | SRC_SYS_MOD_DTE\n     | SRC_SYS_TRANS_ID\n     | STATE_CORP_CHTR_ID\n     | STATE_SALES_TAX_ID\n     | T2_ID\n     | T2_TRANS_MISC_ITEM_CODE\n     | T2_TRANS_MISC_ITEM_DESCR\n     | T2_TRANS_ORIG_OBJ_TYPE_ID\n     | T2_TRANS_PARSED_DESCR\n     | T2_TRANS_RSN\n     | T2_TRANS_SCENARIO\n     | T2_TRANS_TYPE_CODE\n     | T2_TRANS_TYPE_DESCR\n     | TOWING_CMPNY\n     | TRANS_AMT\n     | TRANS_CNT\n     | UNK_CUST_AT_BILL_FLAG\n     | VERS_ASSIGNED_VEND\n     | VIO_CODE\n     | EMS_INCDT   \n     | DISPATCH_NUM\n     | FLAG_DIM_INCDT_EMS_DET\n     | DEST_LOC\n     | EMS_INCDT_CAT\n     | ORIGIN_LOC\n     | TXP_SERV_LVL\n     | TXP_TYPE\n     | VEH\n     | FLAG_DIM_ITEM_BURG_ALM_PERMIT_DET\n     | ALLOWABLE_NO_CHRG_INCDTS\n     | ALM_MNT_CMPNY\n     | ALM_TYPE\n     | PERMIT_EXP_DTE\n     | PERMIT_ISSUE_DTE\n     | PERMIT_NAME\n     | PERMIT_NUM\n     | REG_HOLDER_FLAG\n     | SUSPD_PERMIT_DTE\n     | SUSPD_PERMIT_RSN\n     | TYPE_OF_ALM_SITE\n     | FLAG_DIM_ITEM_FIRE_ALM_PERMIT_DET\n     | ALM_INSTL_CMPNY\n     | ALM_INSTL_DTE\n     | ALM_REG_KEY\n     | APPLICTN_RECV_DTE\n     | CURR_FIRE_ALM_PERMIT_FLAG\n     | EXCL_TYPE\n     | FIRE_ALM_PERMIT_ACTV_FLAG\n     | FIRE_ALM_PERMIT_NUM\n     | FIRE_ALM_PURPOSE\n     | FLAG_DIM_ITEM_LICENSED_VEH_DET\n     | LICENSE_PLATE_EXP_MTH\n     | LICENSE_PLATE_EXP_YR\n     | LICENSE_PLATE_NUM\n     | LICENSE_PLATE_TYPE\n     | OWNER_IS_CUST_FLAG\n     | SRC_SYS_VEH_ID\n     | VEH_COLOR\n     | VEH_ID_NUM\n     | VEH_MAKE\n     | VEH_MODEL\n     | VEH_MODEL_YR\n     | VEH_OWNER_ID\n     | VEH_OWNER_NAME\n     | VEH_TYPE\n     | FLAG_DIM_ITEM_PT_DET\n     | PT_AGE\n     | PT_GNDR\n     | FLAG_DIM_ITEM_TAXABLE_PROP_DET\n     | APPRAISAL_DISTR_ACCT_NUM\n     | CAN\n     | CC_JURIS_CODE\n     | CC_JURIS_DESCR\n     | CITY_RFPD_JURIS_CODE\n     | CITY_RFPD_JURIS_DESCR\n     | CONFI_ACCT_FLAG\n     | MUNIC_UTIL_DISTR_CODE\n     | MUNIC_UTIL_DISTR_DESCR\n     | NUM_OF_ACRES\n     | OWNERSHIP_EFF_DTE\n     | PROP_CLASS_CODE\n     | PROP_CLASS_DESCR\n     | REND_PENALTY_JURIS_CODE\n     | REND_PENALTY_JURIS_DESCR\n     | SCHOOL_JURIS_CODE\n     | SCHOOL_JURIS_DESCR\n     | SUBSTANTIAL_ERR_PENALTY\n     | TAX_DEFERRAL_END_DTE\n     | TAX_DEFERRAL_START_DTE\n     | TAX_ROLL_CODE\n     | TAX_ROLL_DESCR\n     | TAXABLE_PROP_LGL_DESCR_1\n     | TAXABLE_PROP_LGL_DESCR_2\n     | TAXABLE_PROP_LGL_DESCR_3\n     | TAXABLE_PROP_LGL_DESCR_4\n     | TAXABLE_PROP_LGL_DESCR_5\n     | TAXABLE_PROP_ROLL_TYPE\n     | FLAG_DIM_ITEM_WTR_ACCT_DET\n     | CURR_WTR_ACCT_FLAG\n     | DELINQ_DTE\n     | LAST_CUST_CONN_DTE\n     | LAST_CUST_CUTOFF_DTE\n     | LAST_CUST_DISCONN_DTE\n     | LAST_METER_INSPECT_DTE\n     | OWNER_RENTER\n     | SEN_CITIZEN_FLAG\n     | VAC_FLAG\n     | WTR_ACCT_NUM_OF_UNITS\n     | WTR_ACCT_ORIG_USE_TYPE\n     | WTR_ACCT_PROP_USE_TYPE\n     | WTR_METER_NUM\n     | FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\n     | ``A#3307_ATTY_FEE_DTE``\n     | ``A#3308_ATTY_FEE_DTE``\n     | ``A#3348_ATTY_FEE_DTE``\n     | AD_VAL_ACCT_LVL_ID\n     | AD_VAL_DISABLED_FLAG\n     | AD_VAL_EFF_DTE_OF_OWNERSHIP\n     | AD_VAL_HOMESTEAD_FLAG\n     | AD_VAL_OVER_66_FLAG\n     | AD_VAL_TAX_DEFERRAL_END_DTE\n     | AD_VAL_TAX_DEFERRAL_START_DTE\n     | AD_VAL_VET_FLAG\n     | COLL_LAWSUIT_NUM\n     | COLL_LGL_COND\n     | HCAD_ACCT_STAT\n     | QTRLY_PAY_FLAG\n     | FLAG_DIM_RECEIVABLE_BOOT_TOW_DET\n     | RECEIVABLE_HAS_LTR_FLAG\n     | RECEIVABLE_HAS_NOTE_FLAG\n     | RECEIVABLE_HAS_PEND_LTR_FLAG\n     | RESOLVE_DESCR\n     | RESOLVE_DTE\n     | RESOLVE_RSN\n     | RESOLVED_BY\n     | FLAG_DIM_RECEIVABLE_EMS_RECEIVABLE_DET\n     | ACTV_CARRIER\n     | ACTV_CARRIER_FIN_CLASS\n     | ACTV_CARRIER_FIN_GRP\n     | BILLING_HOLD_FLAG\n     | SIG_FLAG\n     | FLAG_DIM_RECEIVABLE_FIRE_ALM_CIT_DET\n     | VOID_CODE\n     | VOID_DESCR\n     | WORK_STAT\n     | FLAG_DIM_RECEIVABLE_PRKG_CONTRA_DET\n     | ESC_CAND_FLAG\n     | ON_ADMIN_HOLD_FLAG\n     | UNDER_APPEAL_FLAG\n     | VOID_FLAG\n     | WRITE_OFF_FLAG\n     | Nil_\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"62d0b48f-6f54-4fa2-a455-e1f288cfd0c8"},"expanded":true},{"name":"FieldDecls","content":"let fieldDecl = [|\n    (\"3307_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"3308_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"3348_ATTY_FEE_DTE\", \"datetime\", 0)\n    (\"ACCT_GRP_DESCR\", \"varchar(30)\", 0)\n    (\"ACCT_GRP_ID\", \"varchar(4)\", 0)\n    (\"ACTV_CARRIER\", \"varchar(120)\", 0)\n    (\"ACTV_CARRIER_FIN_CLASS\", \"varchar(40)\", 0)\n    (\"ACTV_CARRIER_FIN_GRP\", \"varchar(40)\", 0)\n    (\"AD_VAL_ACCT_LVL_ID\", \"varchar(4)\", 1)\n    (\"AD_VAL_DISABLED_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_EFF_DTE_OF_OWNERSHIP\", \"datetime\", 0)\n    (\"AD_VAL_HOMESTEAD_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_OVER_66_FLAG\", \"varchar(1)\", 0)\n    (\"AD_VAL_TAX_DEFERRAL_END_DTE\", \"datetime\", 0)\n    (\"AD_VAL_TAX_DEFERRAL_START_DTE\", \"datetime\", 0)\n    (\"AD_VAL_VET_FLAG\", \"varchar(1)\", 0)\n    (\"ADDR_ID\", \"varchar(10)\", 0)\n    (\"ADJ_FLAG\", \"varchar(1)\", 0)\n    (\"ALLOC_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"ALLOWABLE_NO_CHRG_INCDTS\", \"int\", 0)\n    (\"ALM_INSTL_CMPNY\", \"varchar(50)\", 0)\n    (\"ALM_INSTL_DTE\", \"datetime\", 0)\n    (\"ALM_MNT_CMPNY\", \"varchar(50)\", 0)\n    (\"ALM_REG_KEY\", \"varchar(20)\", 0)\n    (\"ALM_TYPE\", \"varchar(2)\", 0)\n    (\"ALT_PAYEE_NUM\", \"varchar(10)\", 0)\n    (\"AM_PM\", \"varchar(2)\", 0)\n    (\"APPLICTN_RECV_DTE\", \"datetime\", 0)\n    (\"APPRAISAL_DISTR_ACCT_NUM\", \"varchar(16)\", 0)\n    (\"AUTH_GRP_ID\", \"varchar(10)\", 0)\n    (\"BAL_SHT_ACCT_FLAG\", \"varchar(1)\", 0)\n    (\"BAL_UPD_IND\", \"varchar(1)\", 0)\n    (\"BILLED_FLAG\", \"varchar(1)\", 0)\n    (\"BILLING_HOLD_FLAG\", \"varchar(1)\", 0)\n    (\"BLANK_BUD_PER_ALLOWED\", \"varchar(1)\", 0)\n    (\"BLK_NUM\", \"varchar(8)\", 0)\n    (\"BOOT_SERIAL_NUM\", \"varchar(32)\", 0)\n    (\"BUS_AREA_DESCR\", \"varchar(30)\", 0)\n    (\"BUS_AREA_FULL_NAME\", \"varchar(120)\", 0)\n    (\"BUS_AREA_ID\", \"varchar(4)\", 0)\n    (\"BUS_AREA_KEY\", \"int\", 0)\n    (\"BUS_CONT_PERSON_NAME\", \"varchar(40)\", 0)\n    (\"CAL_DAY_OF_MTH_NUM\", \"int\", 0)\n    (\"CAL_MTH\", \"varchar(15)\", 0)\n    (\"CAL_MTH_NUM\", \"int\", 0)\n    (\"CAL_PER\", \"varchar(20)\", 1)\n    (\"CAL_QTR\", \"varchar(15)\", 1)\n    (\"CAL_QTR_NUM\", \"int\", 0)\n    (\"CAL_WK_ENDING_SAT\", \"varchar(15)\", 0)\n    (\"CAL_YR\", \"int\", 0)\n    (\"CAN\", \"varchar(16)\", 1)\n    (\"CARRIER_FIN_CLASS\", \"varchar(40)\", 0)\n    (\"CARRIER_FIN_GRP\", \"varchar(40)\", 0)\n    (\"CARRIER_GRP\", \"varchar(40)\", 0)\n    (\"CARRIER_KEY\", \"int\", 0)\n    (\"CARRIER_NAME\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_BILL_CODE\", \"varchar(40)\", 0)\n    (\"CARRIER_PROCEDURE_CODE\", \"varchar(40)\", 0)\n    (\"CARRIER_PROCEDURE_DESCR\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_KEY\", \"int\", 0)\n    (\"CARRIER_PROCEDURE_SRC\", \"varchar(120)\", 0)\n    (\"CARRIER_PROCEDURE_TYPE\", \"varchar(40)\", 0)\n    (\"CARRIER_SRC\", \"varchar(120)\", 0)\n    (\"CC_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"CC_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"CENTRAL_POSTING_BLK\", \"varchar(1)\", 0)\n    (\"CENTRALLY_IMPOSED_PURCH_BLK\", \"varchar(1)\", 0)\n    (\"CHGED_BY\", \"varchar(12)\", 0)\n    (\"CHGED_ON\", \"datetime\", 0)\n    (\"CHGED_ON_DTE\", \"datetime\", 0)\n    (\"CHRT_OF_ACCT_FULL_NAME\", \"varchar(120)\", 0)\n    (\"CHRT_OF_ACCT_ID\", \"varchar(4)\", 0)\n    (\"CHRT_OF_ACCT_NAME\", \"varchar(50)\", 0)\n    (\"CITY\", \"varchar(40)\", 0)\n    (\"CITY_BUS_DAY\", \"varchar(40)\", 1)\n    (\"CITY_HOL_FLAG\", \"varchar(1)\", 0)\n    (\"CITY_RFPD_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"CITY_RFPD_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"CMPNY_CODE_ID\", \"varchar(4)\", 0)\n    (\"CMPNY_CODE_NAME\", \"varchar(25)\", 0)\n    (\"COH\", \"varchar(20)\", 1)\n    (\"COH_EMP_NUM\", \"varchar(8)\", 0)\n    (\"COH_ORG_KEY\", \"int\", 0)\n    (\"COLL_BID_NUM\", \"varchar(10)\", 0)\n    (\"COLL_LAWSUIT_NUM\", \"varchar(7)\", 0)\n    (\"COLL_LGL_COND\", \"varchar(100)\", 0)\n    (\"COLL_PERSON_ID\", \"varchar(20)\", 0)\n    (\"COLL_PERSON_KEY\", \"int\", 0)\n    (\"COLL_PERSON_NAME\", \"varchar(120)\", 0)\n    (\"COLL_PERSON_TYPE\", \"varchar(40)\", 0)\n    (\"COLL_VEND_CONTR_KEY\", \"int\", 0)\n    (\"CONFI_ACCT_FLAG\", \"varchar(2)\", 1)\n    (\"CONFI_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"CONTR_DESCR\", \"varchar(1000)\", 1)\n    (\"CONTR_ID\", \"varchar(10)\", 0)\n    (\"CONTR_KEY\", \"int\", 0)\n    (\"CONTR_LIFE_PRIOD\", \"int\", 0)\n    (\"CONTR_PER_KEY\", \"int\", 0)\n    (\"CONTR_REV_STREAM\", \"varchar(50)\", 1)\n    (\"CONTR_YR\", \"varchar(15)\", 0)\n    (\"CONTR_YR_PER\", \"varchar(15)\", 0)\n    (\"CR_INFO_ID\", \"varchar(11)\", 0)\n    (\"CREATE_DTE\", \"datetime\", 0)\n    (\"CREATED_BY\", \"varchar(12)\", 0)\n    (\"CTRL_AREA_DESCR\", \"varchar(20)\", 0)\n    (\"CTRL_AREA_ID\", \"varchar(4)\", 0)\n    (\"CTRY_ID\", \"varchar(3)\", 0)\n    (\"CTRY_NAME\", \"varchar(15)\", 0)\n    (\"CURR_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"CURR_FIRE_ALM_PERMIT_FLAG\", \"varchar(1)\", 0)\n    (\"CURR_VERS_FLAG\", \"varchar(1)\", 0)\n    (\"CURR_WTR_ACCT_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"CUST_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"CUST_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"CUST_APT_LOT\", \"varchar(20)\", 0)\n    (\"CUST_CITY\", \"varchar(40)\", 1)\n    (\"CUST_CNTY\", \"varchar(20)\", 0)\n    (\"CUST_CTRY\", \"varchar(32)\", 1)\n    (\"CUST_EMAIL_ADDR\", \"varchar(100)\", 0)\n    (\"CUST_FAX_NUM\", \"varchar(15)\", 0)\n    (\"CUST_GIS_CITY\", \"varchar(20)\", 0)\n    (\"CUST_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"CUST_GIS_LAT\", \"varchar(38)\", 1)\n    (\"CUST_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_GIS_LONG\", \"varchar(38)\", 1)\n    (\"CUST_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"CUST_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"CUST_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"CUST_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"CUST_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"CUST_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"CUST_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"CUST_GIS_X\", \"varchar(21)\", 1)\n    (\"CUST_GIS_Y\", \"varchar(17)\", 1)\n    (\"CUST_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"CUST_ID\", \"varchar(120)\", 0)\n    (\"CUST_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_IS_VEND_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_KEY\", \"int\", 0)\n    (\"CUST_NAME\", \"varchar(120)\", 0)\n    (\"CUST_PAR_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"CUST_PAR_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"CUST_PAR_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"CUST_PAR_APT_LOT\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CITY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CNTY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_CTRY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_GIS_CITY\", \"varchar(20)\", 0)\n    (\"CUST_PAR_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_PAR_GIS_MATCH_SCORE\", \"varchar(3)\", 1)\n    (\"CUST_PAR_GIS_PREFIX\", \"varchar(2)\", 0)\n    (\"CUST_PAR_GIS_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_PAR_GIS_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_PAR_GIS_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_PAR_GIS_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_PAR_GIS_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_PAR_GIS_X\", \"varchar(17)\", 1)\n    (\"CUST_PAR_GIS_Y\", \"varchar(17)\", 1)\n    (\"CUST_PAR_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"CUST_PAR_ID\", \"varchar(40)\", 0)\n    (\"CUST_PAR_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"CUST_PAR_KEY\", \"int\", 0)\n    (\"CUST_PAR_NAME\", \"varchar(40)\", 0)\n    (\"CUST_PAR_PREFIX\", \"varchar(2)\", 1)\n    (\"CUST_PAR_SERV_LVL\", \"varchar(40)\", 0)\n    (\"CUST_PAR_ST\", \"varchar(100)\", 0)\n    (\"CUST_PAR_ST_DIR\", \"varchar(4)\", 0)\n    (\"CUST_PAR_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_PAR_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_PAR_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_PAR_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_PAR_STATE\", \"varchar(25)\", 0)\n    (\"CUST_PAR_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_PAR_ZIP_CODE\", \"varchar(6)\", 0)\n    (\"CUST_PAR_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"CUST_PHN_NUM_1\", \"varchar(20)\", 1)\n    (\"CUST_PHN_NUM_2\", \"varchar(20)\", 1)\n    (\"CUST_PHN_NUM_3\", \"varchar(20)\", 1)\n    (\"CUST_PREFIX\", \"varchar(2)\", 1)\n    (\"CUST_SERV_LVL\", \"varchar(40)\", 0)\n    (\"CUST_ST\", \"varchar(100)\", 0)\n    (\"CUST_ST_DIR\", \"varchar(4)\", 0)\n    (\"CUST_ST_NAME\", \"varchar(35)\", 0)\n    (\"CUST_ST_NUM\", \"varchar(7)\", 0)\n    (\"CUST_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"CUST_ST_TYPE\", \"varchar(4)\", 0)\n    (\"CUST_STATE\", \"varchar(25)\", 0)\n    (\"CUST_SUFF\", \"varchar(2)\", 0)\n    (\"CUST_TYPE\", \"varchar(13)\", 1)\n    (\"CUST_ZIP_CODE\", \"varchar(32)\", 1)\n    (\"CUST_ZIP_PLUS_4\", \"varchar(13)\", 1)\n    (\"DAY_OF_WK\", \"varchar(9)\", 0)\n    (\"DAY_OF_WK_NUM\", \"int\", 0)\n    (\"DEC_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"DEL_FLAG\", \"varchar(1)\", 0)\n    (\"DELINQ_DTE\", \"datetime\", 0)\n    (\"DELIV_POLICY_FLAG\", \"varchar(1)\", 0)\n    (\"DEPT_LONG_NAME\", \"varchar(120)\", 1)\n    (\"DEPT_NAME\", \"varchar(30)\", 1)\n    (\"DERIVED_NODE_FLAG\", \"varchar(1)\", 0)\n    (\"DERIVED_PAR_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"DERIVED_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"DEST_LOC\", \"varchar(120)\", 0)\n    (\"DET_TRANS_CODE\", \"varchar(20)\", 0)\n    (\"DET_TRANS_DESCR\", \"varchar(50)\", 0)\n    (\"DIGITECH_ID\", \"varchar(20)\", 1)\n    (\"DIGITECH_TRANS_TYPE\", \"varchar(40)\", 1)\n    (\"DIGITECH_TRANS_TYPE_DET\", \"varchar(120)\", 1)\n    (\"DISASTER_FLAG\", \"varchar(1)\", 0)\n    (\"DISPATCH_NUM\", \"varchar(40)\", 0)\n    (\"DISTR\", \"varchar(40)\", 0)\n    (\"DIV_LONG_NAME\", \"varchar(120)\", 1)\n    (\"DIV_NAME\", \"varchar(30)\", 1)\n    (\"DL_ISSUE_STATE\", \"varchar(20)\", 0)\n    (\"DL_NUM\", \"varchar(20)\", 0)\n    (\"DST_EX_MIN_FLAG\", \"varchar(1)\", 0)\n    (\"DTE\", \"date\", 0)\n    (\"DTE_FISC_PER_KEY\", \"int\", 0)\n    (\"DTE_KEY\", \"int\", 0)\n    (\"EMP_KEY\", \"int\", 0)\n    (\"EMP_NAME\", \"varchar(120)\", 0)\n    (\"EMP_TYPE\", \"varchar(40)\", 0)\n    (\"EMS_INCDT\", \"varchar(40)\", 0)\n    (\"EMS_INCDT_CAT\", \"varchar(120)\", 0)\n    (\"ENTRY_DTE\", \"datetime\", 0)\n    (\"ESC_CAND_FLAG\", \"varchar(1)\", 0)\n    (\"ETL_PROC_USED\", \"varchar(50)\", 0)\n    (\"EXCH_RATE_LOCAL\", \"numeric\", 0)\n    (\"EXCL_TYPE\", \"varchar(50)\", 0)\n    (\"EXP_DTE\", \"datetime\", 0)\n    (\"EXTRACT_DTE_TIME\", \"datetime\", 0)\n    (\"EXTRACT_PROC_USED\", \"varchar(50)\", 0)\n    (\"FAX\", \"varchar(40)\", 0)\n    (\"FED_FISC_PER\", \"varchar(15)\", 0)\n    (\"FED_FISC_PER_NUM\", \"int\", 0)\n    (\"FED_FISC_QTR\", \"varchar(15)\", 1)\n    (\"FED_FISC_QTR_NUM\", \"int\", 0)\n    (\"FED_FISC_YR\", \"varchar(15)\", 1)\n    (\"FED_TAX_ID\", \"varchar(40)\", 0)\n    (\"FG_FIN_TRANS_KEY\", \"int\", 0)\n    (\"FIN_MGMT_AREA\", \"varchar(4)\", 0)\n    (\"FIN_MGMT_AREA_DESCR\", \"varchar(25)\", 0)\n    (\"FIN_TRANS_TYPE_KEY\", \"int\", 0)\n    (\"FIRE_ALM_AGING_RST_FLAG\", \"varchar(1)\", 0)\n    (\"FIRE_ALM_PERMIT_ACTV_FLAG\", \"varchar(1)\", 0)\n    (\"FIRE_ALM_PERMIT_NUM\", \"varchar(20)\", 0)\n    (\"FIRE_ALM_PURPOSE\", \"varchar(50)\", 0)\n    (\"FIRE_ORIG_ISSUE_DTE\", \"datetime\", 0)\n    (\"FISC_PER\", \"varchar(15)\", 0)\n    (\"FISC_PER_ANNUAL_SORT_ORD\", \"int\", 0)\n    (\"FISC_PER_NUM\", \"int\", 0)\n    (\"FISC_QTR\", \"varchar(15)\", 0)\n    (\"FISC_QTR_NUM\", \"int\", 0)\n    (\"FISC_YR\", \"int\", 0)\n    (\"FISC_YR_VARIANT\", \"varchar(2)\", 0)\n    (\"FM_AUTH_GRP\", \"varchar(10)\", 0)\n    (\"FM_FINUSE\", \"varchar(16)\", 0)\n    (\"FM_SPONSER\", \"varchar(10)\", 0)\n    (\"FUNC_AREA_DESCR\", \"varchar(30)\", 0)\n    (\"FUNC_AREA_FULL_NAME\", \"varchar(120)\", 0)\n    (\"FUNC_AREA_ID\", \"varchar(16)\", 0)\n    (\"FUNC_AREA_KEY\", \"int\", 0)\n    (\"FUNC_THAT_WILL_BE_BLKED\", \"varchar(2)\", 1)\n    (\"FUND_BUD_PROF\", \"varchar(6)\", 0)\n    (\"FUND_CNTR_DESCR\", \"varchar(40)\", 0)\n    (\"FUND_CNTR_FULL_NAME\", \"varchar(120)\", 0)\n    (\"FUND_CNTR_ID\", \"varchar(16)\", 0)\n    (\"FUND_CNTR_KEY\", \"int\", 0)\n    (\"FUND_CNTR_NAME\", \"varchar(20)\", 0)\n    (\"FUND_DESCR\", \"varchar(40)\", 0)\n    (\"FUND_ID\", \"varchar(10)\", 0)\n    (\"FUND_KEY\", \"int\", 0)\n    (\"FUND_NAME\", \"varchar(20)\", 0)\n    (\"FUND_SUBSTR1\", \"varchar(10)\", 0)\n    (\"FUND_SUBSTR2\", \"varchar(10)\", 0)\n    (\"FUND_TYPE_DESCR\", \"varchar(35)\", 0)\n    (\"FUND_TYPE_ID\", \"varchar(6)\", 0)\n    (\"GL_ACCT_FULL_NAME\", \"varchar(120)\", 0)\n    (\"GL_ACCT_GRP\", \"varchar(4)\", 0)\n    (\"GL_ACCT_ID\", \"varchar(30)\", 0)\n    (\"GL_ACCT_KEY\", \"int\", 0)\n    (\"GL_ACCT_MSTR_DESCR\", \"varchar(64)\", 0)\n    (\"GL_COMBO_KEY\", \"int\", 0)\n    (\"GRP_ACCT_NUM\", \"varchar(10)\", 0)\n    (\"HCAD_ACCT_STAT\", \"varchar(100)\", 0)\n    (\"HCTO_AD_VAL_ID\", \"varchar(22)\", 1)\n    (\"HCTO_DET_TRANS_DESCR\", \"varchar(50)\", 1)\n    (\"HCTO_FISC_PER\", \"varchar(15)\", 0)\n    (\"HCTO_FISC_PER_NUM\", \"int\", 0)\n    (\"HCTO_FISC_QTR\", \"varchar(15)\", 1)\n    (\"HCTO_FISC_QTR_NUM\", \"int\", 0)\n    (\"HCTO_FISC_YR\", \"varchar(15)\", 1)\n    (\"HH\", \"varchar(2)\", 0)\n    (\"HIER_ID\", \"varchar(30)\", 0)\n    (\"HOL_DESCR\", \"varchar(40)\", 1)\n    (\"HOUSE_NUM\", \"varchar(10)\", 0)\n    (\"INCDT_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"INCDT_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"INCDT_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"INCDT_APT_LOT\", \"varchar(20)\", 0)\n    (\"INCDT_CAT\", \"varchar(40)\", 0)\n    (\"INCDT_CITY\", \"varchar(20)\", 0)\n    (\"INCDT_CNTY\", \"varchar(20)\", 0)\n    (\"INCDT_CTRY\", \"varchar(20)\", 0)\n    (\"INCDT_DESCR\", \"varchar(40)\", 0)\n    (\"INCDT_DTE\", \"datetime\", 0)\n    (\"INCDT_GIS_CITY\", \"varchar(20)\", 0)\n    (\"INCDT_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"INCDT_GIS_LAT\", \"varchar(38)\", 1)\n    (\"INCDT_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"INCDT_GIS_LONG\", \"varchar(38)\", 1)\n    (\"INCDT_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"INCDT_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"INCDT_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"INCDT_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"INCDT_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"INCDT_GIS_X\", \"varchar(21)\", 1)\n    (\"INCDT_GIS_Y\", \"varchar(17)\", 0)\n    (\"INCDT_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"INCDT_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"INCDT_KEY\", \"int\", 0)\n    (\"INCDT_PREFIX\", \"varchar(2)\", 0)\n    (\"INCDT_SEQ_NUM\", \"varchar(10)\", 0)\n    (\"INCDT_SERV_LVL\", \"varchar(120)\", 0)\n    (\"INCDT_ST\", \"varchar(100)\", 0)\n    (\"INCDT_ST_DIR\", \"varchar(4)\", 0)\n    (\"INCDT_ST_NAME\", \"varchar(35)\", 0)\n    (\"INCDT_ST_NUM\", \"varchar(7)\", 0)\n    (\"INCDT_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"INCDT_ST_TYPE\", \"varchar(4)\", 0)\n    (\"INCDT_STATE\", \"varchar(25)\", 0)\n    (\"INCDT_SUFF\", \"varchar(2)\", 0)\n    (\"INCDT_TIME\", \"varchar(8)\", 0)\n    (\"INCDT_TYPE\", \"varchar(40)\", 0)\n    (\"INCDT_ZIP_CODE\", \"varchar(6)\", 0)\n    (\"INCDT_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"INDY_DESCR\", \"varchar(20)\", 0)\n    (\"INDY_ID\", \"varchar(4)\", 0)\n    (\"INT_EXT_EMP_FLAG\", \"varchar(1)\", 0)\n    (\"INTER_CMPNY_TERM02_NAME\", \"varchar(28)\", 0)\n    (\"INTRA_FUND_TRANS_AMT\", \"money\", 1)\n    (\"INTRA_FUND_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"INV_NUM\", \"varchar(40)\", 0)\n    (\"INVALID INPUT\", \"nvarchar(100)\", 1)\n    (\"INVALID INPUT ERROR DESCRIPTION\", \"nvarchar(1000)\", 1)\n    (\"ITEM_ADDR_LINE_1\", \"varchar(200)\", 0)\n    (\"ITEM_ADDR_LINE_2\", \"varchar(200)\", 0)\n    (\"ITEM_ADDR_LINE_3\", \"varchar(200)\", 0)\n    (\"ITEM_APT_LOT\", \"varchar(20)\", 0)\n    (\"ITEM_CITY\", \"varchar(20)\", 0)\n    (\"ITEM_CNTY\", \"varchar(20)\", 0)\n    (\"ITEM_CTRY\", \"varchar(20)\", 0)\n    (\"ITEM_DESCR\", \"varchar(255)\", 1)\n    (\"ITEM_EXMPT_FLAG\", \"varchar(1)\", 0)\n    (\"ITEM_GIS_CITY\", \"varchar(20)\", 0)\n    (\"ITEM_GIS_CMPLT_MATCH_ADDR\", \"varchar(200)\", 1)\n    (\"ITEM_GIS_LAT\", \"varchar(38)\", 1)\n    (\"ITEM_GIS_LOCATR_NAME\", \"varchar(40)\", 0)\n    (\"ITEM_GIS_LONG\", \"varchar(38)\", 1)\n    (\"ITEM_GIS_MATCH_SCORE\", \"varchar(10)\", 1)\n    (\"ITEM_GIS_PREFIX\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_ST_NAME\", \"varchar(60)\", 1)\n    (\"ITEM_GIS_ST_NUM\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_ST_PRETYPE\", \"varchar(40)\", 1)\n    (\"ITEM_GIS_ST_TYPE\", \"varchar(40)\", 1)\n    (\"ITEM_GIS_SUFF\", \"varchar(12)\", 1)\n    (\"ITEM_GIS_X\", \"varchar(21)\", 1)\n    (\"ITEM_GIS_Y\", \"varchar(17)\", 0)\n    (\"ITEM_GIS_ZIP\", \"varchar(5)\", 0)\n    (\"ITEM_IN_CITY_FLAG\", \"varchar(1)\", 0)\n    (\"ITEM_KEY\", \"int\", 0)\n    (\"ITEM_PREFIX\", \"varchar(2)\", 0)\n    (\"ITEM_SERV_LVL\", \"varchar(40)\", 0)\n    (\"ITEM_ST\", \"varchar(100)\", 0)\n    (\"ITEM_ST_DIR\", \"varchar(4)\", 0)\n    (\"ITEM_ST_NAME\", \"varchar(35)\", 0)\n    (\"ITEM_ST_NUM\", \"varchar(13)\", 1)\n    (\"ITEM_ST_PRETYPE\", \"varchar(15)\", 0)\n    (\"ITEM_ST_TYPE\", \"varchar(4)\", 0)\n    (\"ITEM_STAT\", \"varchar(40)\", 0)\n    (\"ITEM_STAT_CHG_DTE\", \"datetime\", 0)\n    (\"ITEM_STATE\", \"varchar(25)\", 0)\n    (\"ITEM_SUFF\", \"varchar(2)\", 0)\n    (\"ITEM_TYPE\", \"varchar(40)\", 0)\n    (\"ITEM_ZIP_CODE\", \"varchar(13)\", 1)\n    (\"ITEM_ZIP_PLUS_4\", \"varchar(11)\", 0)\n    (\"JV_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"LANG_ID\", \"varchar(1)\", 0)\n    (\"LAST_CUST_CONN_DTE\", \"datetime\", 0)\n    (\"LAST_CUST_CUTOFF_DTE\", \"datetime\", 0)\n    (\"LAST_CUST_DISCONN_DTE\", \"datetime\", 0)\n    (\"LAST_METER_INSPECT_DTE\", \"datetime\", 0)\n    (\"LICENSE_PLATE_EXP_MTH\", \"varchar(3)\", 0)\n    (\"LICENSE_PLATE_EXP_YR\", \"varchar(4)\", 0)\n    (\"LICENSE_PLATE_NUM\", \"varchar(10)\", 0)\n    (\"LICENSE_PLATE_TYPE\", \"varchar(20)\", 0)\n    (\"LOAD_DTE\", \"datetime\", 0)\n    (\"LOAD_DTE_TIME\", \"datetime\", 0)\n    (\"LOAD_TIME\", \"varchar(8)\", 0)\n    (\"LOGICAL_SYS\", \"varchar(10)\", 0)\n    (\"MAN_TRANS_FLAG\", \"varchar(1)\", 0)\n    (\"MEDICAID_PAYER_CODE\", \"varchar(40)\", 0)\n    (\"MEDICARE_PAYER_CODE\", \"varchar(40)\", 0)\n    (\"MIN\", \"varchar(5)\", 0)\n    (\"MSTR_REC_CNTRL_DEL_BLK\", \"varchar(1)\", 0)\n    (\"MSTR_SUBDIV_ID\", \"varchar(10)\", 0)\n    (\"MSTR_TRANS_TYPE\", \"varchar(20)\", 0)\n    (\"MUNIC_UTIL_DISTR_CODE\", \"varchar(13)\", 1)\n    (\"MUNIC_UTIL_DISTR_DESCR\", \"varchar(50)\", 0)\n    (\"NAICS_DET_CODE\", \"varchar(6)\", 0)\n    (\"NAICS_DET_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_DIV_CODE\", \"varchar(2)\", 0)\n    (\"NAICS_DIV_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_INDY_CODE\", \"varchar(5)\", 0)\n    (\"NAICS_INDY_GRP_CODE\", \"varchar(4)\", 0)\n    (\"NAICS_INDY_GRP_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_INDY_NAME\", \"varchar(40)\", 0)\n    (\"NAICS_MAJ_GRP_CODE\", \"varchar(3)\", 0)\n    (\"NAICS_MAJ_GRP_NAME\", \"varchar(40)\", 0)\n    (\"NODE_FLAG\", \"varchar(1)\", 0)\n    (\"NUM_OF_ACRES\", \"varchar(13)\", 1)\n    (\"ON_ADMIN_HOLD_FLAG\", \"varchar(1)\", 0)\n    (\"ONE_TIME_ACCT_DESCR\", \"varchar(5)\", 0)\n    (\"ORIG_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"ORIG_BILL_NAME\", \"varchar(120)\", 1)\n    (\"ORIG_CUST_KEY\", \"int\", 0)\n    (\"ORIG_INV_NUM\", \"varchar(40)\", 0)\n    (\"ORIGIN_LOC\", \"varchar(120)\", 0)\n    (\"OWNER_IS_CUST_FLAG\", \"varchar(1)\", 0)\n    (\"OWNER_RENTER\", \"varchar(1)\", 0)\n    (\"OWNERSHIP_EFF_DTE\", \"datetime\", 0)\n    (\"PAY_BLK\", \"varchar(1)\", 0)\n    (\"PAY_METH\", \"varchar(15)\", 0)\n    (\"PAYROLL_PER\", \"int\", 0)\n    (\"PER_END_DTE\", \"date\", 1)\n    (\"PERMIT_EXP_DTE\", \"datetime\", 0)\n    (\"PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\", \"varchar(1)\", 0)\n    (\"PERMIT_ISSUE_DTE\", \"datetime\", 0)\n    (\"PERMIT_NAME\", \"varchar(120)\", 0)\n    (\"PERMIT_NUM\", \"int\", 0)\n    (\"PERSON_IN_CHRG\", \"varchar(20)\", 0)\n    (\"PERSON_IN_CHRG_ID\", \"varchar(8)\", 0)\n    (\"PHN\", \"varchar(30)\", 0)\n    (\"PL_STMNT_ACCT_TYPE\", \"varchar(2)\", 0)\n    (\"PLANT_ID\", \"varchar(4)\", 0)\n    (\"PLANT_NAME\", \"varchar(30)\", 0)\n    (\"PMAM_ADJMT_TO\", \"varchar(20)\", 1)\n    (\"PMAM_ADJMT_TYPE\", \"varchar(50)\", 1)\n    (\"PMAM_ID\", \"varchar(20)\", 0)\n    (\"POST_DTE_KEY\", \"int\", 1)\n    (\"PRKG_METER_NUM\", \"varchar(8)\", 0)\n    (\"PRKG_METER_VIO_FLAG\", \"varchar(1)\", 0)\n    (\"PROP_CLASS_CODE\", \"varchar(13)\", 1)\n    (\"PROP_CLASS_DESCR\", \"varchar(50)\", 0)\n    (\"PT_AGE\", \"varchar(3)\", 0)\n    (\"PT_GNDR\", \"varchar(10)\", 0)\n    (\"QTRLY_PAY_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_1ST_PAY_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_CURR_BILLING_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_CURR_DELINQ_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_DUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_ISSUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_CURR_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_EVER_TRANS_FLAG\", \"varchar(1)\", 1)\n    (\"RECEIVABLE_FNL_PAY_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_HAS_LTR_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_HAS_NOTE_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_HAS_PEND_LTR_FLAG\", \"varchar(1)\", 0)\n    (\"RECEIVABLE_KEY\", \"int\", 0)\n    (\"RECEIVABLE_LITIGATION_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_MSTR_STAT\", \"varchar(40)\", 1)\n    (\"RECEIVABLE_MSTR_STAT_CHG_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_BILLING_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_DELINQ_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_DUE_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_ISSUE_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_ORIG_TO_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_SETTLEMENT_DTE\", \"datetime\", 1)\n    (\"RECEIVABLE_STAT\", \"varchar(40)\", 0)\n    (\"RECEIVABLE_STAT_CHG_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_BILLING_TO_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_DELINQ_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_DUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_ISSUE_DTE\", \"datetime\", 0)\n    (\"RECEIVABLE_VERS_TO_DTE\", \"datetime\", 0)\n    (\"REG_HOLDER_FLAG\", \"varchar(1)\", 0)\n    (\"REGION_ID\", \"varchar(3)\", 0)\n    (\"REGION_NAME\", \"varchar(20)\", 0)\n    (\"REINSTATEMENT_DTE\", \"datetime\", 1)\n    (\"RELE_REAL_COVER_ELIG\", \"varchar(1)\", 0)\n    (\"REND_PENALTY_JURIS_CODE\", \"varchar(13)\", 1)\n    (\"REND_PENALTY_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"RESOLVE_DESCR\", \"varchar(128)\", 0)\n    (\"RESOLVE_DTE\", \"datetime\", 1)\n    (\"RESOLVE_RSN\", \"varchar(40)\", 1)\n    (\"RESOLVED_BY\", \"varchar(120)\", 0)\n    (\"REVERSAL_DTE\", \"datetime\", 0)\n    (\"RM_EMP_MSTR_KEY\", \"varchar(16)\", 1)\n    (\"RM_LOAD_DTE\", \"datetime\", 0)\n    (\"RM_LOAD_TIME\", \"varchar(8)\", 0)\n    (\"ROW_CHG_RSN\", \"varchar(100)\", 1)\n    (\"RSN_INCDT_NOT_BILLED\", \"varchar(40)\", 0)\n    (\"SAP_BUS_ID\", \"varchar(20)\", 0)\n    (\"SCHOOL_JURIS_CODE\", \"varchar(22)\", 1)\n    (\"SCHOOL_JURIS_DESCR\", \"varchar(50)\", 0)\n    (\"SCND_TEL_NUM\", \"varchar(16)\", 0)\n    (\"SEN_CITIZEN_FLAG\", \"varchar(1)\", 0)\n    (\"SIC_CODE\", \"varchar(8)\", 0)\n    (\"SIC_DIV_CODE\", \"varchar(20)\", 0)\n    (\"SIC_DIV_NAME\", \"varchar(40)\", 0)\n    (\"SIC_INDY_GRP_CODE\", \"varchar(3)\", 0)\n    (\"SIC_INDY_GRP_NAME\", \"varchar(40)\", 0)\n    (\"SIC_MAJ_GRP_CODE\", \"varchar(2)\", 0)\n    (\"SIC_MAJ_GRP_NAME\", \"varchar(40)\", 0)\n    (\"SIC_NAME\", \"varchar(40)\", 0)\n    (\"SIG_FLAG\", \"varchar(1)\", 0)\n    (\"SMART_CM_ID\", \"varchar(20)\", 0)\n    (\"SMARTCM_IS_ADJMT\", \"varchar(1)\", 1)\n    (\"SMARTCM_IS_FEE\", \"varchar(1)\", 1)\n    (\"SMARTCM_IS_PAY\", \"varchar(1)\", 1)\n    (\"SMARTCM_OTHER_CRITERIA\", \"varchar(50)\", 1)\n    (\"SRC_CARRIER_KEY\", \"varchar(40)\", 0)\n    (\"SRC_CARRIER_PROCEDURE_KEY\", \"varchar(40)\", 0)\n    (\"SRC_SYS\", \"varchar(40)\", 0)\n    (\"SRC_SYS_ID\", \"varchar(120)\", 0)\n    (\"SRC_SYS_MOD_DTE\", \"datetime\", 1)\n    (\"SRC_SYS_TRANS_ID\", \"varchar(40)\", 1)\n    (\"SRC_SYS_VEH_ID\", \"varchar(32)\", 1)\n    (\"ST\", \"varchar(60)\", 0)\n    (\"STATE_CORP_CHTR_ID\", \"varchar(20)\", 0)\n    (\"STATE_FISC_PER\", \"varchar(15)\", 0)\n    (\"STATE_FISC_PER_NUM\", \"int\", 0)\n    (\"STATE_FISC_QTR\", \"varchar(15)\", 1)\n    (\"STATE_FISC_QTR_NUM\", \"int\", 0)\n    (\"STATE_FISC_YR\", \"varchar(15)\", 1)\n    (\"STATE_SALES_TAX_ID\", \"varchar(20)\", 0)\n    (\"SUBSTANTIAL_ERR_PENALTY\", \"varchar(1)\", 0)\n    (\"SUSPD_PERMIT_DTE\", \"datetime\", 0)\n    (\"SUSPD_PERMIT_RSN\", \"varchar(50)\", 0)\n    (\"SYS_LOAD_KEY\", \"int\", 0)\n    (\"T2_ID\", \"varchar(20)\", 0)\n    (\"T2_TRANS_MISC_ITEM_CODE\", \"varchar(20)\", 0)\n    (\"T2_TRANS_MISC_ITEM_DESCR\", \"varchar(50)\", 0)\n    (\"T2_TRANS_ORIG_OBJ_TYPE_ID\", \"varchar(10)\", 0)\n    (\"T2_TRANS_PARSED_DESCR\", \"varchar(50)\", 0)\n    (\"T2_TRANS_RSN\", \"varchar(50)\", 0)\n    (\"T2_TRANS_SCENARIO\", \"varchar(50)\", 0)\n    (\"T2_TRANS_TYPE_CODE\", \"varchar(20)\", 0)\n    (\"T2_TRANS_TYPE_DESCR\", \"varchar(50)\", 0)\n    (\"TAX_DEFERRAL_END_DTE\", \"datetime\", 0)\n    (\"TAX_DEFERRAL_START_DTE\", \"datetime\", 0)\n    (\"TAX_NUM_1\", \"varchar(16)\", 0)\n    (\"TAX_NUM_2\", \"varchar(11)\", 0)\n    (\"TAX_ROLL_CODE\", \"varchar(13)\", 1)\n    (\"TAX_ROLL_DESCR\", \"varchar(50)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_1\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_2\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_3\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_4\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_LGL_DESCR_5\", \"varchar(40)\", 0)\n    (\"TAXABLE_PROP_ROLL_TYPE\", \"varchar(50)\", 0)\n    (\"TIME_KEY\", \"int\", 0)\n    (\"TOWING_CMPNY\", \"varchar(40)\", 0)\n    (\"TRADING_PRN_ID\", \"varchar(6)\", 0)\n    (\"TRADING_PRN_NAME\", \"varchar(30)\", 0)\n    (\"TRANS_AMT\", \"money\", 1)\n    (\"TRANS_CNT\", \"int\", 1)\n    (\"TRANS_DTE_KEY\", \"int\", 0)\n    (\"TXP_SERV_LVL\", \"varchar(120)\", 0)\n    (\"TXP_TYPE\", \"varchar(40)\", 0)\n    (\"TYPE_OF_ALM_SITE\", \"varchar(1)\", 0)\n    (\"UNDER_APPEAL_FLAG\", \"varchar(1)\", 0)\n    (\"UNIQ_VEND_NAME\", \"varchar(120)\", 1)\n    (\"UNK_CUST_AT_BILL_FLAG\", \"varchar(1)\", 1)\n    (\"VAC_FLAG\", \"varchar(1)\", 0)\n    (\"VALID_FROM_DTE\", \"datetime\", 0)\n    (\"VALID_TO_DTE\", \"datetime\", 0)\n    (\"VEH\", \"varchar(40)\", 0)\n    (\"VEH_COLOR\", \"varchar(40)\", 0)\n    (\"VEH_ID_NUM\", \"varchar(24)\", 0)\n    (\"VEH_MAKE\", \"varchar(40)\", 0)\n    (\"VEH_MODEL\", \"varchar(40)\", 0)\n    (\"VEH_MODEL_YR\", \"varchar(4)\", 0)\n    (\"VEH_OWNER_ID\", \"varchar(32)\", 0)\n    (\"VEH_OWNER_NAME\", \"varchar(120)\", 0)\n    (\"VEH_TYPE\", \"varchar(40)\", 0)\n    (\"VEND_BILLER_FLAG\", \"varchar(1)\", 1)\n    (\"VEND_COLLR_FLAG\", \"varchar(1)\", 1)\n    (\"VEND_CUST_ID\", \"varchar(10)\", 0)\n    (\"VEND_CUST_NAME\", \"varchar(40)\", 0)\n    (\"VEND_FULL_NAME\", \"varchar(120)\", 0)\n    (\"VEND_GRP_KEY\", \"varchar(10)\", 0)\n    (\"VEND_ID\", \"varchar(10)\", 0)\n    (\"VEND_KEY\", \"int\", 0)\n    (\"VEND_NAME\", \"varchar(40)\", 0)\n    (\"VEND_NAME_01\", \"varchar(40)\", 0)\n    (\"VEND_NAME_02\", \"varchar(40)\", 0)\n    (\"VEND_NAME_03\", \"varchar(40)\", 0)\n    (\"VEND_NAME_04\", \"varchar(40)\", 0)\n    (\"VERS_ASSIGNED_VEND\", \"varchar(120)\", 1)\n    (\"VERS_BEG_DTE\", \"datetime\", 0)\n    (\"VERS_END_DTE\", \"datetime\", 0)\n    (\"VIO_CODE\", \"varchar(20)\", 0)\n    (\"VOID_CODE\", \"varchar(10)\", 0)\n    (\"VOID_DESCR\", \"varchar(50)\", 0)\n    (\"VOID_FLAG\", \"varchar(1)\", 0)\n    (\"WK_IN_CAL_YR\", \"int\", 0)\n    (\"WKND_FLAG\", \"varchar(1)\", 0)\n    (\"WORK_STAT\", \"varchar(50)\", 0)\n    (\"WRITE_OFF_FLAG\", \"varchar(1)\", 0)\n    (\"WTR_ACCT_NUM_OF_UNITS\", \"int\", 0)\n    (\"WTR_ACCT_ORIG_USE_TYPE\", \"varchar(120)\", 0)\n    (\"WTR_ACCT_PROP_USE_TYPE\", \"varchar(120)\", 0)\n    (\"WTR_METER_NUM\", \"varchar(50)\", 0)\n    (\"ZIP\", \"varchar(10)\", 0) |]","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"133131ac-9ee5-47b2-8047-351746ee9e10"},"expanded":true},{"name":"FieldDefaults","content":"let fieldDefault = [|\n    (\"LOAD_DTE\"                            , \"GETDATE()\"   )\n    (\"LOAD_TIME\"                           , \"CONVERT(VARCHAR(8),GETDATE(),108)\")\n    (\"VERS_ASSIGNED_VEND\"                  , \"'CoH'\")\n    (\"MEDICARE_PAYER_CODE\"                 , \"'(SYS) UNKNOWN'\")\n    (\"MEDICAID_PAYER_CODE\"                 , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_FIN_GRP\"                     , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_FIN_CLASS\"                   , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_GRP\"                         , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_NAME\"                        , \"'(SYS) UNKNOWN'\")\n    (\"SRC_CARRIER_CODE\"                    , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_CODE\"              , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_DESCR\"             , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_TYPE\"              , \"'(SYS) UNKNOWN'\")\n    (\"CARRIER_PROCEDURE_BILL_CODE\"         , \"'(SYS) UNKNOWN'\")\n    (\"VEH\"                                 , \"'(SYS) UNKNOWN'\")\n    (\"EMS_INCDT_CAT\"                       , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER_FIN_GRP\"                , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER_FIN_CLASS\"              , \"'(SYS) UNKNOWN'\")\n    (\"ACTV_CARRIER\"                        , \"'(SYS) UNKNOWN'\")\n    (\"NAICS_DET_CODE\"                      , \"'*'\")\n    (\"NAICS_DIV_CODE\"                      , \"'*'\")\n    (\"SIC_MAJ_GRP_CODE\"                    , \"'*'\")\n    (\"DEC_CUST_FLAG\"                       , \"'*'\")\n    (\"CUST_PREFIX\"                         , \"'*'\")\n    (\"CUST_SUFF\"                           , \"'*'\")\n    (\"CUST_GIS_PREFIX\"                     , \"'*'\")\n    (\"CUST_GIS_SUFF\"                       , \"'*'\")\n    (\"ALLOC_TRANS_FLAG\"                    , \"'*'\")\n    (\"SMARTCM_OTHER_CRITERIA\"              , \"'*'\")\n    (\"SMARTCM_IS_FEE\"                      , \"'*'\")\n    (\"SMARTCM_IS_ADJMT\"                    , \"'*'\")\n    (\"SMARTCM_IS_PAY\"                      , \"'*'\")\n    (\"PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG\", \"'*'\")\n    (\"PRKG_METER_VIO_FLAG\"                 , \"'*'\")\n    (\"INCDT_PREFIX\"                        , \"'*'\")\n    (\"INCDT_SUFF\"                          , \"'*'\")\n    (\"INCDT_IN_CITY_FLAG\"                  , \"'*'\")\n    (\"INCDT_GIS_PREFIX\"                    , \"'*'\")\n    (\"INCDT_GIS_SUFF\"                      , \"'*'\")\n    (\"ITEM_EXMPT_FLAG\"                     , \"'*'\")\n    (\"ITEM_PREFIX\"                         , \"'*'\")\n    (\"ITEM_SUFF\"                           , \"'*'\")\n    (\"ITEM_GIS_PREFIX\"                     , \"'*'\")\n    (\"ITEM_GIS_SUFF\"                       , \"'*'\")\n    (\"FIRE_ALM_AGING_RST_FLAG\"             , \"'*'\")\n    (\"AD_VAL_VET_FLAG\"                     , \"'*'\")\n    (\"AD_VAL_DISABLED_FLAG\"                , \"'*'\")\n    (\"AD_VAL_OVER_66_FLAG\"                 , \"'*'\")\n    (\"AD_VAL_HOMESTEAD_FLAG\"               , \"'*'\")\n    (\"QTRLY_PAY_FLAG\"                      , \"'*'\")\n    (\"SRC_CARRIER_KEY\"                     , \"'***'\")\n    (\"SRC_CARRIER_PROCEDURE_KEY\"           , \"'***'\")\n    (\"COLL_PERSON_ID\"                      , \"'***'\")\n    (\"T2_ID\"                               , \"'***'\")\n    (\"PMAM_ID\"                             , \"'***'\")\n    (\"SMART_CM_ID\"                         , \"'***'\")\n    (\"HCTO_AD_VAL_ID\"                      , \"'***'\")\n    (\"COLL_PERSON_COH_EMP_NUM\"             , \"'***'\")\n    (\"CUST_EMAIL_ADDR\"                     , \"'***'\")\n    (\"CUST_PHN_NUM_1\"                      , \"'***'\")\n    (\"CUST_FAX_NUM\"                        , \"'***'\")\n    (\"FED_TAX_ID\"                          , \"'***'\")\n    (\"BUS_CONT_PERSON_NAME\"                , \"'***'\")\n    (\"STATE_CORP_CHTR_ID\"                  , \"'***'\")\n    (\"STATE_SALES_TAX_ID\"                  , \"'***'\")\n    (\"SAP_BUS_ID\"                          , \"'***'\")\n    (\"NAICS_INDY_CODE\"                     , \"'***'\")\n    (\"NAICS_INDY_GRP_CODE\"                 , \"'***'\")\n    (\"NAICS_MAJ_GRP_CODE\"                  , \"'***'\")\n    (\"SIC_INDY_GRP_CODE\"                   , \"'***'\")\n    (\"SIC_DIV_CODE\"                        , \"'***'\")\n    (\"DL_ISSUE_STATE\"                      , \"'***'\")\n    (\"DL_NUM\"                              , \"'***'\")\n    (\"CUST_ADDR_LINE_1\"                    , \"'***'\")\n    (\"CUST_ADDR_LINE_2\"                    , \"'***'\")\n    (\"CUST_ADDR_LINE_3\"                    , \"'***'\")\n    (\"CUST_ST_NUM\"                         , \"'***'\")\n    (\"CUST_ST_PRETYPE\"                     , \"'***'\")\n    (\"CUST_ST_NAME\"                        , \"'***'\")\n    (\"CUST_ST_TYPE\"                        , \"'***'\")\n    (\"CUST_SERV_LVL\"                       , \"'***'\")\n    (\"CUST_CITY\"                           , \"'***'\")\n    (\"CUST_STATE\"                          , \"'***'\")\n    (\"CUST_CTRY\"                           , \"'***'\")\n    (\"CUST_ST_DIR\"                         , \"'***'\")\n    (\"CUST_ST\"                             , \"'***'\")\n    (\"CUST_CNTY\"                           , \"'***'\")\n    (\"CUST_APT_LOT\"                        , \"'***'\")\n    (\"CUST_GIS_MATCH_SCORE\"                , \"'***'\")\n    (\"CUST_GIS_ST_NUM\"                     , \"'***'\")\n    (\"CUST_GIS_ST_PRETYPE\"                 , \"'***'\")\n    (\"CUST_GIS_ST_NAME\"                    , \"'***'\")\n    (\"CUST_GIS_ST_TYPE\"                    , \"'***'\")\n    (\"CUST_GIS_CITY\"                       , \"'***'\")\n    (\"CUST_GIS_ZIP\"                        , \"'***'\")\n    (\"CUST_GIS_X\"                          , \"'***'\")\n    (\"CUST_GIS_Y\"                          , \"'***'\")\n    (\"CUST_ZIP_CODE\"                       , \"'***'\")\n    (\"CUST_ZIP_PLUS_4\"                     , \"'***'\")\n    (\"CUST_GIS_LOCATR_NAME\"                , \"'***'\")\n    (\"SIC_CODE\"                            , \"'***'\")\n    (\"NAICS_DET_NAME\"                      , \"'***'\")\n    (\"NAICS_INDY_NAME\"                     , \"'***'\")\n    (\"NAICS_INDY_GRP_NAME\"                 , \"'***'\")\n    (\"NAICS_MAJ_GRP_NAME\"                  , \"'***'\")\n    (\"NAICS_DIV_NAME\"                      , \"'***'\")\n    (\"SIC_NAME\"                            , \"'***'\")\n    (\"SIC_INDY_GRP_NAME\"                   , \"'***'\")\n    (\"SIC_MAJ_GRP_NAME\"                    , \"'***'\")\n    (\"SIC_DIV_NAME\"                        , \"'***'\")\n    (\"CUST_PHN_NUM_2\"                      , \"'***'\")\n    (\"CUST_PHN_NUM_3\"                      , \"'***'\")\n    (\"CUST_PAR_ID\"                         , \"'***'\")\n    (\"CUST_PAR_NAME\"                       , \"'***'\")\n    (\"COH_EMP_NUM\"                         , \"'***'\")\n    (\"RM_LOAD_TIME\"                        , \"'***'\")\n    (\"RM_EMP_MSTR_KEY\"                     , \"'***'\")\n    (\"PAY_METH\"                            , \"'***'\")\n    (\"DET_TRANS_CODE\"                      , \"'***'\")\n    (\"T2_TRANS_TYPE_CODE\"                  , \"'***'\")\n    (\"T2_TRANS_TYPE_DESCR\"                 , \"'***'\")\n    (\"T2_TRANS_RSN\"                        , \"'***'\")\n    (\"T2_TRANS_PARSED_DESCR\"               , \"'***'\")\n    (\"T2_TRANS_MISC_ITEM_CODE\"             , \"'***'\")\n    (\"T2_TRANS_MISC_ITEM_DESCR\"            , \"'***'\")\n    (\"T2_TRANS_SCENARIO\"                   , \"'***'\")\n    (\"T2_TRANS_ORIG_OBJ_TYPE_ID\"           , \"'***'\")\n    (\"PMAM_ADJMT_TO\"                       , \"'***'\")\n    (\"PMAM_ADJMT_TYPE\"                     , \"'***'\")\n    (\"DIGITECH_TRANS_TYPE_DET\"             , \"'***'\")\n    (\"RSN_INCDT_NOT_BILLED\"                , \"'***'\")\n    (\"VIO_CODE\"                            , \"'***'\")\n    (\"TOWING_CMPNY\"                        , \"'***'\")\n    (\"BOOT_SERIAL_NUM\"                     , \"'***'\")\n    (\"PRKG_METER_NUM\"                      , \"'***'\")\n    (\"INCDT_SEQ_NUM\"                       , \"'***'\")\n    (\"INCDT_ADDR_LINE_1\"                   , \"'***'\")\n    (\"INCDT_ADDR_LINE_2\"                   , \"'***'\")\n    (\"INCDT_ADDR_LINE_3\"                   , \"'***'\")\n    (\"INCDT_ST_NUM\"                        , \"'***'\")\n    (\"INCDT_ST_PRETYPE\"                    , \"'***'\")\n    (\"INCDT_ST_NAME\"                       , \"'***'\")\n    (\"INCDT_ST_TYPE\"                       , \"'***'\")\n    (\"INCDT_SERV_LVL\"                      , \"'***'\")\n    (\"INCDT_CITY\"                          , \"'***'\")\n    (\"INCDT_STATE\"                         , \"'***'\")\n    (\"INCDT_CTRY\"                          , \"'***'\")\n    (\"INCDT_ST_DIR\"                        , \"'***'\")\n    (\"INCDT_ST\"                            , \"'***'\")\n    (\"INCDT_CNTY\"                          , \"'***'\")\n    (\"INCDT_APT_LOT\"                       , \"'***'\")\n    (\"INCDT_GIS_MATCH_SCORE\"               , \"'***'\")\n    (\"INCDT_GIS_ST_NUM\"                    , \"'***'\")\n    (\"INCDT_GIS_ST_PRETYPE\"                , \"'***'\")\n    (\"INCDT_GIS_ST_NAME\"                   , \"'***'\")\n    (\"INCDT_GIS_ST_TYPE\"                   , \"'***'\")\n    (\"INCDT_GIS_CITY\"                      , \"'***'\")\n    (\"INCDT_GIS_ZIP\"                       , \"'***'\")\n    (\"INCDT_GIS_X\"                         , \"'***'\")\n    (\"INCDT_GIS_Y\"                         , \"'***'\")\n    (\"INCDT_ZIP_CODE\"                      , \"'***'\")\n    (\"INCDT_ZIP_PLUS_4\"                    , \"'***'\")\n    (\"INCDT_GIS_LOCATR_NAME\"               , \"'***'\")\n    (\"BLK_NUM\"                             , \"'***'\")\n    (\"TXP_ID\"                              , \"'***'\")\n    (\"TXP_SERV_LVL\"                        , \"'***'\")\n    (\"TXP_TYPE\"                            , \"'***'\")\n    (\"ORIGIN_LOC\"                          , \"'***'\")\n    (\"DEST_LOC\"                            , \"'***'\")\n    (\"ITEM_STAT\"                           , \"'***'\")\n    (\"ITEM_ADDR_LINE_1\"                    , \"'***'\")\n    (\"ITEM_ADDR_LINE_2\"                    , \"'***'\")\n    (\"ITEM_ADDR_LINE_3\"                    , \"'***'\")\n    (\"ITEM_ST_NUM\"                         , \"'***'\")\n    (\"ITEM_ST_PRETYPE\"                     , \"'***'\")\n    (\"ITEM_ST_NAME\"                        , \"'***'\")\n    (\"ITEM_ST_TYPE\"                        , \"'***'\")\n    (\"ITEM_SERV_LVL\"                       , \"'***'\")\n    (\"ITEM_CITY\"                           , \"'***'\")\n    (\"ITEM_STATE\"                          , \"'***'\")\n    (\"ITEM_CTRY\"                           , \"'***'\")\n    (\"ITEM_ST_DIR\"                         , \"'***'\")\n    (\"ITEM_ST\"                             , \"'***'\")\n    (\"ITEM_CNTY\"                           , \"'***'\")\n    (\"ITEM_APT_LOT\"                        , \"'***'\")\n    (\"ITEM_GIS_MATCH_SCORE\"                , \"'***'\")\n    (\"ITEM_GIS_ST_NUM\"                     , \"'***'\")\n    (\"ITEM_GIS_ST_PRETYPE\"                 , \"'***'\")\n    (\"ITEM_GIS_ST_NAME\"                    , \"'***'\")\n    (\"ITEM_GIS_ST_TYPE\"                    , \"'***'\")\n    (\"ITEM_GIS_CITY\"                       , \"'***'\")\n    (\"ITEM_GIS_ZIP\"                        , \"'***'\")\n    (\"ITEM_GIS_X\"                          , \"'***'\")\n    (\"ITEM_GIS_Y\"                          , \"'***'\")\n    (\"ITEM_ZIP_CODE\"                       , \"'***'\")\n    (\"ITEM_ZIP_PLUS_4\"                     , \"'***'\")\n    (\"ITEM_GIS_LOCATR_NAME\"                , \"'***'\")\n    (\"HCAD_ACCT_STAT\"                      , \"'***'\")\n    (\"AD_VAL_ACCT_LVL_ID\"                  , \"'***'\")\n    (\"COLL_LGL_COND\"                       , \"'***'\")\n    (\"COLL_LAWSUIT_NUM\"                    , \"'***'\")\n    (\"GL_ACCT_ID\"                          , \"'0000247130'\")\n    (\"INCDT_TIME\"                          , \"'00:00:00'\")\n    (\"FUND_ID\"                             , \"'1000'\")\n    (\"EMS_INCDT\"                           , \"'***'\")\n    (\"DISPATCH_NUM\"                        , \"'100073'\")\n    (\"FUND_CNTR_ID\"                        , \"'1200030003'\")\n    (\"CONTR_ID\"                            , \"'4600012363'\")\n    (\"PT_AGE\"                              , \"'***'\")\n    (\"BUS_AREA_ID\"                         , \"'6400'\")\n    (\"RECEIVABLE_STAT\"                     , \"'ACTIVE'\")\n    (\"DET_TRANS_DESCR\"                     , \"'Base Amount Billed'\")\n    (\"MSTR_TRANS_TYPE\"                     , \"'Billed'\")\n    (\"CUST_NAME\"                           , \"'***'\")\n    (\"ORIG_BILL_NAME\"                      , \"'***'\")\n    (\"COLL_PERSON_TYPE\"                    , \"'COH Contractor'\")\n    (\"EMP_NAME\"                            , \"'***'\")\n    (\"ITEM_TYPE\"                           , \"'***'\")\n    (\"ITEM_DESCR\"                          , \"'***'\")\n    (\"INCDT_TYPE\"                          , \"'***'\")\n    (\"INCDT_CAT\"                           , \"'***'\")\n    (\"DIV_LONG_NAME\"                       , \"'***'\")\n    (\"INCDT_DESCR\"                         , \"'***'\")\n    (\"EMP_TYPE\"                            , \"'Employee'\")\n    (\"FUNC_AREA_ID\"                        , \"'GEGO-00-00000000'\")\n    (\"DEPT_LONG_NAME\"                      , \"'***'\")\n    (\"CUST_TYPE\"                           , \"'Individual'\")\n    (\"PT_GNDR\"                             , \"'***'\")\n    (\"COLL_PERSON_NAME\"                    , \"'Employee'\")\n    (\"DIGITECH_ID\"                         , \"'***'\")\n    (\"CARRIER_SRC\"                         , \"'***'\")\n    (\"CARRIER_PROCEDURE_SRC\"               , \"'***'\")\n    (\"CUST_IS_VEND_FLAG\"                   , \"'N'\")\n    (\"JV_CUST_FLAG\"                        , \"'N'\")\n    (\"MAN_TRANS_FLAG\"                      , \"'N'\")\n    (\"DERIVED_TRANS_FLAG\"                  , \"'N'\")\n    (\"INTRA_FUND_TRANS_FLAG\"               , \"'N'\")\n    (\"ADJ_FLAG\"                            , \"'N'\")\n    (\"UNK_CUST_AT_BILL_FLAG\"               , \"'N'\")\n    (\"BILLING_HOLD_FLAG\"                   , \"'N'\")\n    (\"SIG_FLAG\"                            , \"'N'\")\n    (\"RECEIVABLE_MSTR_STAT\"                , \"'Open'\")\n    (\"DIGITECH_TRANS_TYPE\"                 , \"'PROCS'\")\n    (\"INT_EXT_EMP_FLAG\"                    , \"'Y'\")\n    (\"CONFI_CUST_FLAG\"                     , \"'Y'\")\n    (\"CUST_IN_CITY_FLAG\"                   , \"'Y'\")\n    (\"BILLED_FLAG\"                         , \"'Y'\")\n    (\"ITEM_IN_CITY_FLAG\"                   , \"'Y'\")\n    (\"RECEIVABLE_EVER_TRANS_FLAG\"          , \"'Y'\")\n    (\"CUST_PAR_KEY\"                        , \"1\")\n    (\"TRANS_CNT\"                           , \"1\")\n    (\"SRC_SYS_MOD_DTE\"                     , \"'1900-01-01'\")\n    (\"RM_LOAD_DTE\"                         , \"'1900-01-01'\")\n    (\"ITEM_STAT_CHG_DTE\"                   , \"'1900-01-01'\")\n    (\"RECEIVABLE_STAT_CHG_DTE\"             , \"'1900-01-01'\")\n    (\"FIRE_ORIG_ISSUE_DTE\"                 , \"'1900-01-01'\")\n    (\"RECEIVABLE_MSTR_STAT_CHG_DTE\"        , \"'1900-01-01'\")\n    (\"AD_VAL_TAX_DEFERRAL_START_DTE\"       , \"'1900-01-01'\")\n    (\"AD_VAL_TAX_DEFERRAL_END_DTE\"         , \"'1900-01-01'\")\n    (\"AD_VAL_EFF_DTE_OF_OWNERSHIP\"         , \"'1900-01-01'\")\n    (\"3348_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"3308_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"3307_ATTY_FEE_DTE\"                   , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_DELINQ_DTE\"          , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_DUE_DTE\"             , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_TO_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_BILLING_TO_DTE\"      , \"'1900-01-01'\")\n    (\"INCDT_DTE\"                           , \"'1900-01-01'\")\n    (\"RECEIVABLE_VERS_ISSUE_DTE\"           , \"'1900-01-01'\")\n    (\"INTRA_FUND_TRANS_AMT\"                , \"NULL\"        )\n    (\"RECEIVABLE_1ST_PAY_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_FNL_PAY_DTE\"              , \"'1900-01-01'\")\n    (\"RECEIVABLE_LITIGATION_DTE\"           , \"'1900-01-01'\")\n    (\"RECEIVABLE_SETTLEMENT_DTE\"           , \"'1900-01-01'\")\n    (\"REINSTATEMENT_DTE\"                   , \"'1900-01-01'\")\n    (\"SRC_SYS_TRANS_ID\"                    , \"'***'\"       )\n\n    (\"ALLOWABLE_NO_CHRG_INCDTS\"            , \"0\"           )\n    (\"ALM_INSTL_CMPNY\"                     , \"'***'\"       )\n    (\"ALM_INSTL_DTE\"                       , \"'1900-01-01'\")\n    (\"ALM_MNT_CMPNY\"                       , \"'***'\"       )\n    (\"ALM_REG_KEY\"                         , \"'***'\"       )\n    (\"ALM_TYPE\"                            , \"'*'\"         )\n    (\"APPLICTN_RECV_DTE\"                   , \"'1900-01-01'\")\n    (\"APPRAISAL_DISTR_ACCT_NUM\"            , \"'***'\"       )\n    (\"CC_JURIS_DESCR\"                      , \"'***'\"       )\n    (\"CITY_RFPD_JURIS_DESCR\"               , \"'***'\"       )\n    (\"CURR_FIRE_ALM_PERMIT_FLAG\"           , \"'*'\"         )\n    (\"CURR_WTR_ACCT_FLAG\"                  , \"'*'\"         )\n    (\"CUST_ID\"                             , \"'***'\"       )\n    (\"DELINQ_DTE\"                          , \"'1900-01-01'\")\n    (\"DTE\"                                 , \"'1900-01-01'\")\n    (\"ESC_CAND_FLAG\"                       , \"'*'\"         )\n    (\"EXCL_TYPE\"                           , \"'***'\"       )\n    (\"FIRE_ALM_PERMIT_ACTV_FLAG\"           , \"'*'\"         )\n    (\"FIRE_ALM_PERMIT_NUM\"                 , \"'***'\"       )\n    (\"FIRE_ALM_PURPOSE\"                    , \"'***'\"       )\n    (\"INV_NUM\"                             , \"'***'\"       )\n    (\"LAST_CUST_CONN_DTE\"                  , \"'1900-01-01'\")\n    (\"LAST_CUST_CUTOFF_DTE\"                , \"'1900-01-01'\")\n    (\"LAST_CUST_DISCONN_DTE\"               , \"'1900-01-01'\")\n    (\"LAST_METER_INSPECT_DTE\"              , \"'1900-01-01'\")\n    (\"LICENSE_PLATE_EXP_MTH\"               , \"'***'\"       )\n    (\"LICENSE_PLATE_EXP_YR\"                , \"'***'\"       )\n    (\"LICENSE_PLATE_NUM\"                   , \"'***'\"       )\n    (\"LICENSE_PLATE_TYPE\"                  , \"'***'\"       )\n    (\"MUNIC_UTIL_DISTR_DESCR\"              , \"'***'\"       )\n    (\"ON_ADMIN_HOLD_FLAG\"                  , \"'*'\"         )\n    (\"OWNERSHIP_EFF_DTE\"                   , \"'1900-01-01'\")\n    (\"OWNER_IS_CUST_FLAG\"                  , \"'*'\"         )\n    (\"OWNER_RENTER\"                        , \"'*'\"         )\n    (\"PERMIT_EXP_DTE\"                      , \"'1900-01-01'\")\n    (\"PERMIT_ISSUE_DTE\"                    , \"'1900-01-01'\")\n    (\"PERMIT_NAME\"                         , \"'***'\"       )\n    (\"PERMIT_NUM\"                          , \"0\"           )\n    (\"PROP_CLASS_DESCR\"                    , \"'***'\"       )\n    (\"RECEIVABLE_HAS_LTR_FLAG\"             , \"'*'\"         )\n    (\"RECEIVABLE_HAS_NOTE_FLAG\"            , \"'*'\"         )\n    (\"RECEIVABLE_HAS_PEND_LTR_FLAG\"        , \"'*'\"         )\n    (\"REG_HOLDER_FLAG\"                     , \"'*'\"         )\n    (\"REND_PENALTY_JURIS_DESCR\"            , \"'***'\"       )\n    (\"RESOLVED_BY\"                         , \"'***'\"       )\n    (\"RESOLVE_DESCR\"                       , \"'***'\"       )\n    (\"SCHOOL_JURIS_DESCR\"                  , \"'***'\"       )\n    (\"SEN_CITIZEN_FLAG\"                    , \"'*'\"         )\n    (\"SRC_SYS\"                             , \"'***'\"       )\n    (\"SRC_SYS_ID\"                          , \"'***'\"       )\n    (\"SUBSTANTIAL_ERR_PENALTY\"             , \"'*'\"         )\n    (\"SUSPD_PERMIT_DTE\"                    , \"'1900-01-01'\")\n    (\"SUSPD_PERMIT_RSN\"                    , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_1\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_2\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_3\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_4\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_LGL_DESCR_5\"            , \"'***'\"       )\n    (\"TAXABLE_PROP_ROLL_TYPE\"              , \"'***'\"       )\n    (\"TAX_DEFERRAL_END_DTE\"                , \"'1900-01-01'\")\n    (\"TAX_DEFERRAL_START_DTE\"              , \"'1900-01-01'\")\n    (\"TAX_ROLL_DESCR\"                      , \"'***'\"       )\n    (\"TYPE_OF_ALM_SITE\"                    , \"'*'\"         )\n    (\"UNDER_APPEAL_FLAG\"                   , \"'*'\"         )\n    (\"VAC_FLAG\"                            , \"'*'\"         )\n    (\"VEH_COLOR\"                           , \"'***'\"       )\n    (\"VEH_ID_NUM\"                          , \"'***'\"       )\n    (\"VEH_MAKE\"                            , \"'***'\"       )\n    (\"VEH_MODEL\"                           , \"'***'\"       )\n    (\"VEH_MODEL_YR\"                        , \"'***'\"       )\n    (\"VEH_OWNER_ID\"                        , \"'***'\"       )\n    (\"VEH_OWNER_NAME\"                      , \"'***'\"       )\n    (\"VEH_TYPE\"                            , \"'***'\"       )\n    (\"VOID_CODE\"                           , \"'***'\"       )\n    (\"VOID_DESCR\"                          , \"'***'\"       )\n    (\"VOID_FLAG\"                           , \"'*'\"         )\n    (\"WORK_STAT\"                           , \"'***'\"       )\n    (\"WRITE_OFF_FLAG\"                      , \"'*'\"         )\n    (\"WTR_ACCT_NUM_OF_UNITS\"               , \"0\"           )\n    (\"WTR_ACCT_ORIG_USE_TYPE\"              , \"'***'\"       )\n    (\"WTR_ACCT_PROP_USE_TYPE\"              , \"'***'\"       )\n    (\"WTR_METER_NUM\"                       , \"'***'\"       )\n\n|]","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"b67af98c-895c-4d9c-bee1-2c43359c6885"},"expanded":true},{"name":"SlowlyChangingDimensions","content":"#define SLOWLY_CHANGING_DIMENSIONS \nopen System.Text.RegularExpressions\nopen Microsoft.FSharp.Reflection\n\nlet padName: int -> string -> string =\n         fun len    name   -> name.PadRight len\n\nlet pad4 = padName 40\nlet pad2 = padName 20\n\nlet defaultValue v opt = match opt with\n                         | Some x -> x\n                         | None   -> v\n\nlet aNumeral (s : string) = if s.StartsWith \"A#\" then s.[2..] else s\n\nlet toString (x:'a) = \n    match FSharpValue.GetUnionFields(x, typeof<'a>) with\n    | case, _ -> case.Name\n    |> aNumeral\n\nlet fromString<'a> (s:string) =\n    match FSharpType.GetUnionCases typeof<'a> |> Array.filter (fun case -> case.Name = s) with\n    |[|case|] -> Some(FSharpValue.MakeUnion(case,[||]) :?> 'a)\n    |_ -> None\n\ntype sqlObjectType = | PROCEDURE | VIEW | TRIGGER\nwith\n     member this.Name      = toString this\n     member this.Condition = match    this with\n                             | PROCEDURE -> \"IN ( N'P', N'PC' )\"\n                             | VIEW      -> \"=    N'V' \"\n                             | TRIGGER   -> \"=    N'TR'\"\n\nlet sqlDropCreate: sqlObjectType -> string -> string =\n               fun sqlType          name   -> sprintf \"\"\"\nIF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'%s') AND type %s)\n    DROP %s %s;\nGO\n-- Machine-generated-code, DO NOT MODIFY HERE\n-- %s 'HPL', '2017-03-01'\nCREATE %s %s\n\"\"\"                                                name         sqlType.Condition \n                                                   sqlType.Name name \n                                                   name \n                                                   sqlType.Name name\n\n\nlet regexIdentifier = Regex @\"^[\\p{L}_][\\p{L}\\p{N}@$#_]{0,127}$|^\\[.+\\]$\"\n                                                \nlet isIdentifier: string -> bool =\n              fun txt    -> regexIdentifier.IsMatch txt\n\nlet nameS fName = \n    if isIdentifier fName \n    then fName \n    else sprintf \"[%s]\" fName\n\ntype TargetField\nwith\n     member this.Name = toString this\n\ntype FinTransViewField\nwith\n     member this.Name = toString this\n\ntype Field =\n    | SurrogateKey   of TargetField\n    | BusinessKey    of FinTransViewField\n    | SourceDate     of FinTransViewField\n    | IntraDayOrder  of  FinTransViewField\n    | SCD2BeginDate  of TargetField\n    | SCD2EndDate    of TargetField\n    | SCD2Current    of TargetField\n    | ChangeReason   of TargetField\n    | SCD2           of FinTransViewField * scd1:TargetField option * scd0:TargetField option /// Version  value\n    | SCD1           of FinTransViewField * scd0:TargetField option                           /// Current  value\n    | SCD0           of FinTransViewField                               /// SCD0 without accompanying SCD1 or 2\nwith member this.Name0 = \n        match this with\n        | SurrogateKey   tfield\n        | SCD2BeginDate  tfield\n        | SCD2EndDate    tfield\n        | ChangeReason   tfield\n        | SCD2Current    tfield        -> tfield.Name\n        | BusinessKey    sfield\n        | SourceDate     sfield\n        | IntraDayOrder  sfield\n        | SCD2          (sfield, _, _) \n        | SCD1          (sfield, _   ) \n        | SCD0           sfield        -> sfield.Name\n     member this.Name = this.Name0 |> nameS\n\nlet strOption: string -> string option =\n           fun txt    -> match txt.Trim() with\n                         | \"\" -> None\n                         | f  -> Some f\n\nlet tfldOption: TargetField -> TargetField option =\n            fun fld         -> match fld with | Nil  -> None | _ -> Some fld\n\nlet sfldOption: FinTransViewField -> FinTransViewField option =\n            fun fld         -> match fld with | Nil_ -> None | _ -> Some fld\n\nlet SurrogateKey  name           : Field =  name                   |> SurrogateKey \nlet BusinessKey   name           : Field =  name                   |> BusinessKey  \nlet SourceDate    name           : Field =  name                   |> SourceDate   \nlet IntraDayOrder name           : Field =  name                   |> IntraDayOrder   \nlet SCD2BeginDate name           : Field =  name                   |> SCD2BeginDate\nlet SCD2EndDate   name           : Field =  name                   |> SCD2EndDate  \nlet SCD2Current   name           : Field =  name                   |> SCD2Current  \nlet ChangeReason  name           : Field =  name                   |> ChangeReason  \nlet SCD0          name           : Field =  name                   |> SCD0         \nlet SCD1          name      scd0 : Field = (name, tfldOption scd0) |> SCD1         \nlet SCD2          name scd1 scd0 : Field = (name, tfldOption scd1                   \n                                                , tfldOption scd0) |> SCD2\n    \nlet fieldNames      :  Field -> string list =\n                   fun f     -> match f with \n                                | SCD2         (_, Some scd1, Some scd0) -> [ f.Name ; scd1.Name ; scd0.Name ]\n                                | SCD2         (_, _        , Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | SCD1         (_,            Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | _                                      -> [ f.Name                         ]\n\nlet fieldSource     :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _\n                                | SCD2BeginDate _\n                                | SCD2EndDate   _\n                                | ChangeReason  _\n                                | SCD2Current   _            -> []\n                                | _                          -> [ f.Name ]\n\nlet fieldTarget    :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  tfield\n                                | SCD2BeginDate tfield\n                                | SCD2EndDate   tfield\n                                | ChangeReason  tfield\n                                | SCD2Current   tfield                   -> [ tfield.Name            ]\n                                | SCD2         (_, Some scd1, Some scd0) -> [ scd1  .Name ; scd0.Name]\n                                | SCD2         (_, _        , Some scd0) -> [               scd0.Name]\n                                | SCD1         (_,            Some scd0) -> [               scd0.Name]\n                                | _                                      -> []\n\nlet fieldAlias      :  Field -> string =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> \"SurrogateKey_ \"\n                                | BusinessKey   _ -> \"BusinessKey_  \"\n                                | SourceDate    _ -> \"SourceDate_   \"\n                                | IntraDayOrder _ -> \"IntraDayOrder_\"\n                                | SCD2BeginDate _ -> \"SourceDate_   \"\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> \"\" \n                                | _               -> f.Name\nlet fieldAliasValue :  Field -> string -> string = \n                   fun f        v      -> sprintf \"%s = %s\" (pad4 (fieldAlias f)) v\n\nlet fieldSelectTable:  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f f.Name ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SCD2BeginDate _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> [] \n                                | _               -> [ f.Name ]\n\nlet fieldSelectSource: (string -> string) -> Field -> string list =\n                   fun transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f \"NULL\"  ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ -> [ fieldAliasValue f f.Name ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldSelectTogether1: (string -> string) -> Field -> string list =\n                   fun    transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAlias f |> transform ]\n                                | BusinessKey   _ -> [ fieldAlias f              ]\n                                | SourceDate    _ -> [ fieldAlias f              ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _ \n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldInsert     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f\n\nlet fieldValues     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (sprintf \"S.%s\")\n\nlet fieldUpdate     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | BusinessKey   _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (fun n -> sprintf \"T.%s = S.%s\" (pad4 n) n)\n\nlet fieldSCD2Equal   : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _ -> [ sprintf \"S.%s = P.%s\" ( pad4 f.Name) f.Name ]\n                                | _      -> []\n                                \nlet fieldSCD2        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _             -> [ sprintf \"S.%s\" f.Name ]\n                                | _                  -> []\n\nlet fieldSCD0        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD1(_,    Some scd0) \n                                | SCD2(_, _, Some scd0) -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 scd0.Name) f.Name ]\n                                | SCD0 _                -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\nlet fieldSCD1        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2(_, Some scd1, _) -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 scd1.Name) f.Name ]\n                                | SCD1 _                -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\ntype SQLTableView = {\n    db       : string option\n    schema   : string option\n    sqlObject: string\n    where    : string option\n    parms    : string option\n}\nwith member this.Reference   : string =\n                               match this.db, this.schema with\n                               | None   , None    -> sprintf \"%s\"\n                               | Some db, None    -> sprintf \"%s..%s\"   (nameS db)\n                               | Some db, Some sc -> sprintf \"%s.%s.%s\" (nameS db) (nameS sc)\n                               | None   , Some sc -> sprintf \"%s.%s\"               (nameS sc)\n                               <| nameS this.sqlObject\n     member this.Call        : string =\n                               match this.parms with\n                               | None    -> sprintf \"%s\"\n                               | Some ps -> fun r -> sprintf \"%s(%s)\" r ps\n                               <| this.Reference\n     member this.FromWhere   : string =\n                               match this.where with\n                               | None    -> sprintf \"%s\"\n                               | Some wh -> fun c -> sprintf \"%s WHERE %s \" c wh\n                               <| this.Call\n\n     static member New: string -> string ->  string  -> string -> string -> SQLTableView =\n                    fun db        schema     sobject    where     parms  -> {\n                                                                                db        = strOption db\n                                                                                schema    = strOption schema\n                                                                                sqlObject = sobject.Trim()\n                                                                                where     = strOption where \n                                                                                parms     = strOption parms\n                                                                            }\n\nlet indent : string  -> string =\n         fun content -> content.Split[| '\\n' |] |> String.concat \"\\n    \"\n\nlet indent2: string  -> string =\n         fun content -> \"    \" + (indent content)\n\ntype SQLWith = { \n    name   : string \n    content: string \n}\nwith override this.ToString()  = sprintf \"%s as (\\n%s\\n)\" this.name this.content\n     static member New: string -> string  -> SQLWith =\n                    fun name      content -> { name = name.Trim() ; content = indent2 content }\n\nlet sqlSelectP: string -> string -> string seq -> string =\n    fun         select    from      fields     -> \n        fields \n        |> String.concat \"\\n     , \"\n        |> sprintf \"%s %s\\n  FROM %s\" select <| from\n\nlet sqlSelect : string -> string seq -> string = sqlSelectP \"SELECT\"\nlet sqlSelectD: string -> string seq -> string = sqlSelectP \"SELECT Distinct\"\n\nlet sqlProcedure: string -> string  -> string  -> string=\n              fun name      parms      content -> \n                  sqlDropCreate PROCEDURE name\n                  |> sprintf \"%s %s\\n as \\n %s \\nGO\" <| parms <| content\n\nlet bSurrogateKey  = function | SurrogateKey  _ -> true | _ -> false\nlet bBusinessKey   = function | BusinessKey   _ -> true | _ -> false\nlet bSourceDate    = function | SourceDate    _ -> true | _ -> false\nlet bIntraDayOrder = function | IntraDayOrder _ -> true | _ -> false\nlet bSCD2BeginDate = function | SCD2BeginDate _ -> true | _ -> false\nlet bSCD2EndDate   = function | SCD2EndDate   _ -> true | _ -> false\nlet bChangeReason  = function | ChangeReason  _ -> true | _ -> false\nlet bSCD2Current   = function | SCD2Current   _ -> true | _ -> false\nlet bSCD2          = function | SCD2          _ -> true | _ -> false\n\ntype Dimension ( tableBase : SQLTableView\n               , source    : SQLTableView\n               , fields    : Field  seq\n               , snowflakes: string seq\n               , extra     : Printf.StringFormat<_>) =              \n     let isSnowflaked   = snowflakes |> Seq.isEmpty |> not\n     let countF filter  = fields |> Seq.filter filter |> Seq.length\n     let cSurrogateKey  = countF bSurrogateKey \n     let cBusinessKey   = countF bBusinessKey  \n     let cSourceDate    = countF bSourceDate   \n     let cIntraDayOrder = countF bIntraDayOrder\n     let cSCD2BeginDate = countF bSCD2BeginDate\n     let cSCD2EndDate   = countF bSCD2EndDate  \n     let cChangeReason  = countF bChangeReason  \n     let cSCD2Current   = countF bSCD2Current  \n     let cSCD2          = countF bSCD2\n     let table          = if isSnowflaked then { tableBase with sqlObject = \"SV_\" + tableBase.sqlObject } else tableBase\n     let duplicates     = fields |> Seq.collect fieldNames |> Seq.countBy (fun n -> n.Trim().ToUpper()) |> Seq.choose (fun (n, i) -> if i > 1 then sprintf \"Field %s appears more than once\" n |> Some else None) |> Seq.toList\n     let errors         = [\n                             if              cSurrogateKey  = 0 then yield \"A SurrogateKey  must be specified\"\n                             if              cBusinessKey   = 0 then yield \"A BusinessKey   must be specified\"\n                             if cSCD2 > 0 && cSourceDate    = 0 then yield \"A SourceDate    must be specified\"\n                             if cSCD2 > 0 && cIntraDayOrder = 0 then yield \"A IntraDayOrder must be specified\"\n                             if cSCD2 > 0 && cSCD2BeginDate = 0 then yield \"A SCD2BeginDate must be specified\"\n                             if cSCD2 > 0 && cSCD2EndDate   = 0 then yield \"A SCD2EndDate   must be specified\"\n                             if              cSurrogateKey  > 1 then yield \"Only 1 SurrogateKey  can be specified\"\n                             if              cBusinessKey   > 1 then yield \"Only 1 BusinessKey   can be specified\"\n                             if              cSourceDate    > 1 then yield \"Only 1 SourceDate    can be specified\"\n                             if              cIntraDayOrder > 1 then yield \"Only 1 IntraDayOrder can be specified\"\n                             if              cSCD2BeginDate > 1 then yield \"Only 1 SCD2BeginDate can be specified\"\n                             if              cSCD2EndDate   > 1 then yield \"Only 1 SCD2EndDate   can be specified\"\n                             if              cSCD2Current   > 1 then yield \"Only 1 SCD2Current   can be specified\"\n                             if              cChangeReason  > 1 then yield \"Only 1 ChangeReason  can be specified\"\n                             if cSCD2 = 0 && cSourceDate    = 1 then yield \"No SCD2 fields, SourceDate    cannot be specified\"\n                             if cSCD2 = 0 && cIntraDayOrder = 1 then yield \"No SCD2 fields, IntraDayOrder cannot be specified\"\n                             if cSCD2 = 0 && cSCD2BeginDate = 1 then yield \"No SCD2 fields, SCD2BeginDate cannot be specified\"\n                             if cSCD2 = 0 && cSCD2EndDate   = 1 then yield \"No SCD2 fields, SCD2EndDate   cannot be specified\"\n                             if cSCD2 = 0 && cSCD2Current   = 1 then yield \"No SCD2 fields, SCD2Current   cannot be specified\"\n                          ] @ duplicates\n     do if not errors.IsEmpty then failwith (errors |> String.concat \"\\n\")\n     let find  : (Field -> bool) -> string =\n             fun  ft             -> fields |> Seq.find ft |> fun f -> f.Name\n     let surrogateKey   = find bSurrogateKey\n     let businessKey    = find bBusinessKey\n     let sourceDateO    = if cSourceDate    = 1 then find bSourceDate    |> Some else None\n     let intraDayOrderO = if cIntraDayOrder = 1 then find bIntraDayOrder |> Some else None\n     let sCD2BeginDateO = if cSCD2BeginDate = 1 then find bSCD2BeginDate |> Some else None\n     let sCD2EndDateO   = if cSCD2EndDate   = 1 then find bSCD2EndDate   |> Some else None\n     let sCD2CurrentO   = if cSCD2Current   = 1 then find bSCD2Current   |> Some else None\n     let changeReasonO  = if cChangeReason  = 1 then find bChangeReason  |> Some else None \n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\n     let lastOfDay    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY %s, %s ORDER BY %s ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n businessKey (sourceDateO |> Option.defaultValue \"\") (intraDayOrderO |> Option.defaultValue \"\")\n     let together1    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY BusinessKey_, SourceDate_ ORDER BY SurrogateKey_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n \nwith\n     new(table, source, fields            ) = Dimension(table, source, fields, []        , \"%s\")\n     new(table, source, fields, snowflakes) = Dimension(table, source, fields, snowflakes, \"%s\")\n     member this.TableReference     = table    .Reference\n     member this.TableBase          = tableBase\n     member this.Fields: (Field -> string list) -> string seq =\n                     fun chooser                  -> fields |> Seq.sort |> Seq.collect chooser\n     member this.AllFields          = this.Fields <| fieldNames\n     member this.FinTransViewFields = this.Fields <| fieldSource\n     member this.TargetFields       = this.Fields <| fieldTarget\n     member this.Existing           = this.Fields <| fieldSelectTable\n     member this.Source             = this.Fields <| fieldSelectSource    (if cSCD2 > 0 then lastOfDay else id)\n     member this.Together1          = this.Fields <| fieldSelectTogether1 (if cSCD2 > 0 then together1 else id)\n     member this.Together2          = [\n                                        sprintf \"NRec_  = ROW_NUMBER() OVER (PARTITION BY BusinessKey_ ORDER BY %s)\" <| if cSCD2 > 0 then \"SourceDate_, ISNULL(SurrogateKey_, 2147483647)\" else \"ISNULL(SurrogateKey_, 2147483647)\"\n                                        \"*\"\n                                      ]\n     member this.NewRec             = if cSCD2 > 0 then \n                                          this.Fields fieldSCD2Equal\n                                          |> String.concat \"\\n                 AND \"  \n                                          |> sprintf \"NewRec_ = IIF (%s, 0, 1)\"\n                                       else          \"NewRec_ = IIF (P.BusinessKey_ is NULL                  , 1, 0) \"\n     member this.Ordered            = [\n                                        yield                    \"S.SurrogateKey_ \"\n                                        yield                    \"S.BusinessKey_  \"\n                                        yield                    \"S.NRec_         \"\n                                        yield                    this.NewRec      \n                                        if cSCD2 > 0 then yield  \"S.SourceDate_   \"\n                                        yield!                   this.Fields fieldSCD2\n                                        yield!                   this.Fields fieldSCD1\n                                        yield!                   this.Fields fieldSCD0\n                                      ]\n     member this.SCD2Records        = [\n                                        \"SCD2Record_ = SUM(NewRec_    ) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\"\n                                        \"NextDate_   = MAX(SourceDate_) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\"\n                                        \"LastRec_    = MAX(NRec_      ) OVER (PARTITION BY BusinessKey_)\"\n                                        \"*\"\n                                      ]\n     member this.VersBeg            = [\n                                        sCD2BeginDateO.Value |> pad4 |> sprintf \"%s = MIN(SourceDate_) OVER (PARTITION BY BusinessKey_, SCD2Record_)\"\n                                        sCD2EndDateO  .Value |> pad4 |> sprintf \"%s = DATEADD(d, -1, MAX(IIF(NRec_ = LastRec_, '9999-12-31', NextDate_)) OVER (PARTITION BY BusinessKey_, SCD2Record_))\"\n                                        \"*\"\n                                      ]\n     member this.RKeys              = [\n                                        if sCD2CurrentO.IsSome then \n                                           yield sCD2CurrentO.Value  |> pad4 |> sprintf \"%s = IIF(%s = '9999-12-30', 'Y', 'N')\"                       <| sCD2EndDateO.Value\n                                        yield    surrogateKey        |> pad4 |> sprintf \"%s = MAX(SurrogateKey_) OVER (PARTITION BY BusinessKey_ %s)\" <| if sCD2BeginDateO.IsSome  then  \", \" + sCD2BeginDateO.Value else \"\"\n                                        yield    businessKey         |> pad4 |> sprintf \"%s = BusinessKey_\"\n                                        if changeReasonO.IsSome then\n                                           yield changeReasonO.Value |> pad4 |> sprintf \"%s = '---'\"\n                                        yield    \"*\"\n                                      ]\n     member this.fromTogether2      = \"    Together2 S\n LEFT JOIN Together2 P ON P.BusinessKey_ = S.BusinessKey_\n                      AND P.NRec_        = S.NRec_ - 1\"\n     member this.Withs              =\n         [\n             yield    SQLWith.New \"Existing     \" <| sqlSelect  table .FromWhere              this.Existing \n             yield    SQLWith.New \"Source       \" <| sqlSelectD source.FromWhere              this.Source   \n             yield    SQLWith.New \"Together0    \" <| \"SELECT *  FROM Existing UNION ALL SELECT * FROM Source\"\n             yield    SQLWith.New \"Together1    \" <| sqlSelectD \"Together0\"                   this.Together1\n             yield    SQLWith.New \"Together2    \" <| sqlSelect  \"Together1          \"         this.Together2\n             yield    SQLWith.New \"Ordered      \" <| sqlSelect  this.fromTogether2            this.Ordered     \n             if cSCD2 > 0 then                                  \n                yield SQLWith.New \"SCD2Records  \" <| sqlSelect  \"Ordered            \"         this.SCD2Records \n                yield SQLWith.New \"VersBeg      \" <| sqlSelect  \"SCD2Records        \"         this.VersBeg     \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"VersBeg            \"         this.RKeys     \n             else                                               \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"Ordered            \"         this.RKeys     \n         ]\n     member this.LastWith           = this.Withs |> Seq.last\n     member this.SelectIntoTemp     = if isSnowflaked then sprintf \"    , NewSurrogateKey_ = NEXT VALUE FOR Seq_%s\\n\" this.TableBase.sqlObject else \"\"\n                                      |> sprintf \"SELECT * \\n%s   INTO #TEMP\\n  FROM %s \\n WHERE NewRec_ = 1\" <| this.LastWith.name                                       \n     member this.Insert             = this.Fields fieldInsert\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   INSERT(%s %s)\" (if isSnowflaked then sprintf \"%s\\n,\" surrogateKey  else \"\")\n                                      |> indent  |> indent\n     member this.Values             = this.Fields fieldValues\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   VALUES(%s %s)\\n\" (if isSnowflaked then \"NewSurrogateKey_\\n,\" else \"\")\n                                      |> indent  |> indent\n     member this.Update             = this.Fields fieldUpdate\n                                      |> String.concat \"\\n, \"\n                                      |> indent |> indent\n     member this.WhenNotMatched     = sprintf \"WHEN NOT MATCHED BY TARGET THEN\\n%s\\n%s\" \n                                      <| this.Insert            <| this.Values\n     member this.WhenMatched        = (fun f -> if f <> \"\" then sprintf \"WHEN MATCHED THEN\\nUPDATE SET %s\" f else f)\n                                      <| this.Update\n     member this.Merge              = sprintf \"MERGE %s AS T\\nUSING #TEMP AS S\\nON (T.%s = S.%s)\\n%s\\n%s;\" \n                                      <| this.TableReference \n                                      <| surrogateKey        <| surrogateKey\n                                      <| this.WhenNotMatched\n                                      <| this.WhenMatched\n     member this.Query              = this.Withs\n                                      |> List.map (fun w -> w.ToString())\n                                      |> String.concat \", \"\n                                      |> sprintf \"WITH %s\"\n                                      |> sprintf \"%s \\n%s; \\n%s\" <| this.SelectIntoTemp <| this.Merge\n     member this.Procedure          = this.Query\n                                      |> sprintf \"BEGIN\\n  EXEC GENERIC.Log @SOURCE, '%s', 'Started Merge', '';\\n  %s\\n END\\n\" procedureName\n                                      |> sqlProcedure procedureName \"@SOURCE VARCHAR(30), @CURRENT_DTE DATE = NULL\" \n     member this.ProcedureName      = procedureName\n     member this.SurrogateKey       = surrogateKey\n     member this.BusinessKey        = businessKey\n     member this.SourceDateO        = sourceDateO\n     member this.SCD2BeginDateO     = sCD2BeginDateO\n     member this.SCD2EndDateO       = sCD2EndDateO  \n     member this.TableName          = table.sqlObject\n     member this.Verification       = sCD2BeginDateO \n                                      |> Option.map (fun b ->\n                                            let e = sCD2EndDateO.Value\n                                            sprintf \" AND (D.%s BETWEEN X.%s AND X.%s  OR D.%s BETWEEN X.%s AND X.%s ) \" b b e  e b e\n                                         )\n                                      |> defaultValue \"\"\n                                      |> sprintf \"SELECT * \\n  FROM %s D \\n WHERE EXISTS(SELECT * \\n         FROM %s X \\n      WHERE X.%s <> D.%s AND X.%s = D.%s %s) \\n ORDER BY %s %s\" \n                                            table.Reference table.Reference\n                                            surrogateKey    surrogateKey    \n                                            businessKey     businessKey\n                                      <| businessKey <| \"\"\n     member this.Snowflakes         = snowflakes\n                                      \n                                    \ntype FactField = \n    | Fact   of FinTransViewField\n    | OField of TargetField * value: string\n\nlet OField: TargetField -> string -> FactField = \n        fun fld            value  -> (fld, value.Trim()) |> OField\n\n[< NoComparison >]\ntype DimRef =\n    | DimRef of Dimension * SurrogateKey: TargetField option * BusinesKey: FinTransViewField option\nwith\n     member this.Dim                = match this with                                      DimRef (dim, _   , _) -> dim\n     member this.FactSurrogateKey   = match this with | DimRef (dim, Some key, _) -> key.Name | DimRef (dim, None, _) -> dim.SurrogateKey\n     member this.FactBusinessKey    = match this with | DimRef (dim, _, Some key) -> key.Name | DimRef (dim, _, None) -> dim.BusinessKey\n     member this.FinTransViewFields = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! bKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.FinTransViewFields ]\n     member this.TargetFields       = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! sKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.TargetFields       ]\n     static member New dim                             = DimRef(dim, None             , None            )\n     static member New(dim, surrogateKey             ) = DimRef(dim, Some surrogateKey, None            )\n     static member New(dim, surrogateKey, businessKey) = DimRef(dim, Some surrogateKey, Some businessKey)\nlet dimension: Dimension -> TargetField -> FinTransViewField -> DimRef = \n           fun dim          surroK         businK      -> DimRef (dim, tfldOption surroK, sfldOption businK)\n\ntype FactTable( table  : SQLTableView\n              , source : SQLTableView\n              , dims   : DimRef    seq\n              , fields : FactField seq\n              , extra  : Printf.StringFormat<_>) =\n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\nwith \n     member this.TableName      = table.sqlObject\n     member this.ProcedureName  = procedureName\n     member this.SourceFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(_, f) -> f\n                                             )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.FinTransViewFields))\n                                  |> Seq.distinct\n     member this.TargetFields   = fields \n                                  |> Seq.collect (function \n                                                  | Fact f       -> []\n                                                  | OField(f, _) -> [ f.Name ]\n                                                 )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.TargetFields))\n                                  |> Seq.distinct\n     member this.Keys           = dims |> Seq.mapi(fun i dim -> sprintf \"D%d.%s\" i dim.Dim.SurrogateKey)\n     member this.Joins          = dims \n                                  |> Seq.mapi(fun i dim -> \n                                                    dim.Dim.SourceDateO\n                                                    |> Option.map (fun v -> sprintf \" AND S.%s BETWEEN D%d.%s AND D%d.%s\" v i dim.Dim.SCD2BeginDateO.Value i dim.Dim.SCD2EndDateO.Value)\n                                                    |> defaultValue \"\"\n                                                    |> sprintf \"%s D%d ON D%d.%s = S.%s %s\" (pad2 dim.Dim.TableBase.Reference) i i (pad2 dim.Dim.BusinessKey) (pad2 dim.FactBusinessKey)\n                                             )\n                                  |> Seq.toList                                                                 \n     member this.From           = sprintf \"%s S\" source.FromWhere\n                                  :: this.Joins\n                                  |> String.concat \"\\n LEFT JOIN \"\n     member this.Query          = fields \n                                  |> Seq.map (function \n                                              | Fact   f     -> sprintf \"S.%s\"    f.Name\n                                              | OField(f, v) -> sprintf \"%s = %s\" (pad2 f.Name) v\n                                             )\n                                  |> Seq.append this.Keys \n                                  |> sqlSelect this.From\n     member this.InsertFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(f, _) -> f.Name\n                                             )\n                                  |> Seq.append (dims |> Seq.map (fun dim -> dim.FactSurrogateKey))\n                                  |> String.concat \"\\n     , \"\n     member this.Insert         = sprintf \"INSERT INTO %s\\n      (%s)\\n%s\" table.Reference this.InsertFields this.Query\n                                  |> sprintf extra\n     member this.Procedure      = sqlProcedure procedureName \"@SOURCE VARCHAR(30), @FROM DATE = NULL, @TO DATE = NULL\" this.Insert\n\nlet print: string -> unit =\n       fun txt    -> printf \"\\n\\n%s\\n\\n\" txt\n\nlet FinTransViewFields: FactTable -> Dimension seq -> string seq =\n    fun                 fTable       dims          -> \n        fTable.SourceFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.FinTransViewFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\nlet targetFields: FactTable -> Dimension seq -> string seq =\n    fun           fTable       dims          -> \n        fTable.TargetFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.TargetFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\n\nlet getDecl: string -> (string * bool) option =\n         fun fname  -> fieldDecl\n                       |> Seq.choose (fun (name, typeDecl, nullable) -> if name = fname.ToUpper() then (typeDecl, nullable = 1) |> Some else None)\n                       |> Seq.tryHead\n\nlet getDefault: string -> string option =\n            fun fname  -> fieldDefault\n                          |> Array.tryPick (fun (name, value) -> if name = fname.ToUpper() then Some value else None)\n\nlet convert fName v =\n    getDecl fName \n    |> Option.map (fun (fType, nullable) -> fType.Trim())\n    |> Option.map (fun typeName -> sprintf \"CONVERT(%s, %s)\"  typeName v) \n    |> Option.defaultValue v\n\nlet applyDefault fName v =\n    getDecl fName \n    |> Option.bind (fun (fType, nullable) ->\n           if nullable then None\n           else getDefault fName\n           |> Option.map (sprintf \"ISNULL(%s, %s)\" v)\n    )\n    |> Option.defaultValue v\n\nlet equalField fName v =\n    fName\n    |> nameS\n    |> pad4 \n    |> sprintf \"%s = %s\"  <| v\n\ntype FinTransViewField\nwith \n    \n    member this.Convert      v = convert      this.Name v\n    member this.applyDefault v = applyDefault this.Name v\n    member this.equal        v = equalField   this.Name v\n    member this.DefaultO       = getDefault   this.Name\n\nlet cast: FinTransViewField -> string -> string =\n      fun field                value  ->\n          value\n          |> field.Convert\n          |> field.applyDefault \n          |> field.equal\n\ntype QueryField(target: FinTransViewField, value: string) =\n    let name = target.Name\nwith\n    member this.Entry = cast target value\n    member this.Name  = name\n\nlet vwField: FinTransViewField -> string -> QueryField = \n         fun fld                  value  -> QueryField(fld, value.Trim())\n\n\nlet inline getUnionNames typ =\n    Microsoft.FSharp.Reflection.FSharpType.GetUnionCases typ\n    |> Seq.map (fun e -> e.Name |> aNumeral)\n    |> Seq.filter ((<>)\"Nil_\")\n    |> Seq.sort\n    |> Seq.toArray\n\nlet finTransViewFieldNames = getUnionNames typeof<FinTransViewField>\nlet targetFieldNames   = getUnionNames typeof<TargetField>\n\nlet missingFields: QueryField seq -> string[] =\n    fun            fields         -> \n        finTransViewFieldNames\n        |> Array.filter (fun e -> fields |> Seq.exists (fun f -> f.Name = e) |> not)\n\nlet allFields() = missingFields (seq[])\n                  |> Seq.sort\n                  |> String.concat \"\\n        , \"\n\nlet setDefault: string -> string =\n            fun field  -> getDefault    field \n                          |> Option.defaultValue \"(NULL)\" \n                          |> convert    field\n                          |> equalField field\n\ntype FactView(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n    let fieldsCached = fields |> Seq.toArray\n    let getFieldValue fName =\n        fieldsCached \n        |> Array.tryFind      (fun q -> q.Name    = fName)\n        |> Option.map         (fun q -> q.Entry          )\n        |> Option.defaultWith (fun _ -> setDefault  fName)\nwith\n     member this.Name     = name.schema\n     member this.ViewName = name.Call\n     member this.Query    = \n         finTransViewFieldNames \n         |> Array.map  getFieldValue\n         |> String.concat \"\\n        , \"\n         |> sprintf \"SELECT %s\\n FROM %s;\\n\" <| source.FromWhere\n         |> sprintf \"%s\\n as %s; \\nGO\" (sqlDropCreate VIEW this.ViewName)\n\nlet missingDefaults() =\n    finTransViewFieldNames \n    |> Seq.map    (fun n -> n, getDecl n, getDefault n)\n    |> Seq.filter (fun (n, typeO, defO) -> \n         match typeO, defO with\n         | None               , _\n         | Some (_    , false), None -> true\n         | _                         -> false\n    )\n    |> Seq.map     (fun (n, typO, _) ->\n        (n, typO, \n            match typO with\n            | Some(\"int\"       , _) -> \"0\"\n            | Some(\"varchar(1)\", _)\n            | Some(\"varchar(2)\", _) -> \"'*'\"\n            | Some(\"date\"      , _) \n            | Some(\"datetime\"  , _) -> \"'1900-01-01'\"\n            | _                     -> \"'***'\"\n        )\n    )\n\nlet missingDecls () =\n    fieldDecl\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    \n\nlet inline str4 s = s |> sprintf \"%A\" |> pad4 \nlet inline str2 s = s |> sprintf \"%A\" |> pad2 \n\nlet mutable AllDimensions: Dimension  list = []\nlet mutable AllFactViews : FactView   list = []\nlet mutable AllFactTables: FactTable  list = []\n\ntype Dimension\nwith \n     static member New( tableBase : SQLTableView\n                      , source    : SQLTableView\n                      , fields    : Field  seq\n                      , snowflakes: string seq\n                      , extra     : Printf.StringFormat<_>) =\n          let dim = Dimension(tableBase, source, fields, snowflakes, extra)\n          AllDimensions <- List.append AllDimensions [ dim ]\n          dim\n     static member New(table, source, fields            ) = Dimension.New(table, source, fields, []        , \"%s\")\n     static member New(table, source, fields, snowflakes) = Dimension.New(table, source, fields, snowflakes, \"%s\")\n\ntype FactTable\nwith \n     static member New( table  : SQLTableView\n                      , source : SQLTableView\n                      , dims   : DimRef    seq\n                      , fields : FactField seq\n                      , extra  : Printf.StringFormat<_>) =\n          let ft = FactTable(table, source, dims, fields, extra)\n          AllFactTables <- List.append AllFactTables [ ft ]\n          ft\n\ntype FactView\nwith \n     static member New(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n          let fv = FactView(name, source, fields)\n          AllFactViews <- List.append AllFactViews [ fv ]\n          fv\n\n(*          \n(*keep*)#load \"BetterFSI.fsx\"  // <<<==== Execute first in F# Interactive\nDo __SOURCE_FILE__ __LINE__ //\nDo __SOURCE_FILE__ __LINE__ //  missingDecls()    |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (fun (n, _, d) -> printfn \"(%s, %s)\" (str4 n) (str2 d))\nDo __SOURCE_FILE__ __LINE__ //  finTransViewFieldNames |> Seq.filter (fun a -> a.StartsWith \"A#\" ) |>\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"62d0b48f-6f54-4fa2-a455-e1f288cfd0c8"},{"$":0,"Item":"133131ac-9ee5-47b2-8047-351746ee9e10"},{"$":0,"Item":"b67af98c-895c-4d9c-bee1-2c43359c6885"}],"companions":[],"id":{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},"expanded":true},{"name":"-------- READ ME --------","content":"\n\nTo update and regenerate views and procedures:\n\n- Make the required changes to the Views and dimension definitions below \n  and/or the Fields, FieldDecls and Defaults above\n- When ready to send to SQL Server, \n  click on \"Copy Views and Procedures\" at the end of this group\n- WHILE \"Copy Views and Procedures\" IS HIGHLIGHTED, select the view(s) and/or dimensions(s) \n  that need to be updated by clicking on the small box to the right. \n- Click on the \"Evaluate FS\" button\n- After a while a menu will pop up\n- Click on the buttons to copy the new definition to the Clipboard\n- Paste into SSMS and execute\n\nSnowFlaked dimensions.\nTo also update the snowflaked dimensions superviews make sure to check the box for \"SQLFetchFields & SnowFlakeViews\"\nA connection to the SQL Server is required for this option to work.\nThe connection string can be found in line 6.\n\nIf more changes are necessary close the pop up menu and repeat the steps above.\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"38aa569a-caf7-4c97-81c7-12ab6a9faec4"},"expanded":true},{"name":"","content":"module Views =","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"expanded":true},{"name":"View  EMS_MSB","content":"let EMS_MSBView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"EMS_MSB\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"EMS_MSB\" \"VW_FG_FIN_TRANS_STEP0_V2\" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'EMS_MSB'                                                           \"\n                vwField SRC_SYS_ID                          \"'EMS_MSB-'+ CONVERT(VARCHAR, Account_No)                            \"\n\n                vwField INTRA_DAY_ORDER                     \"case Transaction_Type \n                                                              when 'Payment'          then 20              \n                                                              when 'Paid'             then 20             \n                                                              when 'Adjustment'       then 30         \n                                                              when 'Billed'           then 10                                                            \n                                                              when 'Turnback'         then 40                                                              \n                                                              when 'Turnover'         then 50                                                              \n                                                              end + IIF(TAG_STATUS='Closed', 2, 1)\"            \n\n                vwField BUS_AREA_ID                         \"'6400'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'EMS_MSB'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'EMS_MSB'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Houston Fire Department'                                           \"\n                vwField DIV_LONG_NAME                       \"'Emergency Medical Services'                                        \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'EMS_MSB-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'EMS_MSB Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'EMS_MSB generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'4600012363'                                                        \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'EMS_MSB-'+ CONVERT(VARCHAR, Account_No)                            \"\n                vwField CUST_NAME                           \"Name                                                                \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                    \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'EMS_MSB '                                                          \"\n                vwField COH_EMP_NUM                         \"'EMS_MSB-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Turnover'\n\t\t\t\t                                             else                            'Turnover'   end                      \"\n                vwField DET_TRANS_DESCR                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Base, City Portion Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Base Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Base Amount Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Base Amount Turnover'\n\t\t\t\t                                             else                            'Base Amount Turnover'   end          \"\n                vwField DET_TRANS_CODE                      \"'EMS_MSB-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"Account_No                                                          \"\n                vwField INCDT_DESCR                         \"'Emergency Transport'                                               \"\n                vwField INCDT_TYPE                          \"'EMS Transport'                                                     \"\n                vwField INCDT_CAT                           \"'EMS Transport'                                                     \"\n                vwField INCDT_DTE                           \"Issue_Date                                                          \"\n// DIM INCDT EMS DET\n                vwField EMS_INCDT                           \"Account_No                                                          \"\n                vwField DISPATCH_NUM                        \"Account_No                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'EMS_MSB Patient'                                                   \"\n// DIM ITEM PT DET\n                vwField PT_GNDR                             \"PT_GNDR                                                             \"\n                vwField PT_AGE                              \"PT_AGE                                                              \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"Tag                                                                 \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'Y'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"IIF(DATEADD(year,1,Issue_Date) > Turnover_Date, Turnover_Date, DATEADD(year,1,Issue_Date))\"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_Date                                                          \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"Turnover_Date                                                       \"   \n                vwField RECEIVABLE_VERS_DELINQ_DTE          \"Turnover_Date                                                       \"   \n                vwField VERS_ASSIGNED_VEND                  \"'0000130521'                                                        \"   \n                vwField RECEIVABLE_MSTR_STAT                \"TAG_STATUS                                                          \"      \n                vwField ITEM_DESCR                          \"'EMS Patient'                                                       \"    \n                vwField ORIG_BILL_NAME                      \"Name                                                                \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"Transaction_Date                                                    \"                               \n        ]\n)\n             \n(* \nopen SlowlyChangingDimensions\nprint EMS_MSBView.Query       \n*)\n\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"d2205189-f6a8-4e24-81b2-5b485d18f424"},"expanded":true},{"name":"View  HCTO","content":"let HCTOView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HCTO\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HCTO\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HCTO'                                                          \"\n                vwField SRC_SYS_ID                          \"'HCTO-' + SRC_SYS_ID                                            \"\n                                                                                                                     \n                vwField BUS_AREA_ID                         \"'9000'                                                          \"\n// DIM_CARRIER                                                                                                                  \n                vwField CARRIER_SRC                         \"'HCTO'                                                          \"\n// DIM_CARRIER PROCEDURE                                                                                                       \n                vwField CARRIER_PROCEDURE_SRC               \"'HCTO'                                                          \"\n// DIM_COH_ORG                                                                                                                  \n                vwField DEPT_LONG_NAME                      \"'Legal Department'                                              \"\n                vwField DIV_LONG_NAME                       \"'Treasury'                                                      \"\n// DIM_COLL_PERSON                                                                                                              \n                vwField COLL_PERSON_ID                      \"'HCTO-111'                                                      \"\n                vwField COLL_PERSON_NAME                    \"'Harris County Employee'                                        \"\n                vwField DIGITECH_ID                         \"'HCTO generic'                                                  \"\n                vwField HCTO_AD_VAL_ID                      \"'Harris County Employee'                                        \"\n                vwField COLL_PERSON_TYPE                    \"'COH Contractor'                                                \"\n                \n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***-000001'                                                    \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'HCTO-'+ CAN                                                    \"\n                vwField CONFI_CUST_FLAG                     \"'N'                                                             \"\n                vwField CUST_NAME                           \"NAMELINE1                                                       \"\n                vwField CUST_IS_VEND_FLAG                   \"'N'                                                             \"\n                vwField JV_CUST_FLAG                        \"'N'                                                             \"\n                vwField CUST_ADDR_LINE_1                    \"NAMELINE2                                                       \"\n                vwField CUST_ADDR_LINE_2                    \"NAMELINE3                                                       \"\n                vwField CUST_ADDR_LINE_3                    \"NAMELINE4                                                       \"\n                vwField CUST_IN_CITY_FLAG                   \"IIF(CITY='HOUSTON','Y','N')                                     \"\n                vwField CUST_CITY                           \"CITY                                                            \"\n                vwField CUST_STATE                          \"STATE                                                           \"\n                vwField CUST_CTRY                           \"COUNTRY                                                         \"\n                vwField CUST_ZIP_CODE                       \"SUBSTRING(ZIPCODE,1,5)                                          \"\n                vwField CUST_ZIP_PLUS_4                     \"SUBSTRING(ZIPCODE,1,13)                                         \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"TRANS_DTE                                                       \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'COH Contractor'                                                \"\n                vwField EMP_NAME                            \"'Harris County Employee'                                        \"\n                vwField COH_EMP_NUM                         \"'HCTO-111'                                                      \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"MSTR_TRANS_TYPE                                             \"\n                vwField DET_TRANS_DESCR                     \"DET_TRANS_DESCR                                                 \"\n                vwField DET_TRANS_CODE                      \"'HCTO-' + MSTR_TRANS_TYPE                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"SRC_SYS_ID                                                      \"\n                vwField INCDT_DESCR                         \"'Property ownership'                                            \"\n                vwField INCDT_TYPE                          \"'Property ownership'                                            \"\n                vwField INCDT_CAT                           \"'Property ownership'                                            \"\n                vwField INCDT_DTE                           \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4),YEAR))              \"\n                vwField INCDT_ADDR_LINE_1                   \"CONVERT(VARCHAR,PNUMBER)+' '+PSTRNAME                         \"\n                vwField INCDT_ST_NUM                        \"PNUMBER                                                         \"\n                vwField INCDT_ST_NAME                       \"PSTRNAME                                                        \"\n                vwField INCDT_IN_CITY_FLAG                  \"'Y'                                                             \"\n                vwField INCDT_STATE                         \"'Texas'                                                         \"\n                vwField INCDT_CTRY                          \"'USA'                                                           \"\n                vwField INCDT_ZIP_CODE                      \"SUBSTRING(PZIP,1,5)                                             \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'Ad Valorem Property'                                           \"\n                vwField ITEM_ADDR_LINE_1                    \"CONVERT(VARCHAR,PNUMBER)+' '+PSTRNAME                           \" \n                vwField ITEM_ST_NUM                         \"CONVERT(VARCHAR(13),PNUMBER)                                    \"\n                vwField ITEM_ST_NAME                        \"PSTRNAME                                                        \"\n                vwField ITEM_IN_CITY_FLAG                   \"'Y'                                                             \"\n                vwField ITEM_STATE                          \"'Texas'                                                         \"\n                vwField ITEM_DESCR                          \"'Property ownership'                                            \"\n                vwField ITEM_ZIP_CODE                       \"SUBSTRING(PZIP,1,5)                                             \"\n// DIM ITEM DET\n                vwField FLAG_DIM_ITEM_TAXABLE_PROP_DET      \"1                                                               \"\n                vwField TAXABLE_PROP_ROLL_TYPE              \"'Roll Type'                                          \"            \n                vwField NUM_OF_ACRES                        \"LEGACRES                                                        \"\n                vwField PROP_CLASS_CODE                     \"PROPCLASS                         \" \n                vwField CITY_RFPD_JURIS_CODE                \"'61'        \" \n                vwField CONFI_ACCT_FLAG                     \"'N' \" \n                vwField TAX_DEFERRAL_START_DTE              \"TAXDEFSTRT                                                      \"\n                vwField TAX_DEFERRAL_END_DTE                \"TAXDEFEND                                                     \" \n                vwField OWNERSHIP_EFF_DTE                   \"CONVERT(DATETIME,'1900-01-01 00:00:00.000') \" \n                vwField APPRAISAL_DISTR_ACCT_NUM            \"SUBSTRING(CAN,1,16) \" \n                vwField TAXABLE_PROP_LGL_DESCR_1            \"LEGAL1                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_2            \"LEGAL2                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_3            \"LEGAL3                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_4            \"LEGAL4                                                          \"\n                vwField TAXABLE_PROP_LGL_DESCR_5            \"LEGAL5                                                          \"\n                vwField TAX_ROLL_CODE                       \"ROLL                                                            \"\n                vwField PROP_CLASS_DESCR                    \"Property_Description                                            \"\n                vwField CITY_RFPD_JURIS_DESCR               \"'HOUSTON, CITY OF'                                             \"\n                vwField TAX_ROLL_DESCR                      \"'Roll Type'                                         \"\n                vwField CAN                                 \"SUBSTRING(CAN,1,16) \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_EVER_TRANS_FLAG      \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DELINQ_DTE      \"DELINQ_DTE                                                          \"\n                vwField RECEIVABLE_VERS_DUE_DTE         \"DUEDATE                                                             \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE       \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4), YEAR))                 \"\n                vwField RECEIVABLE_VERS_TO_DTE          \"CONVERT(DATETIME,'10/1/'+CONVERT(VARCHAR(4), YEAR))                 \"\n                vwField VERS_ASSIGNED_VEND              \"'0000113973'                                                        \"\n                vwField ORIG_BILL_NAME                  \"NAMELINE1                                                           \"\n                vwField UNK_CUST_AT_BILL_FLAG           \"'N'                                                                 \"\n// Dim_Receivable_Det DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\n                vwField FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET \"1\"\n                vwField AD_VAL_VET_FLAG                  \"VETERAN                                                            \"\n                vwField AD_VAL_DISABLED_FLAG             \"DISABLED                                                           \"\n                vwField AD_VAL_OVER_66_FLAG              \"OVER65                                                             \"\n                vwField AD_VAL_HOMESTEAD_FLAG            \"HOMESTEAD                                                          \"\n                vwField HCAD_ACCT_STAT                   \"CAN                                                                \"\n                vwField AD_VAL_TAX_DEFERRAL_START_DTE    \"TAXDEFSTRT                                                        \"\n                vwField AD_VAL_TAX_DEFERRAL_END_DTE      \"TAXDEFEND                                                         \"\n                vwField ``A#3348_ATTY_FEE_DTE``          \"DATE_3348                                                         \"\n                vwField ``A#3308_ATTY_FEE_DTE``          \"DATE_3308                                                         \"\n//              vwField ``A#3307_ATTY_FEE_DTE``          \"DATE_3307                                                         \"\n//Dim Business Area\n                vwField BUS_AREA_ID                   \"'9000'                                                               \"\n\n// Dim Functional Area\n                vwField FUNC_AREA_ID                    \"'GEGO-00-00000000'                                                   \"\n// Dim Fund ID\n                vwField FUND_ID                         \"'1000'                                                               \"\n// Dim Fund Cntr ID\n                vwField FUND_CNTR_ID                    \"'1000'                                                               \"\n// Dim GL Acct  \n                vwField GL_ACCT_ID                      \"'0000428020'                                                         \"\n\n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"TRANS_AMT\t                                                       \"      \n                vwField SRC_SYS_TRANS_ID                    \"'HCTO'                                                            \"      \n              \n                vwField POST_DTE                            \"TRANS_DTE                                                          \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint HCTOView.Query \n*)","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"79ff8549-d6f4-47cf-b0c0-efc9eaa6e813"},"expanded":true},{"name":"View HHD","content":"let HHDView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HHD\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HHD\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HHD'                                                           \"\n                vwField SRC_SYS_ID                          \"'HHD-'+Document_Number                                          \"\n\n                vwField BUS_AREA_ID                         \"'3800'                                                          \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'HHD'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'HHD'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Health & Human Services'                                       \"\n                vwField DIV_LONG_NAME                       \"'Health & Human Services'                                       \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'HHD-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'HHD Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'HHD generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***'                                                           \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'HHD-'+ CONVERT(VARCHAR, CUSTOMER)                              \"\n                vwField CUST_NAME                           \"Name_1                                                          \"\n                vwField CUST_ADDR_LINE_1                    \"Street                                                          \"\n                vwField CUST_CITY                           \"City                                                            \"\n                vwField CUST_STATE                          \"Region                                                            \"\n                vwField CUST_ZIP_CODE                       \"IIF(LEN(Postal_Code) = 0, '***', isnull(LEFT(Postal_Code, 5) ,'***'))           \"\n                vwField CUST_PHN_NUM_1                      \"IIF(LEN(Telephone_1) = 0,'***',Telephone_1)                     \"\n                vwField CUST_FAX_NUM                        \"IIF(LEN(Fax_Number) = 0,'***',Fax_Number)                     \"\n         \n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Value_Date                                                      \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                      \"\n                vwField EMP_NAME                            \"'HHD '                                                          \"\n                vwField COH_EMP_NUM                         \"'HHD-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type\t                                             \"\n                vwField DET_TRANS_DESCR                     \"Transaction_Desc\t                                             \"\n                vwField DET_TRANS_CODE                      \"'HHD-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"'HHD-'+Document_Number                                          \"\n                vwField INCDT_DTE                           \"Value_Date                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'HHD Transaction'                                                   \"\n                vwField ITEM_DESCR                          \"'HHD Transaction'                                                   \"    \n// DIM_RECEIVABLE\n//                vwField RECEIVABLE_STAT                     \"BLNGSTAT                                                            \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"Due_date                                                            \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_date                                                          \"\n//                vwField RECEIVABLE_MSTR_STAT                \"ACCOUNTSTATUS                                                       \"      \n                vwField ORIG_BILL_NAME                      \"Name_1                                                            \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Amount                                                            \"      \n                vwField POST_DTE                            \"Value_Date                                                        \"                               \n        ]\n)\n(* \nopen SlowlyChangingDimensions\nprint HHDView.Query \n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"a8351a4c-1fdb-4f57-8fca-8fed60008c36"},"expanded":true},{"name":"View HPL","content":"let HPLView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"HPL\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"HPL\" \"VW_FG_FIN_TRANS_STEP0_v4\" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'HPL'                                                               \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                             \"\n                vwField INTRA_DAY_ORDER                     \"case Transaction_Type2 \n                                                              when 'Payment'          then 20              \n                                                              when 'Paid'             then 20             \n                                                              when 'Adjustment'       then 30         \n                                                              when 'Billed'           then 10                                                            \n                                                              when 'Turnback'         then 40                                                              \n                                                              when 'Turnover'         then 50                                                              \n                                                              end + IIF(PIF='Y', 2, 1)\"            \n\n                vwField BUS_AREA_ID                         \"'3400'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'HPL'                                                               \"\n// DIM_CARRIER PROCEDURE                                                                                                         \n                vwField CARRIER_PROCEDURE_SRC               \"'HPL'                                                               \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Houston Public Library'                                            \"\n                vwField DIV_LONG_NAME                       \"'Library Material Services'                                         \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'HPL-111'                                                           \"\n                vwField COLL_PERSON_NAME                    \"'HPL Employee'                                                      \"\n                vwField DIGITECH_ID                         \"'HPL generic'                                                       \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"IIF(CollectionState2 > 0, '4600014067' , '***')                     \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"CUST_ID                                                             \"\n                vwField CUST_EMAIL_ADDR                     \"EMAIL                                                               \"\n                vwField CUST_PHN_NUM_1                      \"PHONE                                                               \"\n                vwField CUST_NAME                           \"Name                                                                \"\n                vwField CUST_TYPE                           \"PROFILE                                                             \"\n                vwField CUST_ADDR_LINE_1                    \"STREET                                                              \"\n                vwField CUST_ADDR_LINE_2                    \"APT_UNIT                                                            \"\n                vwField CUST_CITY                           \"CITY_STATE                                                          \"\n                vwField CUST_APT_LOT                        \"APT_UNIT                                                            \"\n                vwField CUST_ZIP_CODE                       \"LEFT(ZIP,5)                                                         \"\n                vwField CUST_ZIP_PLUS_4                     \"ZIP                                                                 \"\n// DIM_CUST_PAR                                                                                                                    \n                vwField CUST_PAR_ID                         \"IIF(LEN(CARE_OF) > 1, CUST_ID, '***')                               \"\n                vwField CUST_PAR_NAME                       \"IIF(LEN(CARE_OF) > 1, CARE_OF, '***')                               \"\n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date2                                                   \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'HPL '                                                              \"\n                vwField COH_EMP_NUM                         \"'HPL-111'                                                           \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type2                                                   \"\n                vwField DET_TRANS_DESCR                     \" case Transaction_Type2 \n                                                              when 'Payment'          then 'Base, City Portion Paid'              \n                                                              when 'Paid'             then 'Base, City Portion Paid'              \n                                                              when 'Adjustment'       then 'Base Adjustment'                 \n                                                              when 'Billed'           then 'Base Amount Billed'                                                                 \n                                                              when 'Turnback'         then 'Base Amount Turnback'                                                                 \n                                                              when 'Turnover'         then 'Base Amount Turnover'                                                                 \n                                                              end                                                                \"\n                vwField DET_TRANS_CODE                      \"'HPL-' + Transaction_Type2                                          \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                             \"\n                vwField INCDT_DESCR                         \"'HPL Billed'                                                        \"\n                vwField INCDT_TYPE                          \"'Houston Public Library'                                            \"\n                vwField INCDT_CAT                           \"'Houston Public Library'                                            \"\n                vwField INCDT_DTE                           \"Date_Billed                                                         \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"ITEM_TYPE                                                           \"\n// DIM_RECEIVABLE\n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"IIF(CollectionState2 > 0, 'Y','N')                                  \"\n                vwField RECEIVABLE_VERS_DELINQ_DTE          \"DATEADD(day,30,Date_Billed)                                         \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"DATEADD(day,30,Date_Billed)                                         \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Date_Billed                                                         \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"IIF(CollectionState2 > 0, TurnoverDate, '1900-01-01')               \"   \n                vwField VERS_ASSIGNED_VEND                  \"IIF(CollectionState2 > 0, '0000109958' , 'CoH')                     \"   \n                vwField RECEIVABLE_MSTR_STAT                \"IIF(PIF='Y','Close','Open')                                         \"      \n                vwField RECEIVABLE_MSTR_STAT_CHG_DTE        \"IIF(PIF='Y',Transaction_Date2, '1900-01-01')                        \"    \n                vwField ITEM_DESCR                          \"'HPL Transaction'                                                   \"    \n                vwField ORIG_BILL_NAME                      \"Name                                                                \"     \n                vwField RECEIVABLE_VERS_BILLING_TO_DTE      \"IIF(CollectionState2 > 0,TurnoverDate,'1900-01-01')                 \"   \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount2                                                 \"      \n                vwField POST_DTE                            \"Transaction_Date2                                                   \"                               \n        ]\n    )\n(*          \nopen SlowlyChangingDimensions\nprint HPLView.Query \n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"04f28553-8359-4ba0-9281-bc45839b844f"},"expanded":true},{"name":"View MCD","content":"let MCDView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"MCD\" \"VW_FG_FIN_TRANS2       \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"MCD\" \"VW_FG_FIN_TRANS_STEP0_v2  \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'MCD'                                                               \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                             \"\n\n                vwField BUS_AREA_ID                         \"'1600'                                                              \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'MCD'                                                               \"\n// DIM_CARRIER PROCEDURE                                                                                                         \n                vwField CARRIER_PROCEDURE_SRC               \"'MCD'                                                               \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Municipal Courts'                                                  \"\n                vwField DIV_LONG_NAME                       \"'Municipal Courts'                                                  \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'MCD-111'                                                           \"\n                vwField COLL_PERSON_NAME                    \"'MCD Employee'                                                      \"\n                vwField DIGITECH_ID                         \"'MCD generic'                                                       \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"IIF(Vendor_ID LIKE 'INCOLL', '***', '0000100103')\" // this is needed to point to Linebarger when they have it\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"CUST_ID                                                             \"\n                vwField CUST_PHN_NUM_1                      \"ResPhone                                                            \"\n                vwField CUST_NAME                           \"DefLastName + ', ' + DefFirstName                                   \"\n                vwField DL_ISSUE_STATE                      \"DLState                                                             \"\n                vwField DL_NUM                              \"DLNbr                                                               \"\n                vwField CUST_ADDR_LINE_1                    \"BestAddLine1                                                        \"\n                vwField CUST_ADDR_LINE_2                    \"BestAddLine2                                                        \"\n                vwField CUST_CITY                           \"BestAddCity                                                         \"\n                vwField CUST_STATE                          \"BestAddState                                                        \"\n                vwField CUST_ZIP_CODE                       \"BestAddZip                                                          \"\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                    \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                          \"\n                vwField EMP_NAME                            \"'MCD '                                                              \"\n                vwField COH_EMP_NUM                         \"'MCD-111'                                                           \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"IIF(Transaction_Type = 'Non-Monetary','Adjustment',Transaction_Type) \"\n                vwField DET_TRANS_DESCR                     \"Transaction_Desc                                                    \"\n                vwField DET_TRANS_CODE                      \"'MCD-' + Transaction_Type                                           \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                             \"\n                vwField INCDT_DESCR                         \"ViolationDesc                                                       \"\n                vwField VIO_CODE                            \"ViolationCode                                                       \"\n                vwField ADJ_FLAG                            \"ADJUDICATED_STATUS                                                  \"\n                vwField INCDT_TYPE                          \"'Municipal Courts'                                                  \"\n                vwField INCDT_CAT                           \"'Municipal Courts'                                                  \"\n                vwField INCDT_DTE                           \"ViolationDate                                                       \"\n                vwField INCDT_TIME                          \"ViolationTime                                                       \"\n                vwField INCDT_ADDR_LINE_1                   \"VioStreetName                                                       \"\n                vwField BLK_NUM                             \"VioStreetBlck                                                       \"\n// DIM_ITEM                                                                                                                      \n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"ViolationStatus                                                     \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"IIF(Vendor_ID LIKE 'INCOLL', 'N','Y')                               \"\n       // too complex resolve in source  vwField RECEIVABLE_VERS_DELINQ_DTE          \"IIF(V.Vendor_ID LIKE 'INCOLL',NULL ,R.Turnover_DTE)                               \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"IIF(Turnover_DTE is null,DATEADD(day,60,Issue_DTE),Turnover_DTE) \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_DTE                                                           \"\n                vwField RECEIVABLE_VERS_TO_DTE              \"Turnover_DTE                                                        \"   \n                vwField VERS_ASSIGNED_VEND                  \"IIF(Vendor_ID LIKE 'INCOLL','CoH' , '0000106846')                   \"   \n                vwField RECEIVABLE_MSTR_STAT                \"IIF(ViolationStatus='CLOSED','Close','Open')                        \"      \n                vwField RECEIVABLE_MSTR_STAT_CHG_DTE        \"STATUS_DATE                                                         \"    \n                vwField ITEM_DESCR                          \"'MCD Transaction'                                                   \"    \n                vwField ORIG_BILL_NAME                      \"DefLastName + ', ' + DefFirstName                                   \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"STATUS_DATE                                                         \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint MCDView.Query\n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"28e52d96-1900-4150-a99d-6f5ed15bd1df"},"expanded":true},{"name":"View PWE","content":"let PWEView =\n    FactView.New (\n        name   = SQLTableView.New \"\" \"PWE\" \"VW_FG_FIN_TRANS2        \" \"\" \"\"\n      , source = SQLTableView.New \"\" \"PWE\" \"VW_FG_FIN_TRANS_STEP0   \" \"\" \"\"\n      , fields = [\n                vwField SRC_SYS                             \"'PWE'                                                           \"\n                vwField SRC_SYS_ID                          \"INV_NUM                                                         \"\n\n                vwField BUS_AREA_ID                         \"'2000'                                                          \"\n// DIM_CARRIER                                                                                                                   \n                vwField CARRIER_SRC                         \"'PWE'                                                           \"\n// DIM_CARRIER PROCEDURE                                                                                                        \n                vwField CARRIER_PROCEDURE_SRC               \"'PWE'                                                           \"\n// DIM_COH_ORG                                                                                                                   \n                vwField DEPT_LONG_NAME                      \"'Public Works & Engineering'                                    \"\n                vwField DIV_LONG_NAME                       \"'Public Works & Engineering'                                    \"\n// DIM_COLL_PERSON                                                                                                               \n                vwField COLL_PERSON_ID                      \"'PWE-111'                                                       \"\n                vwField COLL_PERSON_NAME                    \"'PWE Employee'                                                  \"\n                vwField DIGITECH_ID                         \"'PWE generic'                                                   \"\n// DIM_CONTR                                                                                                                     \n                vwField CONTR_ID                            \"'***'                                                           \"\n// DIM_CUST                                                                                                                      \n                vwField CUST_ID                             \"'PWE-'+ CONVERT(VARCHAR, ACCOUNTNUMBER)                         \"\n                vwField CUST_NAME                           \"CUSTDESC1                                                       \"\n                vwField CUST_ADDR_LINE_1                    \"CONVERT(VARCHAR(10), STNO) + ' ' + CONVERT(VARCHAR(max), STNAME)\"\n                vwField CUST_CITY                           \"City                                                            \"\n                vwField CUST_ZIP_CODE                       \"IIF(LEN(ZIP) = 0, '***', isnull(LEFT(ZIP, 5) ,'***'))           \"\n                vwField CUST_TYPE                           \"ACCTCLASSDESC                                                   \"\n\n// DIM_CUST_PAR                                                                                                                  \n// DIM DTE                                                                                                                       \n                vwField DTE                                 \"Transaction_Date                                                      \"\n// DIM EMP                                                                                                                       \n                vwField EMP_TYPE                            \"'Employee'                                                      \"\n                vwField EMP_NAME                            \"'PWE '                                                          \"\n                vwField COH_EMP_NUM                         \"'PWE-111'                                                       \"\n// DIM_FIN_TRANS_TYPE                                                                                                            \n                vwField MSTR_TRANS_TYPE                     \"Transaction_Type\t                                             \"\n                vwField DET_TRANS_DESCR                     \"case Transaction_Type\t\n\t\t\t\t                                             when 'Payment'             then 'Base, City Portion Paid' \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t when 'Paid'                then 'Base, City Portion Paid' \n\t\t\t\t                                             when 'Adjustment'\t\t\tthen 'Base Adjustment'\n\t\t\t\t                                             when 'Turnback'\t\t\tthen 'Base Amount Turnback'\n\t\t\t\t                                             when 'Turnover'\t\t\tthen 'Base Amount Turnover'\n\t\t\t\t                                             else                            'Base Amount Billed'   end          \"\n                vwField DET_TRANS_CODE                      \"'PWE-' + Transaction_Type                                       \"\n// DIM INCDT                                                                                                                     \n                vwField INV_NUM                             \"INV_NUM                                                         \"\n                vwField INCDT_DTE                           \"Issue_Date                                                          \"\n// DIM_ITEM                                                                                                                      \n                vwField ITEM_TYPE                           \"'PWE Transaction'                                                   \"\n                vwField ITEM_DESCR                          \"'PWE Transaction'                                                   \"    \n// DIM_RECEIVABLE\n                vwField RECEIVABLE_STAT                     \"BLNGSTAT                                                            \"      \n                vwField RECEIVABLE_EVER_TRANS_FLAG          \"'N'                                                                 \"\n                vwField RECEIVABLE_VERS_DUE_DTE             \"ISNULL(Due_Date, DATEADD(day, 21, CONVERT(DATETIME, Issue_Date)))   \"\n                vwField RECEIVABLE_VERS_ISSUE_DTE           \"Issue_Date                                                          \"\n                vwField RECEIVABLE_MSTR_STAT                \"ACCOUNTSTATUS                                                       \"      \n                vwField ORIG_BILL_NAME                      \"CUSTDESC                                                            \"     \n// FG_FIN_TRANS\n                vwField TRANS_AMT                           \"Transaction_Amount                                                  \"      \n                vwField POST_DTE                            \"Transaction_Date                                                          \"                               \n        ]\n)\n\n(* \nopen SlowlyChangingDimensions\nprint PWEView.Query\n*)\n","parent":{"$":0,"Item":"7d6dcaac-d7f9-4eb6-9725-9c42b206324d"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"3b47f651-d4ef-41db-90f3-ad67d1a4b6eb"},"expanded":true},{"name":"module Dimensions =","content":"module Dimensions =","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"expanded":true},{"name":"dimReceivable","content":"let dimReceivable = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_RECEIVABLE        \" \"SRC_SYS_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes =\n                 [\n                    \"DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET\"\n                    \"DIM_RECEIVABLE_BOOT_TOW_DET\"\n                    \"DIM_RECEIVABLE_EMS_RECEIVABLE_DET\"\n                    \"DIM_RECEIVABLE_FIRE_ALM_CIT_DET\"\n                    \"DIM_RECEIVABLE_PRKG_CONTRA_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    SRC_SYS_ID                     \n                    SourceDate     DTE\n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n                    \n                    SurrogateKey   RECEIVABLE_KEY                    \n                    SCD2BeginDate  VERS_BEG_DTE                       \n                    SCD2EndDate    VERS_END_DTE                       \n                    SCD2Current    CURR_VERS_FLAG           \n\n////////////                       SCD2                              SCD1                             SCD0        \n////////////                       ---------                         -------                          ------\n                    SCD2           RECEIVABLE_STAT                   Nil                              Nil\n                    SCD2           RECEIVABLE_STAT_CHG_DTE           Nil                              Nil\n                    SCD2           RECEIVABLE_VERS_ISSUE_DTE         RECEIVABLE_CURR_ISSUE_DTE        RECEIVABLE_ORIG_ISSUE_DTE            \n                    SCD2           RECEIVABLE_VERS_DUE_DTE           RECEIVABLE_CURR_DUE_DTE          RECEIVABLE_ORIG_DUE_DTE              \n                    SCD2           RECEIVABLE_VERS_DELINQ_DTE        RECEIVABLE_CURR_DELINQ_DTE       RECEIVABLE_ORIG_DELINQ_DTE           \n                    SCD2           RECEIVABLE_VERS_TO_DTE            RECEIVABLE_CURR_TO_DTE           RECEIVABLE_ORIG_TO_DTE               \n                    SCD2           RECEIVABLE_VERS_BILLING_TO_DTE    RECEIVABLE_CURR_BILLING_TO_DTE   RECEIVABLE_ORIG_BILLING_TO_DTE       \n                    SCD2           VERS_ASSIGNED_VEND                CURR_ASSIGNED_VEND               ORIG_ASSIGNED_VEND              \n                    SCD2           RECEIVABLE_MSTR_STAT              Nil                              Nil\n                    SCD2           RECEIVABLE_MSTR_STAT_CHG_DTE      Nil                              Nil\n\n////////////                       SCD1                              SCD0                    \n////////////                       ---------                         -------                        \n                    SCD1           INV_NUM                           ORIG_INV_NUM                   \n                    SCD1           RECEIVABLE_EVER_TRANS_FLAG        Nil\n                    SCD1           RECEIVABLE_LITIGATION_DTE         Nil\n                    SCD1           RECEIVABLE_FNL_PAY_DTE            Nil\n                    SCD1           RECEIVABLE_1ST_PAY_DTE            Nil\n                    SCD1           RECEIVABLE_SETTLEMENT_DTE         Nil\n                    SCD1           FIRE_ALM_AGING_RST_FLAG           Nil\n                    SCD1           REINSTATEMENT_DTE                 Nil\n                    SCD1           FIRE_ORIG_ISSUE_DTE               Nil\n                    SCD1           ITEM_DESCR                        Nil\n                    SCD1           ORIG_BILL_NAME                    Nil\n                    SCD1           UNK_CUST_AT_BILL_FLAG             Nil\n\n////////////                       SCD0                    \n////////////                       --------- \n                    SCD0           LOAD_DTE                        \n                    SCD0           LOAD_TIME              \n                    \n                    SCD1           FLAG_DIM_RECEIVABLE_AD_VAL_RECEIVABLE_DET  Nil\n                    SCD1           ``A#3307_ATTY_FEE_DTE``                    Nil\n                    SCD1           ``A#3308_ATTY_FEE_DTE``                    Nil\n                    SCD1           ``A#3348_ATTY_FEE_DTE``                    Nil\n                    SCD1           AD_VAL_ACCT_LVL_ID                         Nil\n                    SCD1           AD_VAL_DISABLED_FLAG                       Nil\n                    SCD1           AD_VAL_EFF_DTE_OF_OWNERSHIP                Nil\n                    SCD1           AD_VAL_HOMESTEAD_FLAG                      Nil\n                    SCD1           AD_VAL_OVER_66_FLAG                        Nil\n                    SCD1           AD_VAL_TAX_DEFERRAL_END_DTE                Nil\n                    SCD1           AD_VAL_TAX_DEFERRAL_START_DTE              Nil\n                    SCD1           AD_VAL_VET_FLAG                            Nil\n                    SCD1           COLL_LAWSUIT_NUM                           Nil\n                    SCD1           COLL_LGL_COND                              Nil\n                    SCD1           HCAD_ACCT_STAT                             Nil\n                    SCD1           QTRLY_PAY_FLAG                             Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_BOOT_TOW_DET           Nil\n                    SCD1           RECEIVABLE_HAS_LTR_FLAG                    Nil\n                    SCD1           RECEIVABLE_HAS_NOTE_FLAG                   Nil\n                    SCD1           RECEIVABLE_HAS_PEND_LTR_FLAG               Nil\n                    SCD1           RESOLVE_DESCR                              Nil\n                    SCD1           RESOLVE_DTE                                Nil\n                    SCD1           RESOLVE_RSN                                Nil\n                    SCD1           RESOLVED_BY                                Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_EMS_RECEIVABLE_DET     Nil\n                    SCD1           ACTV_CARRIER                               Nil\n                    SCD1           ACTV_CARRIER_FIN_CLASS                     Nil\n                    SCD1           ACTV_CARRIER_FIN_GRP                       Nil\n                    SCD1           BILLING_HOLD_FLAG                          Nil\n                    SCD1           SIG_FLAG                                   Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_FIRE_ALM_CIT_DET       Nil\n                    SCD1           VOID_CODE                                  Nil\n                    SCD1           VOID_DESCR                                 Nil\n                    SCD1           WORK_STAT                                  Nil\n                    SCD1           FLAG_DIM_RECEIVABLE_PRKG_CONTRA_DET        Nil\n                    SCD1           ESC_CAND_FLAG                              Nil\n                    SCD1           ON_ADMIN_HOLD_FLAG                         Nil\n                    SCD1           UNDER_APPEAL_FLAG                          Nil\n                    SCD1           VOID_FLAG                                  Nil\n                    SCD1           WRITE_OFF_FLAG                             Nil\n                 ]\n    )\n\n(*\nopen SlowlyChangingDimensions\nprint dimReceivable.Procedure\nprint dimReceivable.Verification\n*)","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},"expanded":true},{"name":"dimItem","content":"let dimItem = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_ITEM              \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes = \n                 [\n                    \"DIM_ITEM_BURG_ALM_PERMIT_DET\"\n                    \"DIM_ITEM_FIRE_ALM_PERMIT_DET\"\n                    \"DIM_ITEM_LICENSED_VEH_DET\"\n                    \"DIM_ITEM_PT_DET\"\n                    \"DIM_ITEM_TAXABLE_PROP_DET\"\n                    \"DIM_ITEM_WTR_ACCT_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    ITEM_TYPE                     \n                    SourceDate     DTE                           \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   ITEM_KEY                        \n                    SCD2BeginDate  VERS_BEG_DTE                     \n                    SCD2EndDate    VERS_END_DTE                     \n                    SCD2Current    CURR_VERS_FLAG                \n                    SCD2           ITEM_STAT                        Nil                             Nil\n                    SCD2           ITEM_STAT_CHG_DTE                Nil                             Nil\n                    SCD1           ITEM_EXMPT_FLAG                  Nil\n                    SCD1           ITEM_ADDR_LINE_1                 Nil\n                    SCD1           ITEM_ADDR_LINE_2                 Nil\n                    SCD1           ITEM_ADDR_LINE_3                 Nil\n                    SCD1           ITEM_ST_NUM                      Nil\n                    SCD1           ITEM_PREFIX                      Nil\n                    SCD1           ITEM_ST_PRETYPE                  Nil\n                    SCD1           ITEM_ST_NAME                     Nil\n                    SCD1           ITEM_ST_TYPE                     Nil\n                    SCD1           ITEM_SUFF                        Nil\n                    SCD1           ITEM_SERV_LVL                    Nil\n                    SCD1           ITEM_IN_CITY_FLAG                Nil\n                    SCD1           ITEM_CITY                        Nil\n                    SCD1           ITEM_STATE                       Nil\n                    SCD1           ITEM_CTRY                        Nil\n                    SCD1           ITEM_ST_DIR                      Nil\n                    SCD1           ITEM_ST                          Nil\n                    SCD1           ITEM_CNTY                        Nil\n                    SCD1           ITEM_APT_LOT                     Nil\n                    SCD1           ITEM_GIS_MATCH_SCORE             Nil\n                    SCD1           ITEM_GIS_ST_NUM                  Nil\n                    SCD1           ITEM_GIS_PREFIX                  Nil\n                    SCD1           ITEM_GIS_ST_PRETYPE              Nil\n                    SCD1           ITEM_GIS_ST_NAME                 Nil\n                    SCD1           ITEM_GIS_ST_TYPE                 Nil\n                    SCD1           ITEM_GIS_SUFF                    Nil\n                    SCD1           ITEM_GIS_CITY                    Nil\n                    SCD1           ITEM_GIS_ZIP                     Nil\n                    SCD1           ITEM_GIS_X                       Nil\n                    SCD1           ITEM_GIS_Y                       Nil\n                    SCD1           ITEM_ZIP_CODE                    Nil\n                    SCD1           ITEM_ZIP_PLUS_4                  Nil\n                    SCD1           ITEM_GIS_LOCATR_NAME             Nil\n                    SCD0           LOAD_DTE                        \n                    SCD0           LOAD_TIME         \n                    \n                    SCD1           FLAG_DIM_ITEM_BURG_ALM_PERMIT_DET  Nil\n                    SCD1           ALLOWABLE_NO_CHRG_INCDTS           Nil\n                    SCD1           ALM_MNT_CMPNY                      Nil\n                    SCD1           ALM_TYPE                           Nil\n                    SCD1           PERMIT_EXP_DTE                     Nil\n                    SCD1           PERMIT_ISSUE_DTE                   Nil\n                    SCD1           PERMIT_NAME                        Nil\n                    SCD1           PERMIT_NUM                         Nil\n                    SCD1           REG_HOLDER_FLAG                    Nil\n                    SCD1           SUSPD_PERMIT_DTE                   Nil\n                    SCD1           SUSPD_PERMIT_RSN                   Nil\n                    SCD1           TYPE_OF_ALM_SITE                   Nil\n                    SCD1           FLAG_DIM_ITEM_FIRE_ALM_PERMIT_DET  Nil\n                    SCD1           ALM_INSTL_CMPNY                    Nil\n                    SCD1           ALM_INSTL_DTE                      Nil\n                    SCD1           ALM_REG_KEY                        Nil\n                    SCD1           APPLICTN_RECV_DTE                  Nil\n                    SCD1           CURR_FIRE_ALM_PERMIT_FLAG          Nil\n                    SCD1           EXCL_TYPE                          Nil\n                    SCD1           FIRE_ALM_PERMIT_ACTV_FLAG          Nil\n                    SCD1           FIRE_ALM_PERMIT_NUM                Nil\n                    SCD1           FIRE_ALM_PURPOSE                   Nil\n                    SCD1           FLAG_DIM_ITEM_LICENSED_VEH_DET     Nil\n                    SCD1           LICENSE_PLATE_EXP_MTH              Nil\n                    SCD1           LICENSE_PLATE_EXP_YR               Nil\n                    SCD1           LICENSE_PLATE_NUM                  Nil\n                    SCD1           LICENSE_PLATE_TYPE                 Nil\n                    SCD1           OWNER_IS_CUST_FLAG                 Nil\n                    SCD1           SRC_SYS_VEH_ID                     Nil\n                    SCD1           VEH_COLOR                          Nil\n                    SCD1           VEH_ID_NUM                         Nil\n                    SCD1           VEH_MAKE                           Nil\n                    SCD1           VEH_MODEL                          Nil\n                    SCD1           VEH_MODEL_YR                       Nil\n                    SCD1           VEH_OWNER_ID                       Nil\n                    SCD1           VEH_OWNER_NAME                     Nil\n                    SCD1           VEH_TYPE                           Nil\n                    SCD1           FLAG_DIM_ITEM_PT_DET               Nil\n                    SCD1           PT_AGE                             Nil\n                    SCD1           PT_GNDR                            Nil\n                    SCD1           FLAG_DIM_ITEM_TAXABLE_PROP_DET     Nil\n                    SCD1           APPRAISAL_DISTR_ACCT_NUM           Nil\n                    SCD1           CAN                                Nil\n                    SCD1           CC_JURIS_CODE                      Nil\n                    SCD1           CC_JURIS_DESCR                     Nil\n                    SCD1           CITY_RFPD_JURIS_CODE               Nil\n                    SCD1           CITY_RFPD_JURIS_DESCR              Nil\n                    SCD1           CONFI_ACCT_FLAG                    Nil\n                    SCD1           MUNIC_UTIL_DISTR_CODE              Nil\n                    SCD1           MUNIC_UTIL_DISTR_DESCR             Nil\n                    SCD1           NUM_OF_ACRES                       Nil\n                    SCD1           OWNERSHIP_EFF_DTE                  Nil\n                    SCD1           PROP_CLASS_CODE                    Nil\n                    SCD1           PROP_CLASS_DESCR                   Nil\n                    SCD1           REND_PENALTY_JURIS_CODE            Nil\n                    SCD1           REND_PENALTY_JURIS_DESCR           Nil\n                    SCD1           SCHOOL_JURIS_CODE                  Nil\n                    SCD1           SCHOOL_JURIS_DESCR                 Nil\n                    SCD1           SUBSTANTIAL_ERR_PENALTY            Nil\n                    SCD1           TAX_DEFERRAL_END_DTE               Nil\n                    SCD1           TAX_DEFERRAL_START_DTE             Nil\n                    SCD1           TAX_ROLL_CODE                      Nil\n                    SCD1           TAX_ROLL_DESCR                     Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_1           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_2           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_3           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_4           Nil\n                    SCD1           TAXABLE_PROP_LGL_DESCR_5           Nil\n                    SCD1           TAXABLE_PROP_ROLL_TYPE             Nil\n                    SCD1           FLAG_DIM_ITEM_WTR_ACCT_DET         Nil\n                    SCD1           CURR_WTR_ACCT_FLAG                 Nil\n                    SCD1           DELINQ_DTE                         Nil\n                    SCD1           LAST_CUST_CONN_DTE                 Nil\n                    SCD1           LAST_CUST_CUTOFF_DTE               Nil\n                    SCD1           LAST_CUST_DISCONN_DTE              Nil\n                    SCD1           LAST_METER_INSPECT_DTE             Nil\n                    SCD1           OWNER_RENTER                       Nil\n                    SCD1           SEN_CITIZEN_FLAG                   Nil\n                    SCD1           VAC_FLAG                           Nil\n                    SCD1           WTR_ACCT_NUM_OF_UNITS              Nil\n                    SCD1           WTR_ACCT_ORIG_USE_TYPE             Nil\n                    SCD1           WTR_ACCT_PROP_USE_TYPE             Nil\n                    SCD1           WTR_METER_NUM                      Nil\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimItem.Procedure\nprint dimItem.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},"expanded":true},{"name":"dimIncdt","content":"let dimIncdt = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_INCDT             \" \"SRC_SYS_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , snowflakes =\n                 [\n                    \"DIM_INCDT_EMS_DET\"\n                 ]\n      , fields = [\n                    BusinessKey    SRC_SYS_ID                          \n                    SourceDate     DTE                                 \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   INCDT_KEY                              \n                    SCD2BeginDate  VERS_BEG_DTE                            \n                    SCD2EndDate    VERS_END_DTE                            \n                    SCD2Current    CURR_VERS_FLAG                      \n                    SCD2           ADJ_FLAG                              Nil Nil\n                    SCD1           BILLED_FLAG                           Nil\n                    SCD1           RSN_INCDT_NOT_BILLED                  Nil\n                    SCD1           INV_NUM                               Nil\n                    SCD1           PERMIT_IS_CURR_AT_TIME_OF_INCDT_FLAG  Nil\n                    SCD1           INCDT_DESCR                           Nil\n                    SCD1           VIO_CODE                              Nil\n                    SCD1           INCDT_TYPE                            Nil\n                    SCD1           INCDT_CAT                             Nil\n                    SCD1           TOWING_CMPNY                          Nil\n                    SCD1           BOOT_SERIAL_NUM                       Nil\n                    SCD1           PRKG_METER_VIO_FLAG                   Nil\n                    SCD1           PRKG_METER_NUM                        Nil\n                    SCD1           INCDT_SEQ_NUM                         Nil\n                    SCD1           INCDT_DTE                             Nil\n                    SCD1           INCDT_TIME                            Nil\n                    SCD1           INCDT_ADDR_LINE_1                     Nil\n                    SCD1           INCDT_ADDR_LINE_2                     Nil\n                    SCD1           INCDT_ADDR_LINE_3                     Nil\n                    SCD1           INCDT_ST_NUM                          Nil\n                    SCD1           INCDT_PREFIX                          Nil\n                    SCD1           INCDT_ST_PRETYPE                      Nil\n                    SCD1           INCDT_ST_NAME                         Nil\n                    SCD1           INCDT_ST_TYPE                         Nil\n                    SCD1           INCDT_SUFF                            Nil\n                    SCD1           INCDT_SERV_LVL                        Nil\n                    SCD1           INCDT_IN_CITY_FLAG                    Nil\n                    SCD1           INCDT_CITY                            Nil\n                    SCD1           INCDT_STATE                           Nil\n                    SCD1           INCDT_CTRY                            Nil\n                    SCD1           INCDT_ST_DIR                          Nil\n                    SCD1           INCDT_ST                              Nil\n                    SCD1           INCDT_CNTY                            Nil\n                    SCD1           INCDT_APT_LOT                         Nil\n                    SCD1           INCDT_GIS_MATCH_SCORE                 Nil\n                    SCD1           INCDT_GIS_ST_NUM                      Nil\n                    SCD1           INCDT_GIS_PREFIX                      Nil\n                    SCD1           INCDT_GIS_ST_PRETYPE                  Nil\n                    SCD1           INCDT_GIS_ST_NAME                     Nil\n                    SCD1           INCDT_GIS_ST_TYPE                     Nil\n                    SCD1           INCDT_GIS_SUFF                        Nil\n                    SCD1           INCDT_GIS_CITY                        Nil\n                    SCD1           INCDT_GIS_ZIP                         Nil\n                    SCD1           INCDT_GIS_X                           Nil\n                    SCD1           INCDT_GIS_Y                           Nil\n                    SCD1           INCDT_ZIP_CODE                        Nil\n                    SCD1           INCDT_ZIP_PLUS_4                      Nil\n                    SCD1           INCDT_GIS_LOCATR_NAME                 Nil\n                    SCD1           BLK_NUM                               Nil\n//                  SCD1           VEH                                   Nil\n//                  SCD1           EMS_INCDT                             Nil\n//                  SCD1           DISPATCH_NUM                          Nil\n//                  SCD1           EMS_INCDT_CAT                         Nil\n//                  SCD1           TXP_SERV_LVL                          Nil\n//                  SCD1           TXP_TYPE                              Nil\n//                  SCD1           ORIGIN_LOC                            Nil\n//                  SCD1           DEST_LOC                              Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n\n                    SCD1           FLAG_DIM_INCDT_EMS_DET                Nil\n                    SCD1           DEST_LOC                              Nil\n                    SCD1           DISPATCH_NUM                          Nil\n                    SCD1           EMS_INCDT                             Nil\n                    SCD1           EMS_INCDT_CAT                         Nil\n                    SCD1           ORIGIN_LOC                            Nil\n                    SCD1           TXP_SERV_LVL                          Nil\n                    SCD1           TXP_TYPE                              Nil\n                    SCD1           VEH                                   Nil\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimIncdt.Procedure\nprint dimIncdt.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},"expanded":true},{"name":"dimCust","content":"let dimCust = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CUST              \" \"CUST_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    CUST_ID                                \n                    SourceDate     DTE                                       \n                    IntraDayOrder  INTRA_DAY_ORDER\n                    ChangeReason   ROW_CHG_RSN\n\n                    SurrogateKey   CUST_KEY                               \n                    SCD2BeginDate  VERS_BEG_DTE                            \n                    SCD2EndDate    VERS_END_DTE                            \n                    SCD2Current    CURR_VERS_FLAG                      \n                    SCD2           JV_CUST_FLAG                          Nil Nil\n                    SCD2           DEC_CUST_FLAG                         Nil Nil\n                    SCD1           CONFI_CUST_FLAG                       Nil\n                    SCD1           CUST_EMAIL_ADDR                       Nil\n                    SCD1           CUST_PHN_NUM_1                        Nil\n                    SCD1           CUST_FAX_NUM                          Nil\n                    SCD1           CUST_NAME                             Nil\n                    SCD1           FED_TAX_ID                            Nil\n                    SCD1           CUST_TYPE                             Nil\n                    SCD1           BUS_CONT_PERSON_NAME                  Nil\n                    SCD1           STATE_CORP_CHTR_ID                    Nil\n                    SCD1           STATE_SALES_TAX_ID                    Nil\n                    SCD1           CUST_IS_VEND_FLAG                     Nil\n                    SCD1           SAP_BUS_ID                            Nil\n                    SCD1           NAICS_DET_CODE                        Nil\n                    SCD1           NAICS_INDY_CODE                       Nil\n                    SCD1           NAICS_INDY_GRP_CODE                   Nil\n                    SCD1           NAICS_MAJ_GRP_CODE                    Nil\n                    SCD1           NAICS_DIV_CODE                        Nil\n                    SCD1           SIC_INDY_GRP_CODE                     Nil\n                    SCD1           SIC_MAJ_GRP_CODE                      Nil\n                    SCD1           SIC_DIV_CODE                          Nil\n                    SCD1           DL_ISSUE_STATE                        Nil\n                    SCD1           DL_NUM                                Nil\n                    SCD1           CUST_ADDR_LINE_1                      Nil\n                    SCD1           CUST_ADDR_LINE_2                      Nil\n                    SCD1           CUST_ADDR_LINE_3                      Nil\n                    SCD1           CUST_ST_NUM                           Nil\n                    SCD1           CUST_PREFIX                           Nil\n                    SCD1           CUST_ST_PRETYPE                       Nil\n                    SCD1           CUST_ST_NAME                          Nil\n                    SCD1           CUST_ST_TYPE                          Nil\n                    SCD1           CUST_SUFF                             Nil\n                    SCD1           CUST_SERV_LVL                         Nil\n                    SCD1           CUST_IN_CITY_FLAG                     Nil\n                    SCD1           CUST_CITY                             Nil\n                    SCD1           CUST_STATE                            Nil\n                    SCD1           CUST_CTRY                             Nil\n                    SCD1           CUST_ST_DIR                           Nil\n                    SCD1           CUST_ST                               Nil\n                    SCD1           CUST_CNTY                             Nil\n                    SCD1           CUST_APT_LOT                          Nil\n                    SCD1           CUST_GIS_MATCH_SCORE                  Nil\n                    SCD1           CUST_GIS_ST_NUM                       Nil\n                    SCD1           CUST_GIS_PREFIX                       Nil\n                    SCD1           CUST_GIS_ST_PRETYPE                   Nil\n                    SCD1           CUST_GIS_ST_NAME                      Nil\n                    SCD1           CUST_GIS_ST_TYPE                      Nil\n                    SCD1           CUST_GIS_SUFF                         Nil\n                    SCD1           CUST_GIS_CITY                         Nil\n                    SCD1           CUST_GIS_ZIP                          Nil\n                    SCD1           CUST_GIS_X                            Nil\n                    SCD1           CUST_GIS_Y                            Nil\n                    SCD1           CUST_ZIP_CODE                         Nil\n                    SCD1           CUST_ZIP_PLUS_4                       Nil\n                    SCD1           CUST_GIS_LOCATR_NAME                  Nil\n                    SCD1           CUST_PAR_KEY                          Nil\n                    SCD1           SIC_CODE                              Nil\n                    SCD1           NAICS_DET_NAME                        Nil\n                    SCD1           NAICS_INDY_NAME                       Nil\n                    SCD1           NAICS_INDY_GRP_NAME                   Nil\n                    SCD1           NAICS_MAJ_GRP_NAME                    Nil\n                    SCD1           NAICS_DIV_NAME                        Nil\n                    SCD1           SIC_NAME                              Nil\n                    SCD1           SIC_INDY_GRP_NAME                     Nil\n                    SCD1           SIC_MAJ_GRP_NAME                      Nil\n                    SCD1           SIC_DIV_NAME                          Nil\n                    SCD1           CUST_PHN_NUM_2                        Nil\n                    SCD1           CUST_PHN_NUM_3                        Nil\n                    SCD1           SRC_SYS_MOD_DTE                       Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimCust.Procedure\nprint dimCust.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},"expanded":true},{"name":"dimFinTransType","content":"let dimFinTransType = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_FIN_TRANS_TYPE    \" \"DET_TRANS_CODE LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                                 \" \"\"\n      , fields = [\n                    BusinessKey    DET_TRANS_CODE                               \n                    SurrogateKey   FIN_TRANS_TYPE_KEY                  \n                    SCD1           PAY_METH                              Nil\n                    SCD1           MAN_TRANS_FLAG                        Nil\n                    SCD1           DERIVED_TRANS_FLAG                    Nil\n                    SCD1           MSTR_TRANS_TYPE                       Nil\n                    SCD1           SRC_SYS                               Nil\n                    SCD1           ALLOC_TRANS_FLAG                      Nil\n                    SCD1           DET_TRANS_DESCR                       Nil\n                    SCD1           T2_TRANS_TYPE_CODE                    Nil\n                    SCD1           T2_TRANS_TYPE_DESCR                   Nil\n                    SCD1           T2_TRANS_RSN                          Nil\n                    SCD1           T2_TRANS_PARSED_DESCR                 Nil\n                    SCD1           T2_TRANS_MISC_ITEM_CODE               Nil\n                    SCD1           T2_TRANS_MISC_ITEM_DESCR              Nil\n                    SCD1           T2_TRANS_SCENARIO                     Nil\n                    SCD1           INTRA_FUND_TRANS_FLAG                 Nil\n                    SCD1           T2_TRANS_ORIG_OBJ_TYPE_ID             Nil\n                    SCD1           SMARTCM_OTHER_CRITERIA                Nil\n                    SCD1           SMARTCM_IS_FEE                        Nil\n                    SCD1           SMARTCM_IS_ADJMT                      Nil\n                    SCD1           SMARTCM_IS_PAY                        Nil\n                    SCD1           PMAM_ADJMT_TO                         Nil\n                    SCD1           PMAM_ADJMT_TYPE                       Nil\n                    SCD1           DIGITECH_TRANS_TYPE                   Nil\n                    SCD1           DIGITECH_TRANS_TYPE_DET               Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\n(*\nopen SlowlyChangingDimensions\nprint dimFinTransType.Procedure\nprint dimFinTransType.Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},"expanded":true},{"name":"dims Carrier, Procedure, CollPerson, Emp, Dte,  CohOrg","content":"let dimCarrier = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CARRIER           \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    SRC_CARRIER_KEY                         \n                    SurrogateKey   CARRIER_KEY                            \n                    SCD1           MEDICARE_PAYER_CODE                   Nil\n                    SCD1           MEDICAID_PAYER_CODE                   Nil\n                    SCD1           CARRIER_FIN_GRP                       Nil\n                    SCD1           CARRIER_FIN_CLASS                     Nil\n                    SCD1           CARRIER_GRP                           Nil\n                    SCD1           CARRIER_NAME                          Nil\n                    SCD1           CARRIER_SRC                           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimProcedure = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_CARRIER_PROCEDURE \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    SRC_CARRIER_PROCEDURE_KEY                \n                    SurrogateKey   CARRIER_PROCEDURE_KEY                  \n                    SCD1           CARRIER_PROCEDURE_SRC                 Nil\n                    SCD1           CARRIER_PROCEDURE_CODE                Nil\n                    SCD1           CARRIER_PROCEDURE_DESCR               Nil\n                    SCD1           CARRIER_PROCEDURE_TYPE                Nil\n                    SCD1           CARRIER_PROCEDURE_BILL_CODE           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimCollPerson = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_COLL_PERSON       \" \"COLL_PERSON_ID LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                                 \" \"\"\n      , fields = [\n                    BusinessKey    COLL_PERSON_ID                           \n                    SurrogateKey   COLL_PERSON_KEY                        \n                    SCD1           T2_ID                                 Nil\n                    SCD1           PMAM_ID                               Nil\n                    SCD1           SMART_CM_ID                           Nil\n                    SCD1           HCTO_AD_VAL_ID                        Nil\n                    SCD1           COLL_PERSON_TYPE                      Nil\n                    SCD1           COLL_PERSON_NAME                      Nil\n                    SCD1           COH_EMP_NUM                           Nil\n                    SCD1           INT_EXT_EMP_FLAG                      Nil\n                    SCD1           DIGITECH_ID                           Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\nlet dimEmp = \n    Dimension.New(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_EMP               \" \"COH_EMP_NUM LIKE @SOURCE + '%'\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"                              \" \"\"\n      , fields = [\n                    BusinessKey    COH_EMP_NUM                                  \n                    SurrogateKey   EMP_KEY                                \n                    SCD1           EMP_TYPE                              Nil\n                    SCD1           EMP_NAME                              Nil\n                    SCD1           RM_LOAD_DTE                           Nil\n                    SCD1           RM_LOAD_TIME                          Nil\n                    SCD1           RM_EMP_MSTR_KEY                       Nil\n                    SCD0           LOAD_DTE                             \n                    SCD0           LOAD_TIME                            \n                 ]\n    )\n\n\n\nlet dimDte = \n    Dimension(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_DTE               \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    DTE                                         \n                    SurrogateKey   DTE_KEY                               \n                 ]\n    )\n\nlet dimCohOrg = \n    Dimension(\n        table  = SQLTableView.New \"         \" \"       \" \"DIM_COH_ORG           \" \"\" \"\"\n      , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n      , fields = [\n                    BusinessKey    DEPT_LONG_NAME                       \n                    SurrogateKey   COH_ORG_KEY\n                 ]\n    )\n    \n(*\nopen SlowlyChangingDimensions\nprint dimCarrier   .Procedure\nprint dimProcedure .Procedure\nprint dimCollPerson.Procedure\nprint dimEmp       .Procedure\nprint dimCohOrg    .Procedure\n\nprint dimCarrier   .Verification\nprint dimProcedure .Verification\nprint dimCollPerson.Verification\nprint dimEmp       .Verification\n*)    ","parent":{"$":0,"Item":"e92d574f-c4d0-4a21-8e98-4146a46fa036"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"}],"companions":[],"id":{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"},"expanded":true},{"name":"FactTable finTrans","content":"open Dimensions\nlet finTrans =\n    FactTable.New(\n               table  = SQLTableView.New \"         \" \"       \" \"FG_FIN_TRANS_INTER    \" \"\" \"\"\n             , source = SQLTableView.New \"         \" \"       \" \"FINTRANS              \" \"\" \"\"\n             , dims   = [ //        dimension       SurrogateKey    BusinessKey (if different)\n                          dimension dimCust         Nil              Nil_\n                          dimension dimReceivable   Nil              Nil_\n                          dimension dimItem         Nil              Nil_\n                          dimension dimIncdt        Nil              Nil_\n                        //dimension dimCarrier      Nil              Nil_\n                        //dimension dimProcedure    Nil              Nil_\n                          dimension dimCollPerson   Nil              Nil_\n                          dimension dimEmp          Nil              Nil_\n                          dimension dimFinTransType Nil              Nil_\n                          dimension dimCohOrg       Nil              Nil_\n                          dimension dimDte          TRANS_DTE_KEY    Nil_\n                          dimension dimDte          POST_DTE_KEY     POST_DTE\n                        ]\n             , fields = [\n                          OField  SYS_LOAD_KEY          \"(SELECT MAX(SYS_LOAD_KEY) FROM DIM_SYS_LOAD WHERE SRC_SYS = @SOURCE)\"\n                          OField  ORIG_CUST_KEY         \"D0.CUST_KEY     \"\n                          OField  COLL_VEND_CONTR_KEY   \"CON.CONTR_KEY   \"\n                          OField  GL_COMBO_KEY          \"1\"\n                          Fact    TRANS_CNT            \n                          Fact    TRANS_AMT            \n                          Fact    INTRA_FUND_TRANS_AMT \n                          Fact    LOAD_DTE             \n                          Fact    LOAD_TIME            \n                          Fact    SRC_SYS_TRANS_ID     \n                        ]\n             , extra  = \"\"\"\nBEGIN\n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'Started DELETE FG_FIN_TRANS_INTER', '';\n    DELETE S \n    FROM        FG_FIN_TRANS_INTER S \n    INNER JOIN  DIM_SYS_LOAD L ON L.SYS_LOAD_KEY = S.SYS_LOAD_KEY \n    INNER JOIN  DIM_DTE      D ON D.DTE_KEY      = S.TRANS_DTE_KEY\n    WHERE L.SRC_SYS = @SOURCE\n      AND D.DTE BETWEEN ISNULL(@FROM, '1000-01-01') AND ISNULL(@TO, '9999-12-31');\n    \n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'Started INSERT FG_FIN_TRANS_INTER', '';\n    %s\n LEFT JOIN  DIM_VEND             V ON V.VEND_ID               = S.VERS_ASSIGNED_VEND\n LEFT JOIN  DIM_CONTR          CON ON  CON.VEND_KEY           = V.VEND_KEY              AND S.DTE BETWEEN CON.VALID_FROM_DTE AND CON.VALID_TO_DTE\n                                  AND (CON.CONTR_REV_STREAM   = S.SRC_SYS                OR CON.CONTR_REV_STREAM   = '***'    ) \n\n  EXEC GENERIC.Log @SOURCE, 'SP_LOAD_FG_FIN_TRANS', 'FINISHED!!! INSERT FG_FIN_TRANS_INTER', '';\nEND\n             \"\"\"\n             )\n\n(*\nopen SlowlyChangingDimensions\nprint finTrans       .Procedure\n*)\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"}],"companions":[],"id":{"$":0,"Item":"ca42551e-1781-4b7f-ba28-609caafa658c"},"expanded":true},{"name":"SQLFetchFields & SnowFlakeViews ","content":"#if SLOWLY_CHANGING_DIMENSIONS\n#define SQL_FETCH_FIELDS \nopen FSharp.Data\n\n[<Literal>]\nlet ConnectionString = @\"Data Source=ARStagingDB.HouTx.lcl;Initial Catalog=ARDatamart;UID=cipherbsc;PWD=123456\"\nlet columns = \n    lazy\n        use cmd = new SqlCommandProvider<\"\nWITH Columns as (\n    SELECT DISTINCT \n           ColumnName = ISNULL(UPPER(COLUMN_NAME), 'Nil')\n         , DataType   = ISNULL(DATA_TYPE + ISNULL('(' + CONVERT(VARCHAR(20), CHARACTER_MAXIMUM_LENGTH) + ')', ''), '')\n         , NULLABLE = IIF(ISNULL(IS_NULLABLE, '') = 'NO', 0, 1)\n         , NRec = ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY TABLE_NAME)\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_NAME  LIKE 'DIM_%'\n       OR TABLE_NAME = 'FG_FIN_TRANS'\n)\nSELECT ColumnName, DataType, NULLABLE  \nFROM Columns WHERE NRec = 1\n\" , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n        cmd.Execute()\n\nlet defaults =\n    lazy\n        use cmd = new SqlCommandProvider<\"SELECT TOP 1 * FROM ARStaging.EMS_MSB.VW_FG_FIN_TRANS\" , ConnectionString, ResultType = ResultType.DataReader>(ConnectionString)\n        use rdr = cmd.Execute()\n        if rdr.Read() |> not then [||] else\n        [|\n            for i = 0 to rdr.FieldCount - 1 do\n                if rdr.IsDBNull i |> not then\n                    yield rdr.GetName i, rdr.GetValue i \n                                         |> sprintf \"%A\" \n                                         |> fun s -> if s.StartsWith \"\\\"\" \n                                                     then s.[1..s.Length-2] |> sprintf \"'%s'\" \n                                                     else s\n        |]\n\n\nlet writeFieldDecl () =\n    columns.Value\n    |> Seq.map (sprintf \"%A\") \n    |> String.concat \"\\n    \" \n    |> sprintf \"let fieldDecl = [|\\n    %s \\n|]\"\n    |> fun txt -> System.IO.File.WriteAllText(\"FieldDecl.fsx\", txt)\n\nlet writeFieldDefault_Source () =\n    defaults.Value\n    |> Seq.sortBy snd\n    |> Seq.map (sprintf \"%A\") \n    |> String.concat \"\\n    \" \n    |> sprintf \"let fieldDefault = [|\\n    %s \\n|]\"\n    |> fun txt -> System.IO.File.WriteAllText(\"FieldDefault source.fsx\", txt)\n\n[<Literal>]\nlet columnsQuery = \"\nWITH Columns as (\n    SELECT DISTINCT \n\t\t   TableName  = ISNULL(UPPER(TABLE_NAME), 'Nil')\n         , ColumnName = ISNULL(UPPER(COLUMN_NAME), 'Nil')\n         , DataType   = ISNULL(DATA_TYPE + ISNULL('(' + CONVERT(VARCHAR(20), CHARACTER_MAXIMUM_LENGTH) + ')', ''), '')\n         , NULLABLE = IIF(ISNULL(IS_NULLABLE, '') = 'NO', 0, 1)\n         , NRec = ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY TABLE_NAME)\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_NAME  LIKE 'DIM_%'\n       OR TABLE_NAME = 'FG_FIN_TRANS'\n)\nSELECT DISTINCT \n       TableName\n     , ColumnName\n  FROM Columns\n WHERE CHARINDEX('|' + TableName + '|', @tables) > 0\nORDER BY 1, 2   \n   \"\n\ntype Dimension with\n    member this.allColumns() =\n        use cmd = new SqlCommandProvider<columnsQuery , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n        cmd.Execute(this.Snowflakes |> String.concat \"|\" |> sprintf \"|%s|%s|\" this.TableBase.sqlObject)\n    member this.superView() =\n        if this.Snowflakes |> Seq.isEmpty then \"\" else\n        let columns    = this.allColumns()\n        let first      = this.TableBase.sqlObject\n        let snowflakes = this.Snowflakes |> Seq.sort\n        let flags      = snowflakes |> Seq.map (sprintf \"        FLAG_%s = 0\")\n        let from  = \n            snowflakes\n            |> Seq.map (fun j -> sprintf \"LEFT JOIN %s ON %s.%s = %s.%s\" j j this.SurrogateKey first this.SurrogateKey)\n            |> String.concat \"\\n\"\n            |> sprintf \"  FROM %s \\n%s\" first\n        let fieldList f fields = fields |> Seq.map f |> String.concat \",\\n\"\n        let view =\n            columns\n            |> Seq.distinctBy (fun (tb, cl) -> cl)\n            |> fieldList (fun (tb, cl) -> sprintf \"        %s.%s\" (nameS tb) (nameS cl))\n            |> sprintf \"%s,\\n%s\" (flags |> String.concat \",\\n\")\n            |> sprintf \"SELECT \\n%s\\n%s\" <| from\n            |> sprintf \"%sAS\\n%s;\\nGO\" (sqlDropCreate VIEW (sprintf \"GENERIC.%s\" this.TableName))\n        let fields table = columns |> Seq.filter (fst >> ((=) table))\n        let snowflakeCond table = \n            if table = first then \"\" else \n            sprintf \"IF (SELECT TOP 1 FLAG_%s FROM INSERTED) = 1 \\n\" table\n        let createTrigger command codes =\n            codes\n            |> String.concat \";\\n\"\n            |> sprintf \"  ON GENERIC.SV_%s\\nINSTEAD OF %s AS\\nBEGIN\\n%s\\nEND;\\nGO\" first command\n            |> sprintf \"%s\\n%s\" (sqlDropCreate TRIGGER (sprintf \"GENERIC.TR_%s_%s\" command first))\n        let insertTable table =\n            fields table\n            |> fieldList (fun (tb, cl) -> sprintf \"        %s\" (nameS cl))\n            |> (fun flds -> \n                sprintf \"%s  INSERT INTO %s (%s)\\n  SELECT %s \\n  FROM inserted\"\n                  (snowflakeCond table) table flds flds      \n               )\n        let updateTable table =\n            fields table\n            |> fieldList (fun (tb, cl) -> sprintf \"    %s = inserted.%s\" (nameS cl) (nameS cl))\n            |> sprintf \"%s  UPDATE T SET\\n%s\\n  FROM %s T, inserted  \\n  WHERE T.%s = inserted.%s;\"\n                 (snowflakeCond table)\n                 <| table <| this.SurrogateKey <| this.SurrogateKey \n        let tables = Seq.append [first] snowflakes\n        let insert = tables |> Seq.map insertTable |> createTrigger \"INSERT\"\n        let update = tables |> Seq.map updateTable |> createTrigger \"UPDATE\"\n        view + insert + update\n\nlet snowflakeFields (dim: Dimension) =\n    if dim.Snowflakes |> Seq.isEmpty then \"\" else\n    use cmd = new SqlCommandProvider<columnsQuery , ConnectionString, ResultType = ResultType.Tuples>(ConnectionString)\n    let columns = \n        cmd.Execute(dim.Snowflakes |> Seq.sort |> String.concat \"|\" |> sprintf \"|%s|%s|\" dim.TableName)\n        |> Seq.distinctBy (fun (tb, cl) -> cl)\n\n    dim.Snowflakes\n    |> Seq.collect\n         (fun t ->\n            Seq.append\n                [ sprintf \"FLAG_%s\" t ]\n                (columns |> Seq.filter(fun (tb, fl) -> tb = t) |> Seq.map snd)\n         )\n    |> String.concat \"\\n\"\n\nlet snowflakeMissingFields (dim: Dimension) =\n    dim.allColumns()\n    |> Seq.filter(fun (tb, fn) -> \n        (finTransViewFieldNames |> Seq.contains fn |> not)\n     && (targetFieldNames       |> Seq.contains fn |> not)\n    )\n\nlet wrongFields (dim: Dimension) =\n    dim.AllFields\n    |> Seq.filter (fun n -> dim.allColumns() |> Seq.exists (fun (tb, cl) -> cl = n) |> not)\n\n#endif\n\n(*          \nopen SlowlyChangingDimensions\nprint <| dimItem      .superView()\nprint <| dimIncdt     .superView()\nprint <| dimReceivable.superView()\n\ndo writeFieldDecl()\ndo writeFieldDefault_Source()\n\nprint <| snowflakeFields dimIncdt      \nprint <| snowflakeFields dimItem       \nprint <| snowflakeFields dimReceivable \n\ndimReceivable.allColumns()            |> Seq.toList |> printfn \"%A\" \nsnowflakeMissingFields dimItem        |> Seq.iter     (printfn \"%A\")  \nsnowflakeMissingFields dimIncdt       |> Seq.iter     (printfn \"%A\")  \nsnowflakeMissingFields dimReceivable  |> Seq.iter     (printfn \"%A\")  \nwrongFields dimItem        |> Seq.iter     (printfn \"%A\")  \nwrongFields dimIncdt       |> Seq.iter     (printfn \"%A\")  \nwrongFields dimReceivable  |> Seq.iter     (printfn \"%A\")  \nwrongFields dimCust        |> Seq.iter     (printfn \"%A\")\nwrongFields dimCarrier     |> Seq.iter     (printfn \"%A\")\nwrongFields dimProcedure   |> Seq.iter     (printfn \"%A\")\nwrongFields dimCollPerson  |> Seq.iter     (printfn \"%A\")\nwrongFields dimEmp         |> Seq.iter     (printfn \"%A\")\nwrongFields dimCohOrg      |> Seq.iter     (printfn \"%A\")\nwrongFields dimFinTransType|> Seq.iter     (printfn \"%A\")\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"db8ed4d6-4bee-407f-958e-250016275444"},"expanded":true},{"name":"Copy Views and Procedures","content":"#if SLOWLY_CHANGING_DIMENSIONS\n\nlet bAllViews = \"Copy ALL views\", fun _ -> AllFactViews  |> Seq.map (fun st -> st.Query    ) |> String.concat \"\\n\\n\"          |> Useful.sCopy  \nlet bAllDims  = \"Copy ALL dims\" , fun _ -> AllDimensions |> Seq.map (fun dm -> dm.Procedure) |> String.concat \"\\n\\n\"          |> Useful.sCopy  \nlet bViews    = AllFactViews  |> Seq.map    (fun st -> st.ViewName      |> sprintf \"Copy %s\", (fun _ -> st.Query       |> Useful.sCopy )) |> Seq.toList\nlet bDims     = AllDimensions |> Seq.map    (fun dm -> dm.ProcedureName |> sprintf \"Copy %s\", (fun _ -> dm.Procedure   |> Useful.sCopy )) |> Seq.toList\nlet bfact     = AllFactTables |> Seq.map    (fun ft -> ft.ProcedureName |> sprintf \"Copy %s\", (fun _ -> ft.Procedure   |> Useful.sCopy )) |> Seq.toList\n#if SQL_FETCH_FIELDS\nlet bSuperVw  = AllDimensions |> Seq.filter (fun dm -> dm.Snowflakes |> Seq.isEmpty |> not) \n                              |> Seq.map    (fun dm -> dm.TableName  |> sprintf \"Copy %s SuperView\", (fun _ -> dm.superView() |> Useful.sCopy )) |> Seq.toList\n#endif                              \n\n[\n  if not bViews.IsEmpty then\n      yield ( \"===== For ARStaging Database ======\", fun _ -> \"---------------------\"  )\n  if bViews.Length > 1 then yield bAllViews\n  yield! bViews\n  if not AllDimensions.IsEmpty then\n      yield ( \"===== For ARDatamart Database =====\", fun _ -> \"---------------------\"  )\n  if bDims.Length  > 1 then yield bAllDims\n  yield! bDims\n  if not AllFactTables.IsEmpty then \n      yield ( \"------ Fact Tables -------\"         , fun _ -> \"---------------------\"  )\n      yield! bfact\n#if SQL_FETCH_FIELDS\n  if not bSuperVw.IsEmpty then\n      yield ( \"------ Super Views -------\"         , fun _ -> \"---------------------\"  )\n  yield! bSuperVw\n#endif                              \n]\n#else\n[]\n#endif\n|> (fun l -> if l.IsEmpty then [ \"=== Select in F# some Views and/or Dimensions ===\", fun _ -> \"Nothing selected\" ]  else l)\n|> Useful.ActionBar\n\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[{"$":0,"Item":"a8351a4c-1fdb-4f57-8fca-8fed60008c36"},{"$":0,"Item":"04f28553-8359-4ba0-9281-bc45839b844f"},{"$":0,"Item":"28e52d96-1900-4150-a99d-6f5ed15bd1df"},{"$":0,"Item":"3b47f651-d4ef-41db-90f3-ad67d1a4b6eb"},{"$":0,"Item":"96efc394-df97-4995-9643-b15f9475e16c"},{"$":0,"Item":"72108083-b588-4246-9978-6fff21e46351"},{"$":0,"Item":"e193a2d8-54ab-4b99-a5cf-a6084db9fffb"},{"$":0,"Item":"7e3c7382-100e-4212-b9be-02cd9f1cb2db"},{"$":0,"Item":"ca42551e-1781-4b7f-ba28-609caafa658c"},{"$":0,"Item":"db8ed4d6-4bee-407f-958e-250016275444"},{"$":0,"Item":"81c54ba2-389b-4333-8e02-42004320dde0"},{"$":0,"Item":"80a1bb44-c482-4a00-bf8a-63832322bad9"},{"$":0,"Item":"79ff8549-d6f4-47cf-b0c0-efc9eaa6e813"},{"$":0,"Item":"d2205189-f6a8-4e24-81b2-5b485d18f424"},{"$":0,"Item":"16f618b6-0483-44dc-9c54-550f4f5b725d"}],"companions":[],"id":{"$":0,"Item":"daa2fd06-2419-40bf-a9af-7f9863420fa5"},"expanded":true},{"name":"module Snippets =","content":"module Snippets =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"expanded":false},{"name":"","content":"let private displayHtml html = \n  let url = Server.instance.Value.AddPage(html)\n  System.Diagnostics.Process.Start(url) |> ignore\n\nfsi.AddPrinter(fun (chart:XPlot.GoogleCharts.GoogleChart) ->\n  let ch = chart |> XPlot.GoogleCharts.Chart.WithSize (800, 600)\n  ch.GetHtml() |> displayHtml\n  \"(Google Chart)\")\n\nfsi.AddPrinter(fun (chart:XPlot.Plotly.PlotlyChart) ->\n  \"\"\"<!DOCTYPE html>\n  <html>\n  <head>\n      <title>Plotly Chart</title>\n      <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n  </head>\n  <body>\"\"\" + chart.GetInlineHtml() + \"</body></html>\" |> displayHtml","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},"expanded":true},{"name":"","content":"let a = 9 + 8\n\n\n7 * 3\n|> printfn \"%A\"\n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},"expanded":true},{"name":"Stack Overflow","content":"let rec recursive i = 1 + recursive i\nrecursive 1","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},"expanded":true},{"name":"Calculate primes","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\ntype BackgroundWorker with\n        member this.AsyncRunWorker (computation, argument : 'T, progressChangedHandler) : Async<'U> =\n            let workerAsync =\n                Async.FromContinuations (fun (cont, econt, ccont) ->\n                            let handler = new RunWorkerCompletedEventHandler (fun sender args ->          \n                                if args.Cancelled then\n                                    ccont (new OperationCanceledException()) \n                                elif args.Error <> null then\n                                    econt args.Error\n                                else\n                                    cont (args.Result :?> 'U))\n                            this.WorkerSupportsCancellation <- true;\n                            this.WorkerReportsProgress <- true\n                            this.DoWork.AddHandler(new DoWorkEventHandler(fun sender args ->\n                                args.Result <- computation(argument, this, args)))\n                            this.ProgressChanged.AddHandler(progressChangedHandler)\n                            this.RunWorkerCompleted.AddHandler(handler)\n                            this.RunWorkerAsync(argument)\n                        )\n\n            async { \n                use! holder = Async.OnCancel(fun _ -> this.CancelAsync())\n                return! workerAsync\n             }\n\nlet factorial number =\n    let rec fact number =\n        match number with\n        | value when value < 0I ->\n            raise (InvalidOperationException(sprintf \"Cannot compute the factorial of a negative number: %s.\" (value.ToString())))\n        | value when value > 2000I ->\n            raise (InvalidOperationException(sprintf \"Input too large: %s\" (value.ToString())))\n        | value when value = 0I -> 1I\n        | value when value = 1I -> 1I\n        | number -> number * fact (number - 1I)\n    fact number\n\n// Recursive isprime function.\nlet isprime number =\n    let rec check count =\n        count > number/2 || (number % count <> 0 && check (count + 1))\n    check 2\n\nlet isprimeBigInt number =\n    let rec check count =\n        count > number/2I || (number % count <> 0I && check (count + 1I))\n    check 2I\n\nlet computeNthPrime (number, worker: BackgroundWorker, eventArgs: DoWorkEventArgs) =\n     if (number < 1) then\n         invalidOp <| sprintf \"Invalid input for nth prime: %s.\" (number.ToString())\n     let mutable count = 0\n     let mutable num = 1I\n     let isDone = false\n     while (count < number && not eventArgs.Cancel ) do\n         if (worker.CancellationPending) then\n             eventArgs.Cancel <- true\n         else\n             let percentComplete = int ((float count) / (float number) * 100.0)\n             worker.ReportProgress(percentComplete, num.ToString())\n         num <- num + 1I\n         if (num < bigint System.Int32.MaxValue) then\n             while (not (isprime (int num))) do\n                 num <- num + 1I\n         else\n             while (not (isprimeBigInt num)) do\n                 num <- num + 1I\n         count <- count + 1\n     num\n         \nlet async1 (progressBar:ProgressBar) (label:Label) value =\n     let worker = new BackgroundWorker()\n     label.Text <- \"Computing...\"\n     let computation value = worker.AsyncRunWorker(computeNthPrime, value,\n                                                   (fun sender (eventArgs:ProgressChangedEventArgs) ->\n                                                       label.Text <- \"Scanning ... \" + eventArgs.UserState.ToString()\n                                                       progressBar.Value <- eventArgs.ProgressPercentage ))\n     Async.StartWithContinuations(\n         computation value,\n         (fun result -> label.Text <- sprintf \"Result: %s\" (result.ToString())),\n         (fun exn -> label.Text <- \"Operation failed with error:\" + exn.Message),\n         (fun _ -> label.Text <- \"Operation canceled.\"))\n\nlet form = new Form(Text = \"Test Form\", Width = 400, Height = 400)\nlet panel1 = new Panel(Dock = DockStyle.Fill)\npanel1.DockPadding.All <- 10\nlet spacing = 5\nlet button1 = new Button(Text = \"Start\")\nlet button2 = new Button(Text = \"Start Invalid\", Top = button1.Height + spacing)\nlet button3 = new Button(Text = \"Cancel\", Top = 2 * (button1.Height + spacing))\nlet updown1 = new System.Windows.Forms.NumericUpDown(Top = 3 * (button1.Height + spacing), \n                                                     Value = 20m,\n                                                     Minimum = 0m,\n                                                     Maximum = 1000000m)\nlet label1 = new Label (Text = \"\", Top = 4 * (button1.Height + spacing),\n                        Width = 300, Height = 2 * button1.Height)\nlet progressBar = new ProgressBar(Top = 6 * (button1.Height + spacing),\n                                  Width = 300)\npanel1.Controls.AddRange [| button1; button2; button3; updown1; label1; progressBar; |]\nform.Controls.Add(panel1)\nbutton1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\nbutton2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\nbutton3.Click.Add(fun args -> Async.CancelDefaultToken())\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},"expanded":true},{"name":"Form test","content":"open System\nopen System.ComponentModel\nopen System.Windows.Forms\n\nlet label1 = new Label (Text = \"\", Width = 300)\nlet newButton txt =\n    let btn = new Button(Text = txt)\n    btn.Click.Add (fun args -> label1.Text <- txt)\n    btn :> Control\n        \n\nlet spacing = 5\nlet button1 = newButton \"Start\"\nlet button2 = newButton \"Start Invalid\"\nlet button3 = newButton \"Cancel\"\nlet updown1 = new System.Windows.Forms.NumericUpDown(Value = 20m,\n                                                     Minimum = 0m,\n                                                     Maximum = 1000000m)\nlet progressBar = new ProgressBar(Width = 300)\n\nlet panel1 = new Panel(Dock = DockStyle.Fill)\n\n[| button1     :> Control\n   button2     :> Control\n   button3     :> Control\n   updown1     :> Control\n   label1      :> Control\n   progressBar :> Control\n|]\n|> Array.mapi (fun i cts -> cts.Top <- i * 25 ; cts)\n|> panel1.Controls.AddRange\npanel1.DockPadding.All <- 10\n//button1.Click.Add(fun args -> async1 progressBar label1 (int updown1.Value))\n//button2.Click.Add(fun args -> async1 progressBar label1 (int (-updown1.Value)))\n//button3.Click.Add(fun args -> Async.CancelDefaultToken())\nlet form = new Form(Text = \"Select Actions\", Width = 400, Height = 400)\nform.Controls.Add(panel1)\nform.Activated.AddHandler(System.EventHandler (fun _ _ -> form.TopMost <- true(*; form.TopMost <- false*) ))\nasync {\n  do Application.Run(form) \n} |> Async.Start","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"dc44bbe1-876a-4910-a39a-5d74bc2304ee"},"expanded":true},{"name":"Test FSharp.Compiler.Service","content":"let input = \"\"\"\n(**)#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance \nlet checker = FSharpChecker.Create()\n\n// Sample input as a multi-line string\nlet input = \"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nasync {\n    let! projOptions                   = checker.GetProjectOptionsFromScript(file, input)\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                         return sprintf \"%A\" tip                              }\n        | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n} |> Async.RunSynchronously\n\"\"\"              \n\n#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\ServiceStack.Text\\lib\\net45\\ServiceStack.Text.dll\"\n#r @\"FSharp.Compiler.Service.dll\"\n#define XX\nopen System\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen ServiceStack.Text\n\n// Create an interactive checker instance \nlet checker = FSharpChecker.Create()\n\n// Split the input & define file name \"\nlet file       = \"/home/user/Test.fsx\"\nlet inputLines = input.Split('\\n')\nlet line       = 8\nlet lineStr    = inputLines.[line - 1]\nprintfn \":%s\" lineStr\nasync {\n    let! projOptions, errors           = checker.GetProjectOptionsFromScript(file, input)\n    printfn \"%A\" errors\n    let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n    let! tip                           =\n        match checkFileAnswer with\n        | FSharpCheckFileAnswer.Succeeded res -> \n//                 sprintfn \"answer:%A\" res.GetAllUsesOfAllSymbolsInFile\n                 async { let! tip = res.GetToolTipTextAlternate(line, 17, lineStr, [\"checker\"], FSharpTokenTag.IDENT) \n//                 async { //let tip = res.//GetAllUsesOfAllSymbolsInFile() \n                         //.Replace(\" \", \"_\")\n                               //|> Seq.map (fun u -> u.DisplayContext, u.FileName, u.RangeAlternate, u.Symbol)\n                               // |> Seq.map (sprintf \"%A\")\n                               // |> String.concat \"\\n\"\n                         return sprintf \"%A\" tip }\n        | res -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n    printfn \"%s\" tip\n    //parseResults.PrintDump()\n} |> Async.RunSynchronously","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"d54a55c5-1462-4983-a966-4feb4cfccb2a"},"expanded":true},{"name":"","content":"module FSAutoComplete =","parent":{"$":0,"Item":"edbbf11e-4698-4e33-af0c-135d5b21799b"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"expanded":false},{"name":"Utils","content":"#r @\"D:\\Abe\\CIPHERWorkspace\\Repos\\packages\\FSharp.Compiler.Service\\lib\\net45\\FSharp.Compiler.Service.dll\"\nopen System.IO\nopen System.Collections.Concurrent\nopen System.Diagnostics\nopen System\n\n\nmodule Utils =\n    \n    type Result<'a> =\n      | Success of 'a\n      | Failure of string\n    \n    type Pos =\n        { Line: int\n          Col: int }\n    \n    type Range =\n        { StartLine : int\n          StartColumn : int\n          EndLine : int\n          EndColumn: int}\n    \n    type Document =\n        { FullName : string\n          LineCount : int\n          GetText : unit -> string\n          GetLineText0 : int -> string\n          GetLineText1 : int -> string}\n    \n    [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\n    module Pos =\n        let make line column = { Line = line; Col = column }\n    \n    \n    type Serializer = obj -> string\n    type ProjectFilePath = string\n    type SourceFilePath = string\n    type LineStr = string\n    \n    let isAScript fileName =\n        let ext = Path.GetExtension fileName\n        [\".fsx\";\".fsscript\";\".sketchfs\"] |> List.exists ((=) ext)\n    \n    let runningOnMono =\n      try not << isNull <| Type.GetType \"Mono.Runtime\"\n      with _ -> false\n    \n    let normalizePath (file : string) =\n      if file.EndsWith \".fs\" || file.EndsWith \".fsi\" then\n          let p = Path.GetFullPath file\n          (p.Chars 0).ToString().ToLower() + p.Substring(1)\n      else file\n    \n    let inline combinePaths path1 (path2 : string) = Path.Combine(path1, path2.TrimStart [| '\\\\'; '/' |])\n    \n    let inline (</>) path1 path2 = combinePaths path1 path2\n    \n    let private sepChar = Path.DirectorySeparatorChar\n    \n    let normalizeDirSeparators (path: string) =\n      match sepChar with\n      | '\\\\' -> path.Replace('/', '\\\\')\n      | '/' -> path.Replace('\\\\', '/')\n      | _ -> path\n      \nopen Utils      \n    \n[<RequireQualifiedAccess>]\nmodule Option =\n\n  let inline attempt (f: unit -> 'T) = try Some <| f() with _ -> None\n\n  let getOrElse defaultValue option =\n    match option with\n    | None -> defaultValue\n    | Some x -> x\n\n  /// Gets the option if Some x, otherwise the supplied default value.\n  let inline orElseX v option =\n    match option with\n    | Some x -> Some x\n    | None -> v\n\n\n  let orElseFun other option =\n    match option with\n    | None -> other()\n    | Some x -> Some x\n\n  let getOrElseFun defaultValue option =\n    match option with\n    | None -> defaultValue()\n    | Some x -> x\n\n  let inline orTry f =\n    function\n    | Some x -> Some x\n    | None -> f()\n\n  /// Some(Some x) -> Some x | None -> None\n  let inline flatten x =\n    match x with\n    | Some x -> x\n    | None -> None\n\n\n[<RequireQualifiedAccess>]\nmodule Async =\n    /// Transforms an Async value using the specified function.\n    [<CompiledName(\"Map\")>]\n    let map (mapping : 'a -> 'b) (value : Async<'a>) : Async<'b> =\n        async {\n            // Get the input value.\n            let! x = value\n            // Apply the mapping function and return the result.\n            return mapping x\n        }\n\n    // Transforms an Async value using the specified Async function.\n    [<CompiledName(\"Bind\")>]\n    let bind (binding : 'a -> Async<'b>) (value : Async<'a>) : Async<'b> =\n        async {\n            // Get the input value.\n            let! x = value\n            // Apply the binding function and return the result.\n            return! binding x\n        }\n\n[<Sealed>]\ntype AsyncMaybeBuilder () =\n    [<DebuggerStepThrough>]\n    member __.Return value : Async<'T option> = Some value |> async.Return\n\n    [<DebuggerStepThrough>]\n    member __.ReturnFrom value : Async<'T option> = value\n\n    [<DebuggerStepThrough>]\n    member __.ReturnFrom (value: 'T option) : Async<'T option> = async.Return value\n\n    [<DebuggerStepThrough>]\n    member __.Zero () : Async<unit option> =\n        Some () |> async.Return\n\n    [<DebuggerStepThrough>]\n    member __.Delay (f : unit -> Async<'T option>) : Async<'T option> = f ()\n\n    [<DebuggerStepThrough>]\n    member __.Combine (r1, r2 : Async<'T option>) : Async<'T option> =\n        async {\n            let! r1' = r1\n            match r1' with\n            | None -> return None\n            | Some () -> return! r2\n        }\n\n    [<DebuggerStepThrough>]\n    member __.Bind (value: Async<'T option>, f : 'T -> Async<'U option>) : Async<'U option> =\n        async {\n            let! value' = value\n            match value' with\n            | None -> return None\n            | Some result -> return! f result\n        }\n\n    [<DebuggerStepThrough>]\n    member __.Bind (value: 'T option, f : 'T -> Async<'U option>) : Async<'U option> =\n        async {\n            match value with\n            | None -> return None\n            | Some result -> return! f result\n        }\n\n    [<DebuggerStepThrough>]\n    member __.Using (resource : ('T :> IDisposable), body : _ -> Async<_ option>) : Async<_ option> =\n        try body resource\n        finally\n            if not << isNull <| resource then resource.Dispose ()\n\n    [<DebuggerStepThrough>]\n    member x.While (guard, body : Async<_ option>) : Async<_ option> =\n        if guard () then\n            x.Bind (body, (fun () -> x.While (guard, body)))\n        else\n            x.Zero ()\n\n    [<DebuggerStepThrough>]\n    member x.For (sequence : seq<_>, body : 'T -> Async<unit option>) : Async<_ option> =\n        x.Using (sequence.GetEnumerator (), fun enum ->\n            x.While (enum.MoveNext, x.Delay (fun () -> body enum.Current)))\n\n    [<DebuggerStepThrough>]\n    member inline __.TryWith (computation : Async<'T option>, catchHandler : exn -> Async<'T option>) : Async<'T option> =\n            async.TryWith (computation, catchHandler)\n\n    [<DebuggerStepThrough>]\n    member inline __.TryFinally (computation : Async<'T option>, compensation : unit -> unit) : Async<'T option> =\n            async.TryFinally (computation, compensation)\n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule AsyncMaybe =\n    let inline liftAsync (async : Async<'T>) : Async<_ option> =\n        async |> Async.map Some\n\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Array =\n    let inline private checkNonNull argName arg =\n        match box arg with\n        | null -> nullArg argName\n        | _ -> ()\n\n    /// Optimized arrays equality. ~100x faster than `array1 = array2` on strings.\n    /// ~2x faster for floats\n    /// ~0.8x slower for ints\n    let inline areEqual (xs: 'T []) (ys: 'T []) =\n        match xs, ys with\n        | null, null -> true\n        | [||], [||] -> true\n        | null, _ | _, null -> false\n        | _ when xs.Length <> ys.Length -> false\n        | _ ->\n            let mutable break' = false\n            let mutable i = 0\n            let mutable result = true\n            while i < xs.Length && not break' do\n                if xs.[i] <> ys.[i] then\n                    break' <- true\n                    result <- false\n                i <- i + 1\n            result\n\n\n    /// Fold over the array passing the index and element at that index to a folding function\n    let foldi (folder: 'State -> int -> 'T -> 'State) (state: 'State) (array: 'T []) =\n        checkNonNull \"array\" array\n        if array.Length = 0 then state else\n        let folder = OptimizedClosures.FSharpFunc<_,_,_,_>.Adapt folder\n        let mutable state:'State = state\n        let len = array.Length\n        for i = 0 to len - 1 do\n            state <- folder.Invoke (state, i, array.[i])\n        state\n\n    /// Returns all heads of a given array.\n    /// For [|1;2;3|] it returns [|[|1; 2; 3|]; [|1; 2|]; [|1|]|]\n    let heads (array: 'T []) =\n        checkNonNull \"array\" array\n        let res = Array.zeroCreate<'T[]> array.Length\n        for i = array.Length - 1 downto 0 do\n            res.[i] <- array.[0..i]\n        res\n\n    /// check if subArray is found in the wholeArray starting\n    /// at the provided index\n    let inline isSubArray (subArray: 'T []) (wholeArray:'T []) index =\n        if isNull subArray || isNull wholeArray then false\n        elif subArray.Length = 0 then true\n        elif subArray.Length > wholeArray.Length then false\n        elif subArray.Length = wholeArray.Length then areEqual subArray wholeArray else\n        let rec loop subidx idx =\n            if subidx = subArray.Length then true\n            elif subArray.[subidx] = wholeArray.[idx] then loop (subidx+1) (idx+1)\n            else false\n        loop 0 index\n\n    /// Returns true if one array has another as its subset from index 0.\n    let startsWith (prefix: _ []) (whole: _ []) =\n        isSubArray prefix whole 0\n\n    /// Returns true if one array has trailing elements equal to another's.\n    let endsWith (suffix: _ []) (whole: _ []) =\n        isSubArray suffix whole (whole.Length-suffix.Length)\n\n    /// Returns a new array with an element replaced with a given value.\n    let replace index value (array: _ []) =\n        checkNonNull \"array\" array\n        if index >= array.Length then raise (IndexOutOfRangeException \"index\")\n        let res = Array.copy array\n        res.[index] <- value\n        res\n\n    /// pass an array byref to reverse it in place\n    let revInPlace (array: 'T []) =\n        checkNonNull \"array\" array\n        if areEqual array [||] then () else\n        let arrlen, revlen = array.Length-1, array.Length/2 - 1\n        for idx in 0 .. revlen do\n            let t1 = array.[idx]\n            let t2 = array.[arrlen-idx]\n            array.[idx] <- t2\n            array.[arrlen-idx] <- t1\n\n\n\n\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule String =\n    let inline toCharArray (str:string) = str.ToCharArray()\n\n    let lowerCaseFirstChar (str: string) =\n        if String.IsNullOrEmpty str\n         || Char.IsLower(str, 0) then str else\n        let strArr = toCharArray str\n        match Array.tryHead strArr with\n        | None -> str\n        | Some c  ->\n            strArr.[0] <- Char.ToLower c\n            String (strArr)\n\n\n    let extractTrailingIndex (str: string) =\n        match str with\n        | null -> null, None\n        | _ ->\n            let charr = str.ToCharArray()\n            Array.revInPlace charr\n            let digits = Array.takeWhile Char.IsDigit charr\n            Array.revInPlace digits\n            String digits\n            |> function\n               | \"\" -> str, None\n               | index -> str.Substring (0, str.Length - index.Length), Some (int index)\n\n\n    let (|StartsWith|_|) pattern value =\n        if String.IsNullOrWhiteSpace value then\n            None\n        elif value.StartsWith pattern then\n            Some()\n        else None\n\n\n\ntype ConcurrentDictionary<'key, 'value> with\n    member x.TryFind key =\n        match x.TryGetValue key with\n        | true, value -> Some value\n        | _ -> None\n\n    member x.ToSeq() =\n        x |> Seq.map (fun (KeyValue(k, v)) -> k, v)\n\ntype Path with\n    static member GetFullPathSafe path =\n        try Path.GetFullPath path\n        with _ -> path\n\n    static member GetFileNameSafe path =\n        try Path.GetFileName path\n        with _ -> path\n\n\n\nlet inline debug msg = Printf.kprintf Debug.WriteLine msg\nlet inline fail msg = Printf.kprintf Debug.Fail msg\nlet asyncMaybe = AsyncMaybeBuilder()","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"},"expanded":true},{"name":"Lexer","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\n\ntype SymbolKind =\n    | Ident\n    | Operator\n    | GenericTypeParameter\n    | StaticallyResolvedTypeParameter\n    | ActivePattern\n    | Keyword\n    | Other\n\ntype LexerSymbol =\n    { Kind: SymbolKind\n      Line: int\n      LeftColumn: int\n      RightColumn: int\n      Text: string }\n\n[<RequireQualifiedAccess>]\ntype SymbolLookupKind =\n    | Fuzzy\n    | ByRightColumn\n    | ByLongIdent\n    | Simple\n\ntype private DraftToken =\n    { Kind: SymbolKind\n      Token: FSharpTokenInfo\n      RightColumn: int }\n    static member inline Create kind token =\n        { Kind = kind; Token = token; RightColumn = token.LeftColumn + token.FullMatchedLength - 1 }\n\nmodule Lexer =\n    /// Return all tokens of current line\n    let tokenizeLine (args: string[]) lineStr =\n        let defines =\n            args |> Seq.choose (fun s -> if s.StartsWith \"--define:\" then Some s.[9..] else None)\n                 |> Seq.toList\n        let sourceTokenizer = FSharpSourceTokenizer(defines, Some \"/tmp.fsx\")\n        let lineTokenizer = sourceTokenizer.CreateLineTokenizer lineStr\n        let rec loop lexState acc =\n            match lineTokenizer.ScanToken lexState with\n            | Some tok, state -> loop state (tok :: acc)\n            | _ -> List.rev acc\n        loop 0L []\n\n    let inline private isIdentifier t = t.CharClass = FSharpTokenCharKind.Identifier\n    let inline private isOperator t = t.ColorClass = FSharpTokenColorKind.Operator\n    let inline private isKeyword t = t.ColorClass = FSharpTokenColorKind.Keyword\n\n    let inline private (|GenericTypeParameterPrefix|StaticallyResolvedTypeParameterPrefix|ActivePattern|Other|) ((token: FSharpTokenInfo), (lineStr:string)) =\n        if token.Tag = FSharpTokenTag.QUOTE then GenericTypeParameterPrefix\n        elif token.Tag = FSharpTokenTag.INFIX_AT_HAT_OP then\n             // The lexer return INFIX_AT_HAT_OP token for both \"^\" and \"@\" symbols.\n             // We have to check the char itself to distinguish one from another.\n             if token.FullMatchedLength = 1 && lineStr.[token.LeftColumn] = '^' then\n                StaticallyResolvedTypeParameterPrefix\n             else Other\n        elif token.Tag = FSharpTokenTag.LPAREN then\n            if token.FullMatchedLength = 1 && lineStr.[token.LeftColumn+1] = '|' then\n               ActivePattern\n            else Other\n        else Other\n\n    // Operators: Filter out overlapped operators (>>= operator is tokenized as three distinct tokens: GREATER, GREATER, EQUALS.\n    // Each of them has FullMatchedLength = 3. So, we take the first GREATER and skip the other two).\n    //\n    // Generic type parameters: we convert QUOTE + IDENT tokens into single IDENT token, altering its LeftColumn\n    // and FullMathedLength (for \"'type\" which is tokenized as (QUOTE, left=2) + (IDENT, left=3, length=4)\n    // we'll get (IDENT, left=2, length=5).\n    //\n    // Statically resolved type parameters: we convert INFIX_AT_HAT_OP + IDENT tokens into single IDENT token, altering its LeftColumn\n    // and FullMathedLength (for \"^type\" which is tokenized as (INFIX_AT_HAT_OP, left=2) + (IDENT, left=3, length=4)\n    // we'll get (IDENT, left=2, length=5).\n    let private fixTokens lineStr (tokens : FSharpTokenInfo list) =\n        tokens\n        |> List.fold (fun (acc, lastToken) token ->\n            match lastToken with\n            | Some t when token.LeftColumn <= t.RightColumn ->\n                acc, lastToken\n            | Some ( {Kind = SymbolKind.ActivePattern} as lastToken) when token.Tag = FSharpTokenTag.BAR || token.Tag = FSharpTokenTag.IDENT || token.Tag = FSharpTokenTag.UNDERSCORE ->\n                let mergedToken =\n                    {lastToken.Token with Tag = FSharpTokenTag.IDENT\n                                                RightColumn = token.RightColumn\n                                                FullMatchedLength = lastToken.Token.FullMatchedLength + token.FullMatchedLength }\n\n                acc, Some { lastToken with Token = mergedToken; RightColumn = lastToken.RightColumn + token.FullMatchedLength }\n            | _ ->\n                match token, lineStr with\n                | GenericTypeParameterPrefix -> acc, Some (DraftToken.Create GenericTypeParameter token)\n                | StaticallyResolvedTypeParameterPrefix -> acc, Some (DraftToken.Create StaticallyResolvedTypeParameter token)\n                | ActivePattern -> acc, Some (DraftToken.Create ActivePattern token)\n                | Other ->\n                    let draftToken =\n                        match lastToken with\n                        | Some { Kind = GenericTypeParameter | StaticallyResolvedTypeParameter as kind } when isIdentifier token ->\n                              DraftToken.Create kind { token with LeftColumn = token.LeftColumn - 1\n                                                                  FullMatchedLength = token.FullMatchedLength + 1 }\n                        | Some ( { Kind = SymbolKind.ActivePattern } as ap) when token.Tag = FSharpTokenTag.RPAREN ->\n                              DraftToken.Create SymbolKind.Ident ap.Token\n                        | _ ->\n                            let kind =\n                                if isOperator token then Operator\n                                elif isIdentifier token then Ident\n                                elif isKeyword token then Keyword\n                                else Other\n                            DraftToken.Create kind token\n                    draftToken :: acc, Some draftToken\n            ) ([], None)\n        |> fst\n\n    // Returns symbol at a given position.\n    let private getSymbolFromTokens (tokens: FSharpTokenInfo list) line col (lineStr: string) lookupKind: LexerSymbol option =\n        let tokens = fixTokens lineStr tokens\n\n        // One or two tokens that in touch with the cursor (for \"let x|(g) = ()\" the tokens will be \"x\" and \"(\")\n        let tokensUnderCursor =\n            match lookupKind with\n            | SymbolLookupKind.Simple | SymbolLookupKind.Fuzzy ->\n                tokens |> List.filter (fun x -> x.Token.LeftColumn <= col && x.RightColumn + 1 >= col)\n            | SymbolLookupKind.ByRightColumn ->\n                tokens |> List.filter (fun x -> x.RightColumn = col)\n            | SymbolLookupKind.ByLongIdent ->\n                tokens |> List.filter (fun x -> x.Token.LeftColumn <= col)\n\n        //printfn \"Filtered tokens: %+A\" tokensUnderCursor\n        match lookupKind with\n        | SymbolLookupKind.ByLongIdent ->\n            // Try to find start column of the long identifiers\n            // Assume that tokens are ordered in an decreasing order of start columns\n            let rec tryFindStartColumn tokens =\n               match tokens with\n               | {Kind = Ident; Token = t1} :: {Kind = Operator; Token = t2} :: remainingTokens ->\n                    if t2.Tag = FSharpTokenTag.DOT then\n                        tryFindStartColumn remainingTokens\n                    else\n                        Some t1.LeftColumn\n               | {Kind = Ident; Token = t} :: _ ->\n                   Some t.LeftColumn\n               | _ :: _ | [] ->\n                   None\n            let decreasingTokens =\n                match tokensUnderCursor |> List.sortBy (fun token -> - token.Token.LeftColumn) with\n                // Skip the first dot if it is the start of the identifier\n                | {Kind = Operator; Token = t} :: remainingTokens when t.Tag = FSharpTokenTag.DOT ->\n                    remainingTokens\n                | newTokens -> newTokens\n\n            match decreasingTokens with\n            | [] -> None\n            | first :: _ ->\n                tryFindStartColumn decreasingTokens\n                |> Option.map (fun leftCol ->\n                    { Kind = Ident\n                      Line = line\n                      LeftColumn = leftCol\n                      RightColumn = first.RightColumn + 1\n                      Text = lineStr.[leftCol..first.RightColumn] })\n        | SymbolLookupKind.Fuzzy\n        | SymbolLookupKind.ByRightColumn ->\n            // Select IDENT token. If failed, select OPERATOR token.\n            tokensUnderCursor\n            |> List.tryFind (fun { DraftToken.Kind = k } ->\n                match k with\n                | Ident | GenericTypeParameter | StaticallyResolvedTypeParameter | Keyword -> true\n                | _ -> false)\n                /// Gets the option if Some x, otherwise try to get another value\n\n            |> Option.orTry (fun _ -> tokensUnderCursor |> List.tryFind (fun { DraftToken.Kind = k } -> k = Operator))\n            |> Option.map (fun token ->\n                { Kind = token.Kind\n                  Line = line\n                  LeftColumn = token.Token.LeftColumn\n                  RightColumn = token.RightColumn + 1\n                  Text = lineStr.Substring(token.Token.LeftColumn, token.Token.FullMatchedLength) })\n        | SymbolLookupKind.Simple ->\n            tokensUnderCursor\n            |> List.tryLast\n            |> Option.map (fun token ->\n                { Kind = token.Kind\n                  Line = line\n                  LeftColumn = token.Token.LeftColumn\n                  RightColumn = token.RightColumn + 1\n                  Text = lineStr.Substring(token.Token.LeftColumn, token.Token.FullMatchedLength) })\n\n    let getSymbol line col lineStr lookupKind (args: string[]) =\n        let tokens = tokenizeLine args lineStr\n        try\n            getSymbolFromTokens tokens line col lineStr lookupKind\n        with _ ->\n            //LoggingService.LogInfo (sprintf \"Getting lex symbols failed with %O\" e)\n            None","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"companions":[],"id":{"$":0,"Item":"08e0d335-e0a3-48e0-af14-d57d98247feb"},"expanded":true},{"name":"Parser","content":"open System\nopen Microsoft.FSharp.Compiler\n\n// --------------------------------------------------------------------------------------\n// Simple implementation of LazyList\n// --------------------------------------------------------------------------------------\n\ntype private LazyList<'T> =\n  | Nil\n  | Cons of 'T * Lazy<LazyList<'T>>\n\nmodule private LazyList =\n  let ofSeq (s:seq<'T>) =\n    let en = s.GetEnumerator()\n    let rec take() =\n      if en.MoveNext() then\n        Cons(en.Current, lazy take())\n      else\n        en.Dispose()\n        Nil\n    take()\n\nmodule Parser =\n  open System\n\n  /// Add some useful methods for creating strings from sequences\n  type String with\n    static member OfSeq chars = chars |> Seq.toArray |> String\n    static member OfReversedSeq chars = chars |> Seq.toArray |> Array.rev |> String\n\n  /// Parser is implemented using lazy list (so that we can use seq<_>)\n  type Parser<'T> = private P of (LazyList<char> -> ('T * LazyList<char>) list)\n\n  // Basic functions needed by the computation builder\n\n  let result v = P (fun c -> [v, c])\n  let zero () = P (fun _ -> [])\n  \n  let bind (P p) f = P (fun inp ->\n    [ for (pr, inp') in p inp do\n        let (P pars) = f pr\n        yield! pars inp' ])\n  \n  let plus (P p) (P q) = P (fun inp ->\n    (p inp) @ (q inp) )\n\n  let (<|>) p1 p2 = plus p1 p2\n\n  type ParserBuilder() =\n    member __.Bind(v, f) = bind v f\n    member __.Zero() = zero()\n    member __.Return(v) = result(v)\n    member __.ReturnFrom(p) = p\n    member __.Combine(a, b) = plus a b\n    member __.Delay(f) = f()\n\n  let parser = new ParserBuilder()\n\n  // --------------------------------------------------------------------------------------\n  // Basic combinators for composing parsers\n\n  let item = P(function | LazyList.Nil -> [] | LazyList.Cons(c, r) -> [c,r.Value])\n\n  let sat p = parser {\n    let! v = item\n    if (p v) then return v }\n\n  let char x = sat ((=) x)\n  let digit = sat Char.IsDigit\n  let letter = sat Char.IsLetter\n  let whitespace = sat (Char.IsWhiteSpace)\n\n  let rec word = parser {\n    return []\n    return! parser {\n      let! x = letter\n      let! xs = word\n      return x::xs } }\n\n  let string (str:string) =\n    let chars = str.ToCharArray() |> List.ofSeq\n    let rec string' = function\n      | [] -> result []\n      | x::xs -> parser {\n          let! y = char x\n          let! ys = string' xs\n          return y::ys }\n    string' chars\n\n  let rec many p = parser {\n    return! parser {\n      let! it = p\n      let! res = many p\n      return it::res }\n    return [] }\n\n  let rec some p = parser {\n    let! first = p\n    let! rest = many p\n    return first::rest }\n\n  let rec map f p = parser {\n    let! v = p\n    return f v }\n\n  let optional p = parser {\n    return! parser { let! v = p in return Some v }\n    return None }\n\n  let apply (P p) (str:seq<char>) =\n    let res = str |> LazyList.ofSeq |> p\n    res |> List.map fst\n\n// --------------------------------------------------------------------------------------\n/// Parsing utilities for IntelliSense (e.g. parse identifier on the left-hand side\n/// of the current cursor location etc.)\nmodule Parsing =\n  open Parser\n\n  module Legacy =\n    let inline isFirstOpChar ch =\n        ch = '!' || ch = '%'|| ch = '&' || ch = '*'|| ch = '+'|| ch = '-'|| ch = '.'|| ch = '/'|| ch = '<'|| ch = '='|| ch = '>'|| ch = '@'|| ch = '^'|| ch = '|'|| ch = '~'\n  \n    let isOpChar ch = ch = '?' || isFirstOpChar ch\n\n    let parseBackSymOpFragment = parser {\n      // This is unfortunate, but otherwise cracking at $ in A.$B\n      // causes the backward parse to return a symbol fragment.\n      let! c  = sat (fun c -> c <> '.' && isOpChar c)\n      let! cs = many (sat isOpChar)\n      return String.OfReversedSeq (c::cs)\n      }\n\n    /// Parses F# short-identifier (i.e. not including '.'); also ignores active patterns\n    // let parseIdent =\n    //   parseActivePatternEnd <|> parseSymOpFragment <|> many fsharpIdentCharacter\n    //    |> map String.ofSeq\n    let fsharpIdentCharacter = sat PrettyNaming.IsIdentifierPartCharacter\n\n    let rawIdChar = sat (fun c -> c <> '\\n' && c <> '\\t' && c <> '\\r' && c <> '`')\n\n    /// Parse F# short-identifier and reverse the resulting string\n    let parseBackIdent =\n      parser {\n          let! x = optional (string \"``\")\n          let! res = many (if x.IsSome then rawIdChar else fsharpIdentCharacter) |> map String.OfReversedSeq\n          let! _ = optional (string \"``\")\n          return res }\n\n    /// Parse remainder of a long identifier before '.' (e.g. \"Name.space.\")\n    /// (designed to look backwards - reverses the results after parsing)\n    let rec parseBackLongIdentRest = parser {\n      return! parser {\n        let! _ = char '.'\n        let! ident = parseBackIdent\n        let! rest = parseBackLongIdentRest\n        return ident::rest }\n      return [] }\n\n    let parseBackLongIdent = parser {\n      return! parser {\n        let! ident = parseBackSymOpFragment <|> parseBackIdent\n        let! rest = parseBackLongIdentRest\n        return ident::rest |> List.rev }\n      return [] }\n\n    let parseBackTriggerThenLongIdent = parser {\n      let! _ = char '(' <|> char '<'\n      let! _  = many whitespace\n      return! parseBackLongIdent\n      }\n\n  /// Create sequence that reads the string backwards\n  let createBackStringReader (str:string) from = seq {\n    for i in (min from (str.Length - 1)) .. -1 .. 0 do yield str.[i] }\n\n  /// Create sequence that reads the string forwards\n  let createForwardStringReader (str:string) from = seq {\n    for i in (max 0 from) .. (str.Length - 1) do yield str.[i] }\n\n  /// Returns first result returned by the parser\n  let getFirst p s = apply p s |> List.head\n  let tryGetFirst p s = match apply p s with h::_ -> Some h | [] -> None\n\n  let inline private tryGetLexerSymbolIslands sym =\n      match sym.Text with \n      | \"\" -> None \n      | _ -> Some (sym.RightColumn, sym.Text.Split '.' |> Array.toList)\n\n  // Parsing - find the identifier around the current location\n  // (we look for full identifier in the backward direction, but only\n  // for a short identifier forward - this means that when you hover\n  // 'B' in 'A.B.C', you will get intellisense for 'A.B' module)\n  let findIdents col lineStr lookupType =\n      if lineStr = \"\" then None\n      else\n          Lexer.getSymbol 0 col lineStr lookupType [||]\n          |> Option.bind tryGetLexerSymbolIslands\n\n  let findLongIdents (col, lineStr) =\n    findIdents col lineStr SymbolLookupKind.Fuzzy\n\n  let findLongIdentsAndResidue (col, lineStr:string) =\n      let lineStr = lineStr.Substring(0, col)\n\n      match Lexer.getSymbol 0 col lineStr SymbolLookupKind.ByLongIdent [||] with\n      | Some sym ->\n          match sym.Text with\n          | \"\" -> [], \"\"\n          | text ->\n              let res = text.Split '.' |> List.ofArray |> List.rev\n              if lineStr.[col - 1] = '.' then res |> List.rev, \"\"\n              else\n                  match res with\n                  | head :: tail -> tail |> List.rev, head\n                  | [] -> [], \"\"\n      | _ -> [], \"\"\n\n  /// find the identifier prior to a '(' or ',' once the method tip trigger '(' shows\n  let findLongIdentsAtGetMethodsTrigger (col, lineStr) =\n    let lookBack = createBackStringReader lineStr col\n    let backIdentOpt = tryGetFirst Legacy.parseBackTriggerThenLongIdent lookBack\n    match backIdentOpt with\n    | None -> None\n    | Some backIdent ->\n\n    let identIsland =\n      match List.rev backIdent with\n      | last::prev -> (last::prev |> List.rev)\n      | [] -> []\n\n    match identIsland with\n    | [] | [ \"\" ] -> None\n    | _ -> Some identIsland","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"08e0d335-e0a3-48e0-af14-d57d98247feb"}],"companions":[],"id":{"$":0,"Item":"a6ffc34e-45f1-4732-a3e7-7de501ad478e"},"expanded":true},{"name":"KeywordList","content":"module internal KeywordList =\n    let private modifiers =\n        Map.ofList [\n            \"abstract\",  \"\"\"Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.\"\"\"\n            \"inline\",  \"\"\"Used to indicate a function that should be integrated directly into the caller's code.\"\"\"\n            \"mutable\",  \"\"\"Used to declare a variable, that is, a value that can be changed.\"\"\"\n            \"private\",  \"\"\"Restricts access to a member to code in the same type or module.\"\"\"\n            \"public\",  \"\"\"Allows access to a member from outside the type.\"\"\"\n        ]\n\n    let private keywordDescriptions =\n        Map.ofList [\n            \"abstract\",  \"\"\"Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.\"\"\"\n            \"and\",  \"\"\"Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.\"\"\"\n            \"as\",  \"\"\"Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.\"\"\"\n            \"assert\",  \"\"\"Used to verify code during debugging.\"\"\"\n            \"base\",  \"\"\"Used as the name of the base class object.\"\"\"\n            \"begin\",  \"\"\"In verbose syntax, indicates the start of a code block.\"\"\"\n            \"class\",  \"\"\"In verbose syntax, indicates the start of a class definition.\"\"\"\n            \"default\",  \"\"\"Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.\"\"\"\n            \"delegate\",  \"\"\"Used to declare a delegate.\"\"\"\n            \"do\",  \"\"\"Used in looping constructs or to execute imperative code.\"\"\"\n            \"done\",  \"\"\"In verbose syntax, indicates the end of a block of code in a looping expression.\"\"\"\n            \"downcast\",  \"\"\"Used to convert to a type that is lower in the inheritance chain.\"\"\"\n            \"downto\",  \"\"\"In a for expression, used when counting in reverse.\"\"\"\n            \"elif\",  \"\"\"Used in conditional branching. A short form of else if.\"\"\"\n            \"else\",  \"\"\"Used in conditional branching.\"\"\"\n            \"end\",  \"\"\"In type definitions and type extensions, indicates the end of a section of member definitions.\nIn verbose syntax, used to specify the end of a code block that starts with the begin keyword.\"\"\"\n            \"exception\",  \"\"\"Used to declare an exception type.\"\"\"\n            \"extern\",  \"\"\"Indicates that a declared program element is defined in another binary or assembly.\"\"\"\n            \"false\",  \"\"\"Used as a Boolean literal.\"\"\"\n            \"finally\",  \"\"\"Used together with try to introduce a block of code that executes regardless of whether an exception occurs.\"\"\"\n            \"for\",  \"\"\"Used in looping constructs.\"\"\"\n            \"fun\",  \"\"\"Used in lambda expressions, also known as anonymous functions.\"\"\"\n            \"function\",  \"\"\"Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.\"\"\"\n            \"global\",  \"\"\"Used to reference the top-level .NET namespace.\"\"\"\n            \"if\",  \"\"\"Used in conditional branching constructs.\"\"\"\n            \"in\",  \"\"\"Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.\"\"\"\n            \"inherit\",  \"\"\"Used to specify a base class or base interface.\"\"\"\n            \"inline\",  \"\"\"Used to indicate a function that should be integrated directly into the caller's code.\"\"\"\n            \"interface\",  \"\"\"Used to declare and implement interfaces.\"\"\"\n            \"internal\",  \"\"\"Used to specify that a member is visible inside an assembly but not outside it.\"\"\"\n            \"lazy\",  \"\"\"Used to specify a computation that is to be performed only when a result is needed.\"\"\"\n            \"let\",  \"\"\"Used to associate, or bind, a name to a value or function.\"\"\"\n            \"let!\",  \"\"\"Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.\"\"\"\n            \"match\",  \"\"\"Used to branch by comparing a value to a pattern.\"\"\"\n            \"member\",  \"\"\"Used to declare a property or method in an object type.\"\"\"\n            \"module\",  \"\"\"Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.\"\"\"\n            \"mutable\",  \"\"\"Used to declare a variable, that is, a value that can be changed.\"\"\"\n            \"namespace\",  \"\"\"Used to associate a name with a group of related types and modules, to logically separate it from other code.\"\"\"\n            \"new\",  \"\"\"Used to declare, define, or invoke a constructor that creates or that can create an object.\nAlso used in generic parameter constraints to indicate that a type must have a certain constructor.\"\"\"\n            \"not\",  \"\"\"Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.\"\"\"\n            \"null\",  \"\"\"Indicates the absence of an object.\nAlso used in generic parameter constraints.\"\"\"\n            \"of\",  \"\"\"Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.\"\"\"\n            \"open\",  \"\"\"Used to make the contents of a namespace or module available without qualification.\"\"\"\n            \"or\",  \"\"\"Used with Boolean conditions as a Boolean or operator. Equivalent to ||.\nAlso used in member constraints.\"\"\"\n            \"override\",  \"\"\"Used to implement a version of an abstract or virtual method that differs from the base version.\"\"\"\n            \"private\",  \"\"\"Restricts access to a member to code in the same type or module.\"\"\"\n            \"public\",  \"\"\"Allows access to a member from outside the type.\"\"\"\n            \"rec\",  \"\"\"Used to indicate that a function is recursive.\"\"\"\n            \"return\",  \"\"\"Used to indicate a value to provide as the result of a computation expression.\"\"\"\n            \"return!\",  \"\"\"Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.\"\"\"\n            \"select\",  \"\"\"Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.\"\"\"\n            \"static\",  \"\"\"Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.\"\"\"\n            \"struct\",  \"\"\"Used to declare a structure type.\nAlso used in generic parameter constraints.\nUsed for OCaml compatibility in module definitions.\"\"\"\n            \"then\",  \"\"\"Used in conditional expressions.\nAlso used to perform side effects after object construction.\"\"\"\n            \"to\",  \"\"\"Used in for loops to indicate a range.\"\"\"\n            \"true\",  \"\"\"Used as a Boolean literal.\"\"\"\n            \"try\",  \"\"\"Used to introduce a block of code that might generate an exception. Used together with with or finally.\"\"\"\n            \"type\",  \"\"\"Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.\"\"\"\n            \"upcast\",  \"\"\"Used to convert to a type that is higher in the inheritance chain.\"\"\"\n            \"use\",  \"\"\"Used instead of let for values that require Dispose to be called to free resources.\"\"\"\n            \"use!\",  \"\"\"Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.\"\"\"\n            \"val\",  \"\"\"Used in a signature to indicate a value, or in a type to declare a member, in limited situations.\"\"\"\n            \"void\",  \"\"\"Indicates the .NET void type. Used when interoperating with other .NET languages.\"\"\"\n            \"when\",  \"\"\"Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.\"\"\"\n            \"while\",  \"\"\"Introduces a looping construct.\"\"\"\n            \"with\",  \"\"\"Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.\"\"\"\n            \"yield\",  \"\"\"Used in a sequence expression to produce a value for a sequence.\"\"\"\n            \"yield!\",  \"\"\"Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.\"\"\"\n            \"->\", \"\"\"In function types, delimits arguments and return values.\nYields an expression (in sequence expressions); equivalent to the yield keyword.\nUsed in match expressions\"\"\"\n            \"<-\", \"Assigns a value to a variable.\"\n            \":>\", \"Converts a type to type that is higher in the hierarchy.\"\n            \":?>\", \"Converts a type to a type that is lower in the hierarchy.\"\n            \"<@\", \"Delimits a typed code quotation.\"\n            \"@>\", \"Delimits a typed code quotation.\"\n            \"<@@\", \"Delimits a untyped code quotation.\"\n            \"@@>\", \"Delimits a untyped code quotation.\"]\n\n    let tryGetKeywordDescription (keyword: string) =\n        keywordDescriptions |> Map.tryFind keyword\n        |> Option.orElseFun (fun _ -> modifiers |> Map.tryFind keyword)\n\n    let allKeywords : string list =\n        [ yield! modifiers |> Map.toSeq |> Seq.map fst\n          yield! keywordDescriptions |> Map.toSeq |> Seq.map fst ]","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"205b5e59-899b-4351-ab75-788ff73f20e7"},"expanded":true},{"name":"UntypedAstUtils","content":"open Microsoft.FSharp.Compiler.Ast\nopen System.Collections.Generic\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.Range\n\ntype Range.range with\n    member inline x.IsEmpty = x.StartColumn = x.EndColumn && x.StartLine = x.EndLine\n\ntype internal ShortIdent = string\ntype internal Idents = ShortIdent[]\n\nlet internal longIdentToArray (longIdent: LongIdent): Idents =\n    longIdent |> Seq.map string |> Seq.toArray\n\n    /// An recursive pattern that collect all sequential expressions to avoid StackOverflowException\nlet rec (|Sequentials|_|) = function\n    | SynExpr.Sequential(_, _, e, Sequentials es, _) ->\n        Some(e::es)\n    | SynExpr.Sequential(_, _, e1, e2, _) ->\n        Some [e1; e2]\n    | _ -> None\n\nlet (|ConstructorPats|) = function\n    | SynConstructorArgs.Pats ps -> ps\n    | SynConstructorArgs.NamePatPairs(xs, _) -> List.map snd xs\n\n/// Returns all Idents and LongIdents found in an untyped AST.\nlet internal getLongIdents (input: ParsedInput option) : IDictionary<Range.pos, Idents> =\n    let identsByEndPos = Dictionary<Range.pos, Idents>()\n\n    let addLongIdent (longIdent: LongIdent) =\n        let idents = longIdentToArray longIdent\n        for ident in longIdent do\n            identsByEndPos.[ident.idRange.End] <- idents\n\n    let addLongIdentWithDots (LongIdentWithDots (longIdent, lids) as value) =\n        match longIdentToArray longIdent with\n        | [||] -> ()\n        | [|_|] as idents -> identsByEndPos.[value.Range.End] <- idents\n        | idents ->\n            for dotRange in lids do\n                identsByEndPos.[Range.mkPos dotRange.EndLine (dotRange.EndColumn - 1)] <- idents\n            identsByEndPos.[value.Range.End] <- idents\n\n    let addIdent (ident: Ident) =\n        identsByEndPos.[ident.idRange.End] <- [|ident.idText|]\n\n    let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n        List.iter walkSynModuleOrNamespace moduleOrNamespaceList\n\n    and walkSynModuleOrNamespace (SynModuleOrNamespace(_, _, _, decls, _, attrs, _, _)) =\n        List.iter walkAttribute attrs\n        List.iter walkSynModuleDecl decls\n\n    and walkAttribute (attr: SynAttribute) =\n        addLongIdentWithDots attr.TypeName\n        walkExpr attr.ArgExpr\n\n    and walkTyparDecl (SynTyparDecl.TyparDecl (attrs, typar)) =\n        List.iter walkAttribute attrs\n        walkTypar typar\n\n    and walkTypeConstraint = function\n        | SynTypeConstraint.WhereTyparIsValueType (t, _)\n        | SynTypeConstraint.WhereTyparIsReferenceType (t, _)\n        | SynTypeConstraint.WhereTyparIsUnmanaged (t, _)\n        | SynTypeConstraint.WhereTyparSupportsNull (t, _)\n        | SynTypeConstraint.WhereTyparIsComparable (t, _)\n        | SynTypeConstraint.WhereTyparIsEquatable (t, _) -> walkTypar t\n        | SynTypeConstraint.WhereTyparDefaultsToType (t, ty, _)\n        | SynTypeConstraint.WhereTyparSubtypeOfType (t, ty, _) -> walkTypar t; walkType ty\n        | SynTypeConstraint.WhereTyparIsEnum (t, ts, _)\n        | SynTypeConstraint.WhereTyparIsDelegate (t, ts, _) -> walkTypar t; List.iter walkType ts\n        | SynTypeConstraint.WhereTyparSupportsMember (ts, sign, _) -> List.iter walkType ts; walkMemberSig sign\n\n    and walkPat = function\n        | SynPat.Tuple (pats, _)\n        | SynPat.ArrayOrList (_, pats, _)\n        | SynPat.Ands (pats, _) -> List.iter walkPat pats\n        | SynPat.Named (pat, ident, _, _, _) ->\n            walkPat pat\n            addIdent ident\n        | SynPat.Typed (pat, t, _) ->\n            walkPat pat\n            walkType t\n        | SynPat.Attrib (pat, attrs, _) ->\n            walkPat pat\n            List.iter walkAttribute attrs\n        | SynPat.Or (pat1, pat2, _) -> List.iter walkPat [pat1; pat2]\n        | SynPat.LongIdent (ident, _, typars, ConstructorPats pats, _, _) ->\n            addLongIdentWithDots ident\n            typars\n            |> Option.iter (fun (SynValTyparDecls (typars, _, constraints)) ->\n                 List.iter walkTyparDecl typars\n                 List.iter walkTypeConstraint constraints)\n            List.iter walkPat pats\n        | SynPat.Paren (pat, _) -> walkPat pat\n        | SynPat.IsInst (t, _) -> walkType t\n        | SynPat.QuoteExpr(e, _) -> walkExpr e\n        | _ -> ()\n\n    and walkTypar (Typar (_, _, _)) = ()\n\n    and walkBinding (SynBinding.Binding (_, _, _, _, attrs, _, _, pat, returnInfo, e, _, _)) =\n        List.iter walkAttribute attrs\n        walkPat pat\n        walkExpr e\n        returnInfo |> Option.iter (fun (SynBindingReturnInfo (t, _, _)) -> walkType t)\n\n    and walkInterfaceImpl (InterfaceImpl(_, bindings, _)) = List.iter walkBinding bindings\n\n    and walkIndexerArg = function\n        | SynIndexerArg.One e -> walkExpr e\n        | SynIndexerArg.Two (e1, e2) -> List.iter walkExpr [e1; e2]\n\n    and walkType = function\n        | SynType.Array (_, t, _)\n        | SynType.HashConstraint (t, _)\n        | SynType.MeasurePower (t, _, _) -> walkType t\n        | SynType.Fun (t1, t2, _)\n        | SynType.MeasureDivide (t1, t2, _) -> walkType t1; walkType t2\n        | SynType.LongIdent ident -> addLongIdentWithDots ident\n        | SynType.App (ty, _, types, _, _, _, _) -> walkType ty; List.iter walkType types\n        | SynType.LongIdentApp (_, _, _, types, _, _, _) -> List.iter walkType types\n        | SynType.Tuple (ts, _) -> ts |> List.iter (fun (_, t) -> walkType t)\n        | SynType.WithGlobalConstraints (t, typeConstraints, _) ->\n            walkType t; List.iter walkTypeConstraint typeConstraints\n        | _ -> ()\n\n    and walkClause (Clause (pat, e1, e2, _, _)) =\n        walkPat pat\n        walkExpr e2\n        e1 |> Option.iter walkExpr\n\n    and walkSimplePats = function\n        | SynSimplePats.SimplePats (pats, _) -> List.iter walkSimplePat pats\n        | SynSimplePats.Typed (pats, ty, _) ->\n            walkSimplePats pats\n            walkType ty\n\n    and walkExpr = function\n        | SynExpr.Paren (e, _, _, _)\n        | SynExpr.Quote (_, _, e, _, _)\n        | SynExpr.Typed (e, _, _)\n        | SynExpr.InferredUpcast (e, _)\n        | SynExpr.InferredDowncast (e, _)\n        | SynExpr.AddressOf (_, e, _, _)\n        | SynExpr.DoBang (e, _)\n        | SynExpr.YieldOrReturn (_, e, _)\n        | SynExpr.ArrayOrListOfSeqExpr (_, e, _)\n        | SynExpr.CompExpr (_, _, e, _)\n        | SynExpr.Do (e, _)\n        | SynExpr.Assert (e, _)\n        | SynExpr.Lazy (e, _)\n        | SynExpr.YieldOrReturnFrom (_, e, _) -> walkExpr e\n        | SynExpr.Lambda (_, _, pats, e, _) ->\n            walkSimplePats pats\n            walkExpr e\n        | SynExpr.New (_, t, e, _)\n        | SynExpr.TypeTest (e, t, _)\n        | SynExpr.Upcast (e, t, _)\n        | SynExpr.Downcast (e, t, _) -> walkExpr e; walkType t\n        | SynExpr.Tuple (es, _, _)\n        | Sequentials es\n        | SynExpr.ArrayOrList (_, es, _) -> List.iter walkExpr es\n        | SynExpr.App (_, _, e1, e2, _)\n        | SynExpr.TryFinally (e1, e2, _, _, _)\n        | SynExpr.While (_, e1, e2, _) -> List.iter walkExpr [e1; e2]\n        | SynExpr.Record (_, _, fields, _) ->\n            fields |> List.iter (fun ((ident, _), e, _) ->\n                        addLongIdentWithDots ident\n                        e |> Option.iter walkExpr)\n        | SynExpr.Ident ident -> addIdent ident\n        | SynExpr.ObjExpr(ty, argOpt, bindings, ifaces, _, _) ->\n            argOpt |> Option.iter (fun (e, ident) ->\n                walkExpr e\n                ident |> Option.iter addIdent)\n            walkType ty\n            List.iter walkBinding bindings\n            List.iter walkInterfaceImpl ifaces\n        | SynExpr.LongIdent (_, ident, _, _) -> addLongIdentWithDots ident\n        | SynExpr.For (_, ident, e1, _, e2, e3, _) ->\n            addIdent ident\n            List.iter walkExpr [e1; e2; e3]\n        | SynExpr.ForEach (_, _, _, pat, e1, e2, _) ->\n            walkPat pat\n            List.iter walkExpr [e1; e2]\n        | SynExpr.MatchLambda (_, _, synMatchClauseList, _, _) ->\n            List.iter walkClause synMatchClauseList\n        | SynExpr.Match (_, e, synMatchClauseList, _, _) ->\n            walkExpr e\n            List.iter walkClause synMatchClauseList\n        | SynExpr.TypeApp (e, _, tys, _, _, _, _) ->\n            List.iter walkType tys; walkExpr e\n        | SynExpr.LetOrUse (_, _, bindings, e, _) ->\n            List.iter walkBinding bindings; walkExpr e\n        | SynExpr.TryWith (e, _, clauses, _, _, _, _) ->\n            List.iter walkClause clauses;  walkExpr e\n        | SynExpr.IfThenElse (e1, e2, e3, _, _, _, _) ->\n            List.iter walkExpr [e1; e2]\n            e3 |> Option.iter walkExpr\n        | SynExpr.LongIdentSet (ident, e, _)\n        | SynExpr.DotGet (e, _, ident, _) ->\n            addLongIdentWithDots ident\n            walkExpr e\n        | SynExpr.DotSet (e1, idents, e2, _) ->\n            walkExpr e1\n            addLongIdentWithDots idents\n            walkExpr e2\n        | SynExpr.DotIndexedGet (e, args, _, _) ->\n            walkExpr e\n            List.iter walkIndexerArg args\n        | SynExpr.DotIndexedSet (e1, args, e2, _, _, _) ->\n            walkExpr e1\n            List.iter walkIndexerArg args\n            walkExpr e2\n        | SynExpr.NamedIndexedPropertySet (ident, e1, e2, _) ->\n            addLongIdentWithDots ident\n            List.iter walkExpr [e1; e2]\n        | SynExpr.DotNamedIndexedPropertySet (e1, ident, e2, e3, _) ->\n            addLongIdentWithDots ident\n            List.iter walkExpr [e1; e2; e3]\n        | SynExpr.JoinIn (e1, _, e2, _) -> List.iter walkExpr [e1; e2]\n        | SynExpr.LetOrUseBang (_, _, _, pat, e1, e2, _) ->\n            walkPat pat\n            List.iter walkExpr [e1; e2]\n        | SynExpr.TraitCall (ts, sign, e, _) ->\n            List.iter walkTypar ts\n            walkMemberSig sign\n            walkExpr e\n        | SynExpr.Const (SynConst.Measure(_, m), _) -> walkMeasure m\n        | _ -> ()\n\n    and walkMeasure = function\n        | SynMeasure.Product (m1, m2, _)\n        | SynMeasure.Divide (m1, m2, _) -> walkMeasure m1; walkMeasure m2\n        | SynMeasure.Named (longIdent, _) -> addLongIdent longIdent\n        | SynMeasure.Seq (ms, _) -> List.iter walkMeasure ms\n        | SynMeasure.Power (m, _, _) -> walkMeasure m\n        | SynMeasure.Var (ty, _) -> walkTypar ty\n        | SynMeasure.One\n        | SynMeasure.Anon _ -> ()\n\n    and walkSimplePat = function\n        | SynSimplePat.Attrib (pat, attrs, _) ->\n            walkSimplePat pat\n            List.iter walkAttribute attrs\n        | SynSimplePat.Typed(pat, t, _) ->\n            walkSimplePat pat\n            walkType t\n        | _ -> ()\n\n    and walkField (SynField.Field(attrs, _, _, t, _, _, _, _)) =\n        List.iter walkAttribute attrs\n        walkType t\n\n    and walkValSig (SynValSig.ValSpfn(attrs, _, _, t, SynValInfo(argInfos, argInfo), _, _, _, _, _, _)) =\n        List.iter walkAttribute attrs\n        walkType t\n        argInfo :: (argInfos |> List.concat)\n        |> List.map (fun (SynArgInfo(attrs, _, _)) -> attrs)\n        |> List.concat\n        |> List.iter walkAttribute\n\n    and walkMemberSig = function\n        | SynMemberSig.Inherit (t, _)\n        | SynMemberSig.Interface(t, _) -> walkType t\n        | SynMemberSig.Member(vs, _, _) -> walkValSig vs\n        | SynMemberSig.ValField(f, _) -> walkField f\n        | SynMemberSig.NestedType(SynTypeDefnSig.TypeDefnSig (info, repr, memberSigs, _), _) ->\n            let isTypeExtensionOrAlias =\n                match repr with\n                | SynTypeDefnSigRepr.Simple(SynTypeDefnSimpleRepr.TypeAbbrev _, _)\n                | SynTypeDefnSigRepr.ObjectModel(SynTypeDefnKind.TyconAbbrev, _, _)\n                | SynTypeDefnSigRepr.ObjectModel(SynTypeDefnKind.TyconAugmentation, _, _) -> true\n                | _ -> false\n            walkComponentInfo isTypeExtensionOrAlias info\n            walkTypeDefnSigRepr repr\n            List.iter walkMemberSig memberSigs\n\n    and walkMember = function\n        | SynMemberDefn.AbstractSlot (valSig, _, _) -> walkValSig valSig\n        | SynMemberDefn.Member (binding, _) -> walkBinding binding\n        | SynMemberDefn.ImplicitCtor (_, attrs, pats, _, _) ->\n            List.iter walkAttribute attrs\n            List.iter walkSimplePat pats\n        | SynMemberDefn.ImplicitInherit (t, e, _, _) -> walkType t; walkExpr e\n        | SynMemberDefn.LetBindings (bindings, _, _, _) -> List.iter walkBinding bindings\n        | SynMemberDefn.Interface (t, members, _) ->\n            walkType t\n            members |> Option.iter (List.iter walkMember)\n        | SynMemberDefn.Inherit (t, _, _) -> walkType t\n        | SynMemberDefn.ValField (field, _) -> walkField field\n        | SynMemberDefn.NestedType (tdef, _, _) -> walkTypeDefn tdef\n        | SynMemberDefn.AutoProperty (attrs, _, _, t, _, _, _, _, e, _, _) ->\n            List.iter walkAttribute attrs\n            Option.iter walkType t\n            walkExpr e\n        | _ -> ()\n\n    and walkEnumCase (EnumCase(attrs, _, _, _, _)) = List.iter walkAttribute attrs\n\n    and walkUnionCaseType = function\n        | SynUnionCaseType.UnionCaseFields fields -> List.iter walkField fields\n        | SynUnionCaseType.UnionCaseFullType (t, _) -> walkType t\n\n    and walkUnionCase (SynUnionCase.UnionCase (attrs, _, t, _, _, _)) =\n        List.iter walkAttribute attrs\n        walkUnionCaseType t\n\n    and walkTypeDefnSimple = function\n        | SynTypeDefnSimpleRepr.Enum (cases, _) -> List.iter walkEnumCase cases\n        | SynTypeDefnSimpleRepr.Union (_, cases, _) -> List.iter walkUnionCase cases\n        | SynTypeDefnSimpleRepr.Record (_, fields, _) -> List.iter walkField fields\n        | SynTypeDefnSimpleRepr.TypeAbbrev (_, t, _) -> walkType t\n        | _ -> ()\n\n    and walkComponentInfo isTypeExtensionOrAlias (ComponentInfo(attrs, typars, constraints, longIdent, _, _, _, _)) =\n        List.iter walkAttribute attrs\n        List.iter walkTyparDecl typars\n        List.iter walkTypeConstraint constraints\n        if isTypeExtensionOrAlias then\n            addLongIdent longIdent\n\n    and walkTypeDefnRepr = function\n        | SynTypeDefnRepr.ObjectModel (_, defns, _) -> List.iter walkMember defns\n        | SynTypeDefnRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n        | SynTypeDefnRepr.Exception _ -> ()\n\n    and walkTypeDefnSigRepr = function\n        | SynTypeDefnSigRepr.ObjectModel (_, defns, _) -> List.iter walkMemberSig defns\n        | SynTypeDefnSigRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n        | SynTypeDefnSigRepr.Exception _ -> ()\n\n    and walkTypeDefn (TypeDefn (info, repr, members, _)) =\n        let isTypeExtensionOrAlias =\n            match repr with\n            | SynTypeDefnRepr.ObjectModel (SynTypeDefnKind.TyconAugmentation, _, _)\n            | SynTypeDefnRepr.ObjectModel (SynTypeDefnKind.TyconAbbrev, _, _)\n            | SynTypeDefnRepr.Simple (SynTypeDefnSimpleRepr.TypeAbbrev _, _) -> true\n            | _ -> false\n        walkComponentInfo isTypeExtensionOrAlias info\n        walkTypeDefnRepr repr\n        List.iter walkMember members\n\n    and walkSynModuleDecl (decl: SynModuleDecl) =\n        match decl with\n        | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace fragment\n        | SynModuleDecl.NestedModule (info, _, modules, _, _) ->\n            walkComponentInfo false info\n            List.iter walkSynModuleDecl modules\n        | SynModuleDecl.Let (_, bindings, _) -> List.iter walkBinding bindings\n        | SynModuleDecl.DoExpr (_, expr, _) -> walkExpr expr\n        | SynModuleDecl.Types (types, _) -> List.iter walkTypeDefn types\n        | SynModuleDecl.Attributes (attrs, _) -> List.iter walkAttribute attrs\n        | _ -> ()\n\n    match input with\n    | Some (ParsedInput.ImplFile input) ->\n         walkImplFileInput input\n    | _ -> ()\n    //debug \"%A\" idents\n    identsByEndPos :> _\n\nlet getLongIdentAt ast pos =\n    let idents = getLongIdents (Some ast)\n    match idents.TryGetValue pos with\n    | true, idents -> Some idents\n    | _ -> None\n\n/// Returns ranges of all quotations found in an untyped AST\nlet getQuotationRanges ast =\n    let quotationRanges = ResizeArray()\n\n    let rec visitExpr = function\n        | SynExpr.LongIdentSet (_, expr, _)\n        | SynExpr.Typed (expr, _, _)\n        | SynExpr.Paren (expr, _, _, _)\n        | SynExpr.New (_, _, expr, _)\n        | SynExpr.ArrayOrListOfSeqExpr (_, expr, _)\n        | SynExpr.CompExpr (_, _, expr, _)\n        | SynExpr.ForEach (_, _, _, _, _, expr(*body*), _)\n        | SynExpr.YieldOrReturn (_, expr, _)\n        | SynExpr.YieldOrReturnFrom (_, expr, _)\n        | SynExpr.Do (expr, _)\n        | SynExpr.DoBang (expr, _)\n        | SynExpr.Downcast (expr, _, _)\n        | SynExpr.For (_, _, _, _, _, expr, _)\n        | SynExpr.Lazy (expr, _)\n        | SynExpr.Assert (expr, _)\n        | SynExpr.TypeApp (expr, _, _, _, _, _, _)\n        | SynExpr.DotSet (_, _, expr, _)\n        | SynExpr.DotIndexedSet (_, _, expr, _, _, _)\n        | SynExpr.NamedIndexedPropertySet (_, _, expr, _)\n        | SynExpr.DotNamedIndexedPropertySet (_, _, _, expr, _)\n        | SynExpr.TypeTest (expr, _, _)\n        | SynExpr.Upcast (expr, _, _)\n        | SynExpr.InferredUpcast (expr, _)\n        | SynExpr.InferredDowncast (expr, _)\n        | SynExpr.Lambda (_, _, _, expr, _)\n        | SynExpr.AddressOf (_, expr, _, _) ->\n            visitExpr expr\n        | SynExpr.App (_,_, expr1(*funcExpr*),expr2(*argExpr*), _)\n        | SynExpr.LetOrUseBang (_, _, _, _,expr1(*rhsExpr*),expr2(*body*), _)\n        | SynExpr.TryFinally (expr1, expr2, _, _, _)\n        | SynExpr.While (_, expr1, expr2, _) ->\n            visitExpr expr1; visitExpr expr2\n        | SynExpr.Tuple (exprs, _, _)\n        | SynExpr.ArrayOrList (_, exprs, _)\n        | Sequentials  exprs ->\n            List.iter visitExpr exprs\n        | SynExpr.TryWith (expr, _, clauses, _, _, _, _)\n        | SynExpr.Match (_, expr, clauses, _, _) ->\n            visitExpr expr; visitMatches clauses\n        | SynExpr.IfThenElse (cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n            visitExpr cond; visitExpr trueBranch\n            falseBranchOpt |> Option.iter visitExpr\n        | SynExpr.LetOrUse (_, _, bindings, body, _) -> visitBindindgs bindings; visitExpr body\n        | SynExpr.Quote (_, _isRaw, _quotedExpr, _, range) -> quotationRanges.Add range\n        | SynExpr.MatchLambda (_, _, clauses, _, _) -> visitMatches clauses\n        | SynExpr.ObjExpr (_, _, bindings, _, _ , _) -> visitBindindgs bindings\n        | SynExpr.Record (_, _, fields, _) ->\n            fields |> List.choose (fun (_, expr, _) -> expr) |> List.iter visitExpr\n        | _ -> ()\n\n    and visitBinding (Binding(_, _, _, _, _, _, _, _, _, body, _, _)) = visitExpr body\n    and visitBindindgs = List.iter visitBinding\n\n    and visitPattern = function\n        | SynPat.QuoteExpr (expr, _) -> visitExpr expr\n        | SynPat.Named (pat, _, _, _, _)\n        | SynPat.Paren (pat, _)\n        | SynPat.Typed (pat, _, _) -> visitPattern pat\n        | SynPat.Ands (pats, _)\n        | SynPat.Tuple (pats, _)\n        | SynPat.ArrayOrList (_, pats, _) -> List.iter visitPattern pats\n        | SynPat.Or (pat1, pat2, _) -> visitPattern pat1; visitPattern pat2\n        | SynPat.LongIdent (_, _, _, ctorArgs, _, _) ->\n            match ctorArgs with\n            | SynConstructorArgs.Pats pats -> List.iter visitPattern pats\n            | SynConstructorArgs.NamePatPairs(xs, _) ->\n                xs |> List.map snd |> List.iter visitPattern\n        | SynPat.Record(xs, _) -> xs |> List.map snd |> List.iter visitPattern\n        | _ -> ()\n\n    and visitMatch (SynMatchClause.Clause (pat, _, expr, _, _)) = visitPattern pat; visitExpr expr\n\n    and visitMatches = List.iter visitMatch\n\n    let visitMember = function\n        | SynMemberDefn.LetBindings (bindings, _, _, _) -> visitBindindgs bindings\n        | SynMemberDefn.Member (binding, _) -> visitBinding binding\n        | SynMemberDefn.AutoProperty (_, _, _, _, _, _, _, _, expr, _, _) -> visitExpr expr\n        | _ -> ()\n\n    let visitType ty =\n        let (SynTypeDefn.TypeDefn (_, repr, defns, _)) = ty\n        match repr with\n        | SynTypeDefnRepr.ObjectModel (_, objDefns, _) ->\n            for d in objDefns do visitMember d\n        | _ -> ()\n        for d in defns do visitMember d\n\n    let rec visitDeclarations decls =\n        decls |> List.iter\n           (function\n            | SynModuleDecl.Let (_, bindings, _) -> visitBindindgs bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> visitExpr expr\n            | SynModuleDecl.Types (types, _) -> List.iter visitType types\n            | SynModuleDecl.NestedModule (_, _, decls, _, _) -> visitDeclarations decls\n            | _ -> () )\n\n    let visitModulesAndNamespaces modulesOrNss =\n        modulesOrNss\n        |> Seq.iter (fun (SynModuleOrNamespace(_, _, _, decls, _, _, _, _)) -> visitDeclarations decls)\n    ast\n    |> Option.iter (function\n        | ParsedInput.ImplFile (ParsedImplFileInput(_, _, _, _, _, modules, _)) -> visitModulesAndNamespaces modules\n        | _ -> ())\n    quotationRanges\n\n/// Returns all string literal ranges\nlet internal getStringLiterals ast : Range.range list =\n    let result = ResizeArray()\n\n    let visitType ty =\n        match ty with\n        | SynType.StaticConstant (SynConst.String(_, r), _) -> result.Add r\n        | _ -> ()\n\n    let rec visitExpr = function\n        | SynExpr.ArrayOrListOfSeqExpr (_, expr, _)\n        | SynExpr.CompExpr (_, _, expr, _)\n        | SynExpr.Lambda (_, _, _, expr, _)\n        | SynExpr.YieldOrReturn (_, expr, _)\n        | SynExpr.YieldOrReturnFrom (_, expr, _)\n        | SynExpr.New (_, _, expr, _)\n        | SynExpr.Assert (expr, _)\n        | SynExpr.Do (expr, _)\n        | SynExpr.Typed (expr, _, _)\n        | SynExpr.Paren (expr, _, _, _)\n        | SynExpr.DoBang (expr, _)\n        | SynExpr.Downcast (expr, _, _)\n        | SynExpr.For (_, _, _, _, _, expr, _)\n        | SynExpr.Lazy (expr, _)\n        | SynExpr.TypeTest(expr, _, _)\n        | SynExpr.Upcast(expr, _, _)\n        | SynExpr.InferredUpcast(expr, _)\n        | SynExpr.InferredDowncast(expr, _)\n        | SynExpr.LongIdentSet (_, expr, _)\n        | SynExpr.DotGet (expr, _, _, _)\n        | SynExpr.ForEach (_, _, _, _, _,expr(*body*), _) -> visitExpr expr\n        | SynExpr.App (_,_, expr1(*funcExpr*), expr2(*argExpr*), _)\n        | SynExpr.TryFinally (expr1, expr2, _, _, _)\n        | SynExpr.NamedIndexedPropertySet (_, expr1, expr2, _)\n        | SynExpr.DotNamedIndexedPropertySet (_, _, expr1, expr2, _)\n        | SynExpr.LetOrUseBang (_, _, _, _,expr1(*rhsExpr*), expr2(*body*), _)\n        | SynExpr.While (_, expr1, expr2, _) ->\n            visitExpr expr1; visitExpr expr2\n        | Sequentials exprs\n        | SynExpr.Tuple (exprs, _, _)\n        | SynExpr.ArrayOrList(_, exprs, _) -> List.iter visitExpr exprs\n        | SynExpr.Match (_, expr, clauses, _, _)\n        | SynExpr.TryWith(expr, _, clauses, _, _, _, _) ->\n            visitExpr expr; visitMatches clauses\n        | SynExpr.IfThenElse(cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n            visitExpr cond\n            visitExpr trueBranch\n            falseBranchOpt |> Option.iter visitExpr\n        | SynExpr.LetOrUse (_, _, bindings, body, _) ->\n            visitBindindgs bindings\n            visitExpr body\n        | SynExpr.Record (_, _, fields, _) ->\n            fields |> List.choose (fun (_, expr, _) -> expr) |> List.iter visitExpr\n        | SynExpr.MatchLambda (_, _, clauses, _, _) -> visitMatches clauses\n        | SynExpr.ObjExpr (_, _, bindings, _, _ , _) -> visitBindindgs bindings\n        | SynExpr.Const (SynConst.String (_, r), _) -> result.Add r\n        | SynExpr.TypeApp(_, _, tys, _, _, _, _) -> List.iter visitType tys\n        | _ -> ()\n\n    and visitBinding (Binding(_, _, _, _, _, _, _, _, _, body, _, _)) = visitExpr body\n    and visitBindindgs = List.iter visitBinding\n    and visitMatch (SynMatchClause.Clause (_, _, expr, _, _)) = visitExpr expr\n    and visitMatches = List.iter visitMatch\n\n    let visitMember = function\n        | SynMemberDefn.LetBindings (bindings, _, _, _) -> visitBindindgs bindings\n        | SynMemberDefn.Member (binding, _) -> visitBinding binding\n        | SynMemberDefn.AutoProperty (_, _, _, _, _, _, _, _, expr, _, _) -> visitExpr expr\n        | _ -> ()\n\n    let visitTypeDefn ty =\n        let (SynTypeDefn.TypeDefn (_, repr, memberDefns, _)) = ty\n        match repr with\n        | SynTypeDefnRepr.ObjectModel (_, defns, _) ->\n            for d in defns do visitMember d\n        | SynTypeDefnRepr.Simple(SynTypeDefnSimpleRepr.TypeAbbrev(_, SynType.App(_, _, tys, _,_ , _, _), _), _) ->\n            List.iter visitType tys\n        | _ -> ()\n        List.iter visitMember memberDefns\n\n    let rec visitDeclarations decls =\n        for declaration in decls do\n            match declaration with\n            | SynModuleDecl.Let (_, bindings, _) -> visitBindindgs bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> visitExpr expr\n            | SynModuleDecl.Types (types, _) -> for ty in types do visitTypeDefn ty\n            | SynModuleDecl.NestedModule (_, _, decls, _, _) -> visitDeclarations decls\n            | _ -> ()\n\n    let visitModulesAndNamespaces modulesOrNss =\n        Seq.iter (fun (SynModuleOrNamespace(_, _, _, decls, _, _, _, _)) -> visitDeclarations decls) modulesOrNss\n\n    ast\n    |> Option.iter (function\n        | ParsedInput.ImplFile (ParsedImplFileInput(_, _, _, _, _, modules, _)) -> visitModulesAndNamespaces modules\n        | _ -> ())\n\n    List.ofSeq result\n\n/// Get path to containing module/namespace of a given position\nlet getModuleOrNamespacePath (pos: pos) (ast: ParsedInput) =\n    let idents =\n        match ast with\n        | ParsedInput.ImplFile (ParsedImplFileInput(_, _, _, _, _, modules, _)) ->\n            let rec walkModuleOrNamespace idents (decls, moduleRange) =\n                decls\n                |> List.fold (fun acc ->\n                    function\n                    | SynModuleDecl.NestedModule (componentInfo, _, nestedModuleDecls, _, nestedModuleRange) ->\n                        if rangeContainsPos moduleRange pos then\n                            let (ComponentInfo(_,_,_,longIdent,_,_,_,_)) = componentInfo\n                            walkModuleOrNamespace (longIdent::acc) (nestedModuleDecls, nestedModuleRange)\n                        else acc\n                    | _ -> acc) idents\n\n            modules\n            |> List.fold (fun acc (SynModuleOrNamespace(longIdent, _, _, decls, _, _, _, moduleRange)) ->\n                    if rangeContainsPos moduleRange pos then\n                        walkModuleOrNamespace (longIdent::acc) (decls, moduleRange) @ acc\n                    else acc) []\n        | ParsedInput.SigFile(ParsedSigFileInput(_, _, _, _, modules)) ->\n            let rec walkModuleOrNamespaceSig idents (decls, moduleRange) =\n                decls\n                |> List.fold (fun acc ->\n                    function\n                    | SynModuleSigDecl.NestedModule (componentInfo, _, nestedModuleDecls, nestedModuleRange) ->\n                        if rangeContainsPos moduleRange pos then\n                            let (ComponentInfo(_,_,_,longIdent,_,_,_,_)) = componentInfo\n                            walkModuleOrNamespaceSig (longIdent::acc) (nestedModuleDecls, nestedModuleRange)\n                        else acc\n                    | _ -> acc) idents\n\n            modules\n            |> List.fold (fun acc (SynModuleOrNamespaceSig(longIdent, _, _, decls, _, _, _, moduleRange)) ->\n                    if rangeContainsPos moduleRange pos then\n                        walkModuleOrNamespaceSig (longIdent::acc) (decls, moduleRange) @ acc\n                    else acc) []\n    idents\n    |> List.rev\n    |> Seq.concat\n    |> Seq.map (fun ident -> ident.idText)\n    |> String.concat \".\"\n\n\nmodule HashDirectiveInfo =\n    open System.IO\n\n    type IncludeDirective =\n        | ResolvedDirectory of string\n\n    type LoadDirective =\n        | ExistingFile of string\n        | UnresolvableFile of string * previousIncludes : string array\n\n    [<NoComparison>]\n    type Directive =\n        | Include of IncludeDirective * range\n        | Load of LoadDirective * range\n\n    /// returns an array of LoadScriptResolutionEntries\n    /// based on #I and #load directives\n    let getIncludeAndLoadDirectives ast =\n        // the Load items are resolved using fallback resolution relying on previously parsed #I directives\n        // (this behaviour is undocumented in F# but it seems to be how it works).\n\n        // list of #I directives so far (populated while encountering those in order)\n        // TODO: replace by List.fold if possible\n        let includesSoFar = new System.Collections.Generic.List<_>()\n        let pushInclude = includesSoFar.Add\n\n        // those might need to be abstracted away from real filesystem operations\n        let fileExists = File.Exists\n        let directoryExists = Directory.Exists\n        let isPathRooted = Path.IsPathRooted\n        let getDirectoryOfFile = Path.GetFullPathSafe >> Path.GetDirectoryName\n        let getRootedDirectory = Path.GetFullPathSafe\n        let makeRootedDirectoryIfNecessary baseDirectory directory =\n            if not (isPathRooted directory) then\n                getRootedDirectory (baseDirectory </> directory)\n            else\n                directory\n\n        // separate function to reduce nesting one level\n        let parseDirectives modules file =\n            [|\n            let baseDirectory = getDirectoryOfFile file\n            for (SynModuleOrNamespace (_, _, _, declarations, _, _, _, _)) in modules do\n                for decl in declarations do\n                    match decl with\n                    | SynModuleDecl.HashDirective (ParsedHashDirective(\"I\",[directory],range),_) ->\n                        let directory = makeRootedDirectoryIfNecessary (getDirectoryOfFile file) directory\n\n                        if directoryExists directory then\n                            let includeDirective = ResolvedDirectory(directory)\n                            pushInclude includeDirective\n                            yield Include (includeDirective, range)\n\n                    | SynModuleDecl.HashDirective (ParsedHashDirective (\"load\",files,range),_) ->\n                        for f in files do\n                            if isPathRooted f && fileExists f then\n\n                                // this is absolute reference to an existing script, easiest case\n                                yield Load (ExistingFile f, range)\n\n                            else\n                                // I'm not sure if the order is correct, first checking relative to file containing the #load directive\n                                // then checking for undocumented resolution using previously parsed #I directives\n                                let fileRelativeToCurrentFile = baseDirectory </> f\n                                if fileExists fileRelativeToCurrentFile then\n                                    // this is existing file relative to current file\n                                    yield Load (ExistingFile fileRelativeToCurrentFile, range)\n\n                                else\n                                    // match file against first include which seemingly have it found\n                                    let maybeFile =\n                                        includesSoFar\n                                        |> Seq.tryPick (function\n                                            | (ResolvedDirectory d) ->\n                                                let filePath = d </> f\n                                                if fileExists filePath then Some filePath else None\n                                        )\n                                    match maybeFile with\n                                    | None -> () // can't load this file even using any of the #I directives...\n                                    | Some f ->\n                                        yield Load (ExistingFile f,range)\n                    | _ -> ()\n            |]\n\n        match ast with\n        | ParsedInput.ImplFile (ParsedImplFileInput(fn,_,_,_,_,modules,_)) -> parseDirectives modules fn\n        | _ -> [||]\n\n    /// returns the Some (complete file name of a resolved #load directive at position) or None\n    let getHashLoadDirectiveResolvedPathAtPosition (pos: pos) (ast: ParsedInput) : string option =\n        getIncludeAndLoadDirectives ast\n        |> Array.tryPick (\n            function\n            | Load (ExistingFile f,range)\n                // check the line is within the range\n                // (doesn't work when there are multiple files given to a single #load directive)\n                when rangeContainsPos range pos\n                    -> Some f\n            | _     -> None\n        )\n\n\n/// Set of visitor utilities, designed for the express purpose of fetching ranges\n/// from an untyped AST for the purposes of outlining.\nmodule Outlining =\n    [<RequireQualifiedAccess>]\n    module private Range =\n        /// Create a range starting at the end of r1 and finishing at the end of r2\n        let inline endToEnd (r1: range) (r2: range) = mkFileIndexRange r1.FileIndex r1.End   r2.End\n\n        /// Create a range beginning at the start of r1 and finishing at the end of r2\n        let inline startToEnd (r1: range) (r2: range) = mkFileIndexRange r1.FileIndex r1.Start r2.End\n\n        /// Create a new range from r by shifting the starting column by m\n        let inline modStart (r: range) (m:int) =\n            let modstart = mkPos r.StartLine (r.StartColumn+m)\n            mkFileIndexRange r.FileIndex modstart r.End\n\n        /// Produce a new range by adding modStart to the StartColumn of `r`\n        /// and subtracting modEnd from the EndColumn of `r`\n        let inline modBoth (r:range) modStart modEnd =\n            let rStart = Range.mkPos r.StartLine (r.StartColumn+modStart)\n            let rEnd   = Range.mkPos r.EndLine   (r.EndColumn - modEnd)\n            mkFileIndexRange r.FileIndex rStart rEnd\n\n    /// Scope indicates the way a range/snapshot should be collapsed. |Scope.Scope.Same| is for a scope inside\n    /// some kind of scope delimiter, e.g. `[| ... |]`, `[ ... ]`, `{ ... }`, etc.  |Scope.Below| is for expressions\n    /// following a binding or the right hand side of a pattern, e.g. `let x = ...`\n    type Collapse =\n        | Below = 0\n        | Same = 1\n\n    type Scope =\n        | Open = 0\n        | Namespace = 1\n        | Module = 2\n        | Type = 3\n        | Member = 4\n        | LetOrUse = 5\n        | Match = 6\n        /// MatchLambda = function | expr -> .... | expr ->...\n        | MatchLambda = 7\n        | CompExpr = 8\n        | IfThenElse = 9\n        | ThenInIfThenElse = 10\n        | ElseInIfThenElse = 11\n        | TryWith = 12\n        | TryInTryWith = 13\n        | WithInTryWith = 14\n        | TryFinally = 15\n        | TryInTryFinally = 16\n        | FinallyInTryFinally = 17\n        | ArrayOrList = 18\n        | ObjExpr = 19\n        | For = 20\n        | While = 21\n        | CompExprInternal = 22\n        | Quote = 23\n        | Record = 24\n        | Tuple = 25\n        | SpecialFunc = 26\n        | Do = 27\n        | Lambda = 28\n        | MatchClause = 29\n        | Attribute = 30\n        | Interface = 31\n        | HashDirective = 32\n        | LetOrUseBang = 33\n        | TypeExtension = 34\n        | YieldOrReturn = 35\n        | YieldOrReturnBang = 36\n        | UnionCase = 37\n        | EnumCase = 38\n        | RecordField = 39\n        | SimpleType = 40\n        | RecordDefn = 41\n        | UnionDefn = 42\n        | Comment = 43\n        | XmlDocComment = 44\n\n    [<NoComparison; Struct>]\n    type ScopeRange (scope:Scope, collapse:Collapse, r:range) =\n        member __.Scope = scope\n        member __.Collapse = collapse\n        member __.Range = r\n\n    // Only yield a range that spans 2 or more lines\n    let inline private rcheck scope collapse (r: range) =\n        seq { if r.StartLine <> r.EndLine then\n                yield ScopeRange (scope, collapse, r) }\n\n    let rec private parseExpr expression =\n        seq {\n            match expression with\n            | SynExpr.Upcast (e,_,_)\n            | SynExpr.Downcast (e,_,_)\n            | SynExpr.AddressOf(_,e,_,_)\n            | SynExpr.InferredDowncast (e,_)\n            | SynExpr.InferredUpcast (e,_)\n            | SynExpr.DotGet (e,_,_,_)\n            | SynExpr.Do (e,_)\n            | SynExpr.DotSet (e,_,_,_)\n            | SynExpr.New (_,_,e,_)\n            | SynExpr.Typed (e,_,_)\n            | SynExpr.DotIndexedGet (e,_,_,_)\n            | SynExpr.DotIndexedSet (e,_,_,_,_,_) -> yield! parseExpr e\n            | SynExpr.YieldOrReturn (_,e,r) ->\n                yield! rcheck Scope.YieldOrReturn Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.YieldOrReturnFrom (_,e,r) ->\n                yield! rcheck Scope.YieldOrReturnBang Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.DoBang (e,r) ->\n                yield! rcheck Scope.Do Collapse.Below <| Range.modStart r 3\n                yield! parseExpr e\n            | SynExpr.LetOrUseBang (_,_,_,pat,e1,e2,_) ->\n                // for `let!` or `use!` the pattern begins at the end of the keyword so that\n                // this scope can be used without adjustment if there is no `=` on the same line\n                // if there is an `=` the range will be adjusted during the tooltip creation\n                yield! rcheck Scope.LetOrUseBang Collapse.Below <| Range.endToEnd pat.Range e1.Range\n                yield! parseExpr e1\n                yield! parseExpr e2\n            | SynExpr.For (_,_,_,_,_,e,r)\n            | SynExpr.ForEach (_,_,_,_,_,e,r) ->\n                yield! rcheck Scope.For Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.LetOrUse (_,_,bindings, body,_) ->\n                yield! parseBindings bindings\n                yield! parseExpr body\n            | SynExpr.Match (seqPointAtBinding,_,clauses,_,r) ->\n                match seqPointAtBinding with\n                | SequencePointAtBinding pr ->\n                    yield! rcheck Scope.Match Collapse.Below <| Range.endToEnd pr r\n                | _ -> ()\n                yield! parseMatchClauses clauses\n            | SynExpr.MatchLambda (_,_,clauses,_,r) ->\n                yield! rcheck Scope.MatchLambda Collapse.Below <| Range.modStart r 8\n                yield! parseMatchClauses clauses\n            | SynExpr.App (atomicFlag,isInfix,funcExpr,argExpr,r) ->\n                // seq exprs, custom operators, etc\n                if ExprAtomicFlag.NonAtomic=atomicFlag && (not isInfix)\n                   && (function | SynExpr.Ident _ -> true | _ -> false) funcExpr\n                   // if the argExrp is a computation expression another match will handle the outlining\n                   // these cases must be removed to prevent creating unnecessary tags for the same scope\n                   && (function | SynExpr.CompExpr _ -> false | _ -> true) argExpr then\n                        yield! rcheck Scope.SpecialFunc Collapse.Below <| Range.endToEnd funcExpr.Range r\n                yield! parseExpr argExpr\n                yield! parseExpr funcExpr\n            | SynExpr.Sequential (_,_,e1,e2,_) ->\n                yield! parseExpr e1\n                yield! parseExpr e2\n            | SynExpr.ArrayOrListOfSeqExpr (isArray,e,r) ->\n                yield! rcheck  Scope.ArrayOrList Collapse.Same <| Range.modBoth r (if isArray then 2 else 1) (if isArray then 2 else 1)\n                yield! parseExpr e\n            | SynExpr.CompExpr (arrayOrList,_,e,r) ->\n                if arrayOrList then\n                    yield! parseExpr e\n                else  // exclude the opening { and closing } on the cexpr from collapsing\n                    yield! rcheck Scope.CompExpr Collapse.Same <| Range.modBoth r 1 1\n                yield! parseExpr e\n            | SynExpr.ObjExpr (_,_,bindings,_,newRange,wholeRange) ->\n                let r = mkFileIndexRange newRange.FileIndex newRange.End (Range.mkPos wholeRange.EndLine (wholeRange.EndColumn - 1))\n                yield! rcheck Scope.ObjExpr Collapse.Below r\n                yield! parseBindings bindings\n            | SynExpr.TryWith (e,_,matchClauses,tryRange,withRange,tryPoint,withPoint) ->\n                match tryPoint with\n                | SequencePointAtTry r ->\n                    yield! rcheck Scope.TryWith Collapse.Below <| Range.endToEnd r tryRange\n                | _ -> ()\n                match withPoint with\n                | SequencePointAtWith r ->\n                    yield! rcheck Scope.WithInTryWith Collapse.Below <| Range.endToEnd r withRange\n                | _ -> ()\n                yield! parseExpr e\n                yield! parseMatchClauses matchClauses\n            | SynExpr.TryFinally (tryExpr,finallyExpr,r,tryPoint,finallyPoint) ->\n                match tryPoint with\n                | SequencePointAtTry tryRange ->\n                    yield! rcheck Scope.TryFinally Collapse.Below <| Range.endToEnd tryRange r\n                | _ -> ()\n                match finallyPoint with\n                | SequencePointAtFinally finallyRange ->\n                    yield! rcheck  Scope.FinallyInTryFinally Collapse.Below <| Range.endToEnd finallyRange r\n                | _ -> ()\n                yield! parseExpr tryExpr\n                yield! parseExpr finallyExpr\n            | SynExpr.IfThenElse (e1,e2,e3,seqPointInfo,_,_,r) ->\n                // Outline the entire IfThenElse\n                yield! rcheck Scope.IfThenElse Collapse.Below r\n                // Outline the `then` scope\n                match seqPointInfo with\n                | SequencePointInfoForBinding.SequencePointAtBinding rt ->\n                    yield! rcheck  Scope.ThenInIfThenElse Collapse.Below <| Range.endToEnd rt e2.Range\n                | _ -> ()\n                yield! parseExpr e1\n                yield! parseExpr e2\n                match e3 with\n                | Some e ->\n                    match e with // prevent double collapsing on elifs\n                    | SynExpr.IfThenElse (_,_,_,_,_,_,_) ->\n                        yield! parseExpr e\n                    | _ ->\n                        yield! rcheck Scope.ElseInIfThenElse Collapse.Same e.Range\n                        yield! parseExpr e\n                | None -> ()\n            | SynExpr.While (_,_,e,r) ->\n                yield! rcheck Scope.While Collapse.Below  r\n                yield! parseExpr e\n            | SynExpr.Lambda (_,_,pats,e,r) ->\n                match pats with\n                | SynSimplePats.SimplePats (_,pr)\n                | SynSimplePats.Typed (_,_,pr) ->\n                    yield! rcheck Scope.Lambda Collapse.Below <| Range.endToEnd pr r\n                yield! parseExpr e\n            | SynExpr.Lazy (e,r) ->\n                yield! rcheck Scope.SpecialFunc Collapse.Below r\n                yield! parseExpr e\n            | SynExpr.Quote (_,isRaw,e,_,r) ->\n                // subtract columns so the @@> or @> is not collapsed\n                yield! rcheck Scope.Quote Collapse.Same <| Range.modBoth r (if isRaw then 3 else 2) (if isRaw then 3 else 2)\n                yield! parseExpr e\n            | SynExpr.Tuple (es,_,r) ->\n                yield! rcheck Scope.Tuple Collapse.Same r\n                yield! Seq.collect parseExpr es\n            | SynExpr.Paren (e,_,_,_) ->\n                yield! parseExpr e\n            | SynExpr.Record (recCtor,recCopy,recordFields,r) ->\n                if recCtor.IsSome then\n                    let (_,ctorArgs,_,_,_) = recCtor.Value\n                    yield! parseExpr ctorArgs\n                if recCopy.IsSome then\n                    let (e,_) = recCopy.Value\n                    yield! parseExpr e\n                yield! recordFields |> (Seq.choose (fun (_,e,_) -> e) >> Seq.collect parseExpr)\n                // exclude the opening `{` and closing `}` of the record from collapsing\n                yield! rcheck Scope.Record Collapse.Same <| Range.modBoth r 1 1\n            | _ -> ()\n        }\n\n    and private parseMatchClause (SynMatchClause.Clause (synPat,_,e,_,_)) =\n        seq { yield! rcheck Scope.MatchClause Collapse.Same <| Range.startToEnd synPat.Range e.Range  // Collapse the scope after `->`\n              yield! parseExpr e }\n\n    and private parseMatchClauses = Seq.collect parseMatchClause\n\n    and private parseAttributes (attrs: SynAttributes) =\n        seq{\n            let attrListRange =\n                if List.isEmpty attrs then Seq.empty else\n                rcheck Scope.Attribute Collapse.Same  <| Range.startToEnd (attrs.[0].Range) (attrs.[attrs.Length-1].ArgExpr.Range)\n            match  attrs with\n            | [] -> ()\n            | [_] -> yield! attrListRange\n            | hd::tl ->\n                yield! attrListRange\n                yield! parseExpr hd.ArgExpr\n                // If there are more than 2 attributes only add tags to the 2nd and beyond, to avoid double collapsing on the first attribute\n                yield! tl |> Seq.collect (fun attr -> rcheck Scope.Attribute Collapse.Same <| Range.startToEnd attr.Range attr.ArgExpr.Range)\n                // visit the expressions inside each attribute\n                yield! attrs |> Seq.collect (fun attr -> parseExpr attr.ArgExpr)\n        }\n\n    and private parseBinding (Binding (_,kind,_,_,attrs,_,_,_,_,e,br,_) as b) =\n        seq {\n//            let r = Range.endToEnd b.RangeOfBindingSansRhs b.RangeOfBindingAndRhs\n            match kind with\n            | SynBindingKind.NormalBinding ->\n                yield! rcheck Scope.LetOrUse Collapse.Below <| Range.endToEnd b.RangeOfBindingSansRhs b.RangeOfBindingAndRhs\n            | SynBindingKind.DoBinding ->\n                yield! rcheck Scope.Do Collapse.Below <| Range.modStart br 2\n            | _ -> ()\n            yield! parseAttributes attrs\n            yield! parseExpr e\n        }\n\n    and private parseBindings = Seq.collect parseBinding\n\n    and private parseSynMemberDefn d =\n        seq {\n            match d with\n            | SynMemberDefn.Member (binding, r) ->\n                yield! rcheck Scope.Member Collapse.Below r\n                yield! parseBinding binding\n            | SynMemberDefn.LetBindings (bindings, _, _, _r) ->\n                //yield! rcheck Scope.LetOrUse Collapse.Below r\n                yield! parseBindings bindings\n            | SynMemberDefn.Interface (tp,iMembers,_) ->\n                yield! rcheck Scope.Interface Collapse.Below <| Range.endToEnd tp.Range d.Range\n                match iMembers with\n                | Some members -> yield! Seq.collect parseSynMemberDefn members\n                | None -> ()\n            | SynMemberDefn.NestedType (td, _, _) ->\n                yield! parseTypeDefn td\n            | SynMemberDefn.AbstractSlot (ValSpfn(_, _, _, synt, _, _, _, _, _, _, _), _, r) ->\n                yield! rcheck Scope.Member Collapse.Below <| Range.startToEnd synt.Range r\n            | SynMemberDefn.AutoProperty (_, _, _, _, (*memkind*)_, _, _, _, e, _, r) ->\n                yield! rcheck Scope.Member Collapse.Below r\n                yield! parseExpr e\n            | _ -> ()\n        }\n\n    (*  For Cases like\n        --------------\n            type JsonDocument =\n                private {   Json : string\n                            Path : string   }\n        Or\n             type JsonDocument =\n                internal |  Json of string\n                         |  Path of string\n    *)\n    and private parseSimpleRepr simple =\n        let _accessRange (opt:SynAccess option) =\n            match opt with\n            | None -> 0\n            | Some synacc ->\n                match synacc with\n                | SynAccess.Public -> 6\n                | SynAccess.Private -> 7\n                | SynAccess.Internal -> 8\n        seq {\n            match simple with\n            | SynTypeDefnSimpleRepr.Enum (cases,er) ->\n                yield! rcheck Scope.SimpleType Collapse.Below er\n                yield!\n                    cases\n                    |> Seq.collect (fun (SynEnumCase.EnumCase (attrs, _, _, _, cr)) ->\n                        seq { yield! rcheck Scope.EnumCase Collapse.Below cr\n                              yield! parseAttributes attrs })\n            | SynTypeDefnSimpleRepr.Record (_opt,fields,rr) ->\n                //yield! rcheck Scope.SimpleType Collapse.Same <| Range.modBoth rr (accessRange opt+1) 1\n                yield! rcheck Scope.RecordDefn Collapse.Same rr //<| Range.modBoth rr 1 1\n                yield! fields\n                    |> Seq.collect (fun (SynField.Field (attrs,_,_,_,_,_,_,fr)) ->\n                    seq{yield! rcheck Scope.RecordField Collapse.Below fr\n                        yield! parseAttributes attrs\n                    })\n            | SynTypeDefnSimpleRepr.Union (_opt,cases,ur) ->\n//                yield! rcheck Scope.SimpleType Collapse.Same <| Range.modStart ur (accessRange opt)\n                yield! rcheck Scope.UnionDefn Collapse.Same ur\n                yield! cases\n                    |> Seq.collect (fun (SynUnionCase.UnionCase (attrs,_,_,_,_,cr)) ->\n                    seq{yield! rcheck Scope.UnionCase Collapse.Below cr\n                        yield! parseAttributes attrs\n                    })\n            | _ -> ()\n        }\n\n    and private parseTypeDefn (TypeDefn (componentInfo, objectModel, members, range)) =\n        seq {\n            match objectModel with\n            | SynTypeDefnRepr.ObjectModel (defnKind, objMembers, _) ->\n                match defnKind with\n                | SynTypeDefnKind.TyconAugmentation ->\n                    yield! rcheck Scope.TypeExtension Collapse.Below <| Range.endToEnd componentInfo.Range range\n                | _ ->\n                    yield! rcheck Scope.Type Collapse.Below <| Range.endToEnd componentInfo.Range range\n                yield! Seq.collect parseSynMemberDefn objMembers\n                // visit the members of a type extension\n                yield! Seq.collect parseSynMemberDefn members\n            | SynTypeDefnRepr.Simple (simpleRepr,_r) ->\n                yield! rcheck Scope.Type Collapse.Below <| Range.endToEnd componentInfo.Range range\n                yield! parseSimpleRepr simpleRepr\n                yield! Seq.collect parseSynMemberDefn members\n            | SynTypeDefnRepr.Exception _ -> ()\n        }\n\n    let private getConsecutiveModuleDecls (predicate: SynModuleDecl -> range option) (scope:Scope) (decls: SynModuleDecls) =\n        let groupConsecutiveDecls input =\n            let rec loop (input: range list) (res: range list list) currentBulk =\n                match input, currentBulk with\n                | [], [] -> List.rev res\n                | [], _ -> List.rev (currentBulk::res)\n                | r :: rest, [] -> loop rest res [r]\n                | r :: rest, last :: _ when r.StartLine = last.EndLine + 1 ->\n                    loop rest res (r::currentBulk)\n                | r :: rest, _ -> loop rest (currentBulk::res) [r]\n            loop input [] []\n\n        let selectRanges (ranges: range list) =\n            match ranges with\n            | [] -> None\n            | [r] when r.StartLine = r.EndLine -> None\n            | [r] -> Some <| ScopeRange (scope, Collapse.Same, (Range.mkRange \"\" r.Start r.End))\n            | lastRange :: rest ->\n                let firstRange = Seq.last rest\n                Some <| ScopeRange (scope, Collapse.Same, (Range.mkRange \"\" firstRange.Start lastRange.End))\n\n        decls |> (List.choose predicate >> groupConsecutiveDecls >> List.choose selectRanges)\n\n\n    let collectOpens = getConsecutiveModuleDecls (function SynModuleDecl.Open (_, r) -> Some r | _ -> None) Scope.Open\n\n    let collectHashDirectives =\n         getConsecutiveModuleDecls(\n            function\n            | SynModuleDecl.HashDirective (ParsedHashDirective (directive, _, _),r) ->\n                let prefixLength = \"#\".Length + directive.Length + \" \".Length\n                Some (Range.mkRange \"\" (Range.mkPos r.StartLine prefixLength) r.End)\n            | _ -> None) Scope.HashDirective\n\n\n    let rec private parseDeclaration (decl: SynModuleDecl) =\n        seq {\n            match decl with\n            | SynModuleDecl.Let (_,bindings,_) ->\n                yield! parseBindings bindings\n            | SynModuleDecl.Types (types,_) ->\n                yield! Seq.collect parseTypeDefn types\n            // Fold the attributes above a module\n            | SynModuleDecl.NestedModule (SynComponentInfo.ComponentInfo (attrs,_,_,_,_,_,_,cmpRange),_, decls,_,_) ->\n                // Outline the full scope of the module\n                yield! rcheck Scope.Module Collapse.Below <| Range.endToEnd cmpRange decl.Range\n                // A module's component info stores the ranges of its attributes\n                yield! parseAttributes attrs\n                yield! collectOpens decls\n                yield! Seq.collect parseDeclaration decls\n            | SynModuleDecl.DoExpr (_,e,_) ->\n                yield! parseExpr e\n            | SynModuleDecl.Attributes (attrs,_) ->\n                yield! parseAttributes attrs\n            | _ -> ()\n        }\n\n    let private parseModuleOrNamespace moduleOrNs =\n        seq { let (SynModuleOrNamespace.SynModuleOrNamespace (_,_,_,decls,_,_,_,_)) = moduleOrNs\n              yield! collectHashDirectives decls\n              yield! collectOpens decls\n              yield! Seq.collect parseDeclaration decls }\n\n    type private LineNum = int\n    type private LineStr = string\n    type private CommentType = Regular | XmlDoc\n\n    [<NoComparison>]\n    type private CommentList =\n        { Lines: ResizeArray<LineNum * LineStr>\n          Type: CommentType }\n        static member New ty lineStr =\n            { Type = ty; Lines = ResizeArray [| lineStr |] }\n\n    let private (|Comment|_|) line =\n        match line with\n        | String.StartsWith \"///\" -> Some XmlDoc\n        | String.StartsWith \"//\" -> Some Regular\n        | _ -> None\n\n    let getCommentRanges (lines: string[]) =\n        let comments: CommentList list =\n            lines\n            |> Array.foldi (fun ((lastLineNum, currentComment: CommentList option, result) as state) lineNum lineStr ->\n                match lineStr.TrimStart(), currentComment with\n                | Comment commentType, Some comment ->\n                    if comment.Type = commentType && lineNum = lastLineNum + 1 then\n                        comment.Lines.Add (lineNum, lineStr)\n                        lineNum, currentComment, result\n                    else lineNum, Some (CommentList.New commentType (lineNum, lineStr)), comment :: result\n                | Comment commentType, None ->\n                    lineNum, Some (CommentList.New commentType (lineNum, lineStr)), result\n                | _, Some comment ->\n                    lineNum, None, comment :: result\n                | _ -> state)\n               (-1, None, [])\n            |> fun (_, lastComment, comments) ->\n                match lastComment with\n                | Some comment ->\n                    comment :: comments\n                | _ -> comments\n                |> List.rev\n\n        comments\n        |> List.filter (fun comment -> comment.Lines.Count > 1)\n        |> List.map (fun comment ->\n            let lines = comment.Lines\n            let startLine, startStr = lines.[0]\n            let endLine, endStr = lines.[lines.Count - 1]\n            let startCol = startStr.IndexOf '/'\n            let endCol = endStr.TrimEnd().Length\n\n            let scopeType =\n                match comment.Type with\n                | Regular -> Scope.Comment\n                | XmlDoc -> Scope.XmlDocComment\n            ScopeRange(\n                scopeType,\n                Collapse.Same,\n                Range.mkRange\n                    \"\"\n                    (Range.mkPos (startLine + 1) startCol)\n                    (Range.mkPos (endLine + 1) endCol)))\n\n    let getOutliningRanges sourceLines tree =\n        match tree with\n        | ParsedInput.ImplFile implFile ->\n            let (ParsedImplFileInput (_, _, _, _, _, modules, _)) = implFile\n            let astBasedRanges = Seq.collect parseModuleOrNamespace modules\n            let commentRanges = getCommentRanges sourceLines\n            Seq.append astBasedRanges commentRanges\n        | _ -> Seq.empty\n\nmodule Printf =\n    [<NoComparison>]\n    type PrintfFunction =\n        { FormatString: Range.range\n          Args: Range.range[] }\n\n    [<NoComparison>]\n    type private AppWithArg =\n        { Range: Range.range\n          Arg: Range.range }\n\n    let internal getAll (input: ParsedInput option) : PrintfFunction[] =\n        let result = ResizeArray()\n        let appStack: AppWithArg list ref = ref []\n\n        let addAppWithArg appWithArg =\n            match !appStack with\n            | lastApp :: _ when not (Range.rangeContainsRange lastApp.Range appWithArg.Range) ->\n                appStack := [appWithArg]\n            | _ -> appStack := appWithArg :: !appStack\n\n        let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n            List.iter walkSynModuleOrNamespace moduleOrNamespaceList\n\n        and walkSynModuleOrNamespace (SynModuleOrNamespace(_, _, _, decls, _, _, _, _)) =\n            List.iter walkSynModuleDecl decls\n\n        and walkTypeConstraint = function\n            | SynTypeConstraint.WhereTyparDefaultsToType (_, ty, _)\n            | SynTypeConstraint.WhereTyparSubtypeOfType (_, ty, _) -> walkType ty\n            | SynTypeConstraint.WhereTyparIsEnum (_, ts, _)\n            | SynTypeConstraint.WhereTyparIsDelegate (_, ts, _) -> List.iter walkType ts\n            | SynTypeConstraint.WhereTyparSupportsMember (_, sign, _) -> walkMemberSig sign\n            | _ -> ()\n\n        and walkBinding (SynBinding.Binding (_, _, _, _, _, _, _, _, returnInfo, e, _, _)) =\n            walkExpr e\n            returnInfo |> Option.iter (fun (SynBindingReturnInfo (t, _, _)) -> walkType t)\n\n        and walkInterfaceImpl (InterfaceImpl(_, bindings, _)) = List.iter walkBinding bindings\n\n        and walkIndexerArg = function\n            | SynIndexerArg.One e -> walkExpr e\n            | SynIndexerArg.Two (e1, e2) -> List.iter walkExpr [e1; e2]\n\n        and walkType = function\n            | SynType.Array (_, t, _)\n            | SynType.HashConstraint (t, _)\n            | SynType.MeasurePower (t, _, _) -> walkType t\n            | SynType.Fun (t1, t2, _)\n            | SynType.MeasureDivide (t1, t2, _) -> walkType t1; walkType t2\n            | SynType.App (ty, _, types, _, _, _, _) -> walkType ty; List.iter walkType types\n            | SynType.LongIdentApp (_, _, _, types, _, _, _) -> List.iter walkType types\n            | SynType.Tuple (ts, _) -> ts |> List.iter (fun (_, t) -> walkType t)\n            | SynType.WithGlobalConstraints (t, typeConstraints, _) ->\n                walkType t; List.iter walkTypeConstraint typeConstraints\n            | _ -> ()\n\n        and walkClause (Clause (_, e1, e2, _, _)) =\n            walkExpr e2\n            e1 |> Option.iter walkExpr\n\n        and walkSimplePats = function\n            | SynSimplePats.SimplePats (pats, _) -> List.iter walkSimplePat pats\n            | SynSimplePats.Typed (pats, ty, _) ->\n                walkSimplePats pats\n                walkType ty\n\n        and walkExpr e =\n            match e with\n            | SynExpr.App (_, _, SynExpr.Ident _, SynExpr.Const (SynConst.String (_, stringRange), _), r) ->\n                match !appStack with\n                | (lastApp :: _) as apps when Range.rangeContainsRange lastApp.Range e.Range ->\n                    let intersectsWithFuncOrString (arg: Range.range) =\n                        Range.rangeContainsRange arg stringRange\n                        || arg = stringRange\n                        || Range.rangeContainsRange arg r\n                        || arg = r\n\n                    let rec loop acc (apps: AppWithArg list) =\n                        match acc, apps with\n                        | _, [] -> acc\n                        | [], h :: t ->\n                            if not (intersectsWithFuncOrString h.Arg) then\n                                loop [h] t\n                            else loop [] t\n                        | prev :: _, curr :: rest ->\n                            if Range.rangeContainsRange curr.Range prev.Range\n                               && not (intersectsWithFuncOrString curr.Arg) then\n                                loop (curr :: acc) rest\n                            else acc\n\n                    let args =\n                        apps\n                        |> loop []\n                        |> List.rev\n                        |> List.map (fun x -> x.Arg)\n                        |> List.toArray\n                    let res = { FormatString = stringRange\n                                Args = args }\n                    result.Add res\n                | _ -> ()\n                appStack := []\n            | SynExpr.App (_, _, SynExpr.App(_, true, SynExpr.Ident op, e1, _), e2, _) ->\n                let rec deconstruct = function\n                    | SynExpr.Paren (exp, _, _, _) -> deconstruct exp\n                    | SynExpr.Tuple (exps, _, _) ->\n                        exps |> List.iter (fun exp -> addAppWithArg { Range = e.Range; Arg = exp.Range})\n                        ()\n                    | _ -> ()\n\n                addAppWithArg { Range = e.Range; Arg = e2.Range }\n                if op.idText = (PrettyNaming.CompileOpName \"||>\")\n                        || op.idText = (PrettyNaming.CompileOpName \"|||>\") then\n                    deconstruct e1\n                    walkExpr e2\n                else\n                    if op.idText = (PrettyNaming.CompileOpName \"|>\") then\n                        addAppWithArg { Range = e.Range; Arg = e1.Range }\n                    walkExpr e2\n                    walkExpr e1\n            | SynExpr.App (_, _, SynExpr.App(_, true, _, e1, _), e2, _) ->\n                addAppWithArg { Range = e.Range; Arg = e2.Range }\n                addAppWithArg { Range = e.Range; Arg = e1.Range }\n                walkExpr e1\n                walkExpr e2\n            | SynExpr.App (_, _, e1, e2, _) ->\n                addAppWithArg { Range = e.Range; Arg = e2.Range }\n                walkExpr e1\n                walkExpr e2\n            | _ ->\n                match e with\n                | SynExpr.Paren (e, _, _, _)\n                | SynExpr.Quote (_, _, e, _, _)\n                | SynExpr.Typed (e, _, _)\n                | SynExpr.InferredUpcast (e, _)\n                | SynExpr.InferredDowncast (e, _)\n                | SynExpr.AddressOf (_, e, _, _)\n                | SynExpr.DoBang (e, _)\n                | SynExpr.YieldOrReturn (_, e, _)\n                | SynExpr.ArrayOrListOfSeqExpr (_, e, _)\n                | SynExpr.CompExpr (_, _, e, _)\n                | SynExpr.Do (e, _)\n                | SynExpr.Assert (e, _)\n                | SynExpr.Lazy (e, _)\n                | SynExpr.YieldOrReturnFrom (_, e, _) -> walkExpr e\n                | SynExpr.Lambda (_, _, pats, e, _) ->\n                    walkSimplePats pats\n                    walkExpr e\n                | SynExpr.New (_, t, e, _)\n                | SynExpr.TypeTest (e, t, _)\n                | SynExpr.Upcast (e, t, _)\n                | SynExpr.Downcast (e, t, _) -> walkExpr e; walkType t\n                | SynExpr.Tuple (es, _, _)\n                | Sequentials es\n                | SynExpr.ArrayOrList (_, es, _) -> List.iter walkExpr es\n                | SynExpr.TryFinally (e1, e2, _, _, _)\n                | SynExpr.While (_, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.Record (_, _, fields, _) ->\n                    fields |> List.iter (fun (_, e, _) -> e |> Option.iter walkExpr)\n                | SynExpr.ObjExpr(ty, argOpt, bindings, ifaces, _, _) ->\n                    argOpt |> Option.iter (fun (e, _) -> walkExpr e)\n                    walkType ty\n                    List.iter walkBinding bindings\n                    List.iter walkInterfaceImpl ifaces\n                | SynExpr.For (_, _, e1, _, e2, e3, _) -> List.iter walkExpr [e1; e2; e3]\n                | SynExpr.ForEach (_, _, _, _, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.MatchLambda (_, _, synMatchClauseList, _, _) ->\n                    List.iter walkClause synMatchClauseList\n                | SynExpr.Match (_, e, synMatchClauseList, _, _) ->\n                    walkExpr e\n                    List.iter walkClause synMatchClauseList\n                | SynExpr.TypeApp (e, _, tys, _, _, _, _) ->\n                    List.iter walkType tys; walkExpr e\n                | SynExpr.LetOrUse (_, _, bindings, e, _) ->\n                    List.iter walkBinding bindings; walkExpr e\n                | SynExpr.TryWith (e, _, clauses, _, _, _, _) ->\n                    List.iter walkClause clauses;  walkExpr e\n                | SynExpr.IfThenElse (e1, e2, e3, _, _, _, _) ->\n                    List.iter walkExpr [e1; e2]\n                    e3 |> Option.iter walkExpr\n                | SynExpr.LongIdentSet (_, e, _)\n                | SynExpr.DotGet (e, _, _, _) -> walkExpr e\n                | SynExpr.DotSet (e1, _, e2, _) ->\n                    walkExpr e1\n                    walkExpr e2\n                | SynExpr.DotIndexedGet (e, args, _, _) ->\n                    walkExpr e\n                    List.iter walkIndexerArg args\n                | SynExpr.DotIndexedSet (e1, args, e2, _, _, _) ->\n                    walkExpr e1\n                    List.iter walkIndexerArg args\n                    walkExpr e2\n                | SynExpr.NamedIndexedPropertySet (_, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.DotNamedIndexedPropertySet (e1, _, e2, e3, _) -> List.iter walkExpr [e1; e2; e3]\n                | SynExpr.JoinIn (e1, _, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.LetOrUseBang (_, _, _, _, e1, e2, _) -> List.iter walkExpr [e1; e2]\n                | SynExpr.TraitCall (_, sign, e, _) ->\n                    walkMemberSig sign\n                    walkExpr e\n                | SynExpr.Const (SynConst.Measure(_, m), _) -> walkMeasure m\n                | _ -> ()\n\n        and walkMeasure = function\n            | SynMeasure.Product (m1, m2, _)\n            | SynMeasure.Divide (m1, m2, _) -> walkMeasure m1; walkMeasure m2\n            | SynMeasure.Seq (ms, _) -> List.iter walkMeasure ms\n            | SynMeasure.Power (m, _, _) -> walkMeasure m\n            | SynMeasure.One\n            | SynMeasure.Anon _\n            | SynMeasure.Named _\n            | SynMeasure.Var _ -> ()\n\n        and walkSimplePat = function\n            | SynSimplePat.Attrib (pat, _, _) -> walkSimplePat pat\n            | SynSimplePat.Typed(_, t, _) -> walkType t\n            | _ -> ()\n\n        and walkField (SynField.Field(_, _, _, t, _, _, _, _)) = walkType t\n\n        and walkMemberSig = function\n            | SynMemberSig.Inherit (t, _)\n            | SynMemberSig.Interface(t, _) -> walkType t\n            | SynMemberSig.ValField(f, _) -> walkField f\n            | SynMemberSig.NestedType(SynTypeDefnSig.TypeDefnSig (_, repr, memberSigs, _), _) ->\n                walkTypeDefnSigRepr repr\n                List.iter walkMemberSig memberSigs\n            | SynMemberSig.Member _ -> ()\n\n        and walkMember = function\n            | SynMemberDefn.Member (binding, _) -> walkBinding binding\n            | SynMemberDefn.ImplicitCtor (_, _, pats, _, _) -> List.iter walkSimplePat pats\n            | SynMemberDefn.ImplicitInherit (t, e, _, _) -> walkType t; walkExpr e\n            | SynMemberDefn.LetBindings (bindings, _, _, _) -> List.iter walkBinding bindings\n            | SynMemberDefn.Interface (t, members, _) ->\n                walkType t\n                members |> Option.iter (List.iter walkMember)\n            | SynMemberDefn.Inherit (t, _, _) -> walkType t\n            | SynMemberDefn.ValField (field, _) -> walkField field\n            | SynMemberDefn.NestedType (tdef, _, _) -> walkTypeDefn tdef\n            | SynMemberDefn.AutoProperty (_, _, _, t, _, _, _, _, e, _, _) ->\n                Option.iter walkType t\n                walkExpr e\n            | _ -> ()\n\n        and walkTypeDefnRepr = function\n            | SynTypeDefnRepr.ObjectModel (_, defns, _) -> List.iter walkMember defns\n            | SynTypeDefnRepr.Simple _ -> ()\n            | SynTypeDefnRepr.Exception _ -> ()\n\n        and walkTypeDefnSigRepr = function\n            | SynTypeDefnSigRepr.ObjectModel (_, defns, _) -> List.iter walkMemberSig defns\n            | SynTypeDefnSigRepr.Simple _ -> ()\n            | SynTypeDefnSigRepr.Exception _ -> ()\n\n        and walkTypeDefn (TypeDefn (_, repr, members, _)) =\n            walkTypeDefnRepr repr\n            List.iter walkMember members\n\n        and walkSynModuleDecl (decl: SynModuleDecl) =\n            match decl with\n            | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace fragment\n            | SynModuleDecl.NestedModule (_, _, modules, _, _) ->\n                List.iter walkSynModuleDecl modules\n            | SynModuleDecl.Let (_, bindings, _) -> List.iter walkBinding bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> walkExpr expr\n            | SynModuleDecl.Types (types, _) -> List.iter walkTypeDefn types\n            | _ -> ()\n\n        match input with\n        | Some (ParsedInput.ImplFile input) ->\n             walkImplFileInput input\n        | _ -> ()\n        //debug \"%A\" idents\n        result.ToArray()","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"205b5e59-899b-4351-ab75-788ff73f20e7"}],"companions":[],"id":{"$":0,"Item":"8e3d8af0-5987-4429-8b9e-e537f0192955"},"expanded":true},{"name":"TypedAstUtils","content":"open System\nopen System.Text.RegularExpressions\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open UntypedAstUtils\n\n[<NoComparison>]\ntype SymbolUse =\n    { SymbolUse: FSharpSymbolUse\n      IsUsed: bool\n      FullNames: Idents[] }\n\n[<AutoOpen>]\nmodule TypedAstUtils =\n    let isSymbolLocalForProject (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpParameter -> true\n        | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember || not m.Accessibility.IsPublic\n        | :? FSharpEntity as m -> not m.Accessibility.IsPublic\n        | :? FSharpGenericParameter -> true\n        | :? FSharpUnionCase as m -> not m.Accessibility.IsPublic\n        | :? FSharpField as m -> not m.Accessibility.IsPublic\n        | _ -> false\n\n    let isAttribute<'T> (attribute: FSharpAttribute) =\n        // CompiledName throws exception on DataContractAttribute generated by SQLProvider\n        match Option.attempt (fun _ -> attribute.AttributeType.CompiledName) with\n        | Some name when name = typeof<'T>.Name -> true\n        | _ -> false\n\n    let hasAttribute<'T> (attributes: seq<FSharpAttribute>) =\n        attributes |> Seq.exists isAttribute<'T>\n\n    let tryGetAttribute<'T> (attributes: seq<FSharpAttribute>) =\n        attributes |> Seq.tryFind isAttribute<'T>\n\n    let hasModuleSuffixAttribute (entity: FSharpEntity) =\n         entity.Attributes\n         |> tryGetAttribute<CompilationRepresentationAttribute>\n         |> Option.bind (fun a ->\n              Option.attempt (fun _ -> a.ConstructorArguments)\n              |> Option.bind (fun args -> args |> Seq.tryPick (fun (_, arg) ->\n                   let res =\n                       match arg with\n                       | :? int32 as arg when arg = int CompilationRepresentationFlags.ModuleSuffix ->\n                           Some()\n                       | :? CompilationRepresentationFlags as arg when arg = CompilationRepresentationFlags.ModuleSuffix ->\n                           Some()\n                       | _ ->\n                           None\n                   res)))\n         |> Option.isSome\n\n    let isOperator (name: string) =\n        name.StartsWith \"( \" && name.EndsWith \" )\" && name.Length > 4\n            && name.Substring (2, name.Length - 4)\n               |> String.forall (fun c -> c <> ' ' && not (Char.IsLetter c))\n\n    let private UnnamedUnionFieldRegex = Regex(\"^Item(\\d+)?$\", RegexOptions.Compiled)\n    let isUnnamedUnionCaseField (field: FSharpField) = UnnamedUnionFieldRegex.IsMatch(field.Name)\n\n[<AutoOpen>]\nmodule TypedAstExtensionHelpers =\n    type FSharpEntity with\n        member x.TryGetFullName() =\n            Option.attempt (fun _ -> x.TryFullName)\n            |> Option.flatten\n            |> Option.orTry (fun _ ->\n                Option.attempt (fun _ -> String.Join(\".\", x.AccessPath, x.DisplayName)))\n\n        member x.TryGetFullDisplayName() =\n            let fullName = x.TryGetFullName() |> Option.map (fun fullName -> fullName.Split '.')\n            let res =\n                match fullName with\n                | Some fullName ->\n                    match Option.attempt (fun _ -> x.DisplayName) with\n                    | Some shortDisplayName when not (shortDisplayName.Contains \".\") ->\n                        Some (fullName |> Array.replace (fullName.Length - 1) shortDisplayName)\n                    | _ -> Some fullName\n                | None -> None\n                |> Option.map (fun fullDisplayName -> String.Join (\".\", fullDisplayName))\n            //debug \"GetFullDisplayName: FullName = %A, Result = %A\" fullName res\n            res\n\n        member x.TryGetFullCompiledName() =\n            let fullName = x.TryGetFullName() |> Option.map (fun fullName -> fullName.Split '.')\n            let res =\n                match fullName with\n                | Some fullName ->\n                    match Option.attempt (fun _ -> x.CompiledName) with\n                    | Some shortCompiledName when not (shortCompiledName.Contains \".\") ->\n                        Some (fullName |> Array.replace (fullName.Length - 1) shortCompiledName)\n                    | _ -> Some fullName\n                | None -> None\n                |> Option.map (fun fullDisplayName -> String.Join (\".\", fullDisplayName))\n            //debug \"GetFullCompiledName: FullName = %A, Result = %A\" fullName res\n            res\n\n        member x.PublicNestedEntities =\n            x.NestedEntities |> Seq.filter (fun entity -> entity.Accessibility.IsPublic)\n\n        member x.TryGetMembersFunctionsAndValues =\n            Option.attempt (fun _ -> x.MembersFunctionsAndValues) |> Option.getOrElse ([||] :> _)\n\n    type FSharpMemberOrFunctionOrValue with\n        // FullType may raise exceptions (see https://github.com/fsharp/fsharp/issues/307).\n        member x.FullTypeSafe = Option.attempt (fun _ -> x.FullType)\n\n        member x.TryGetFullDisplayName() =\n            let fullName = Option.attempt (fun _ -> x.FullName.Split '.')\n            match fullName with\n            | Some fullName ->\n                match Option.attempt (fun _ -> x.DisplayName) with\n                | Some shortDisplayName when not (shortDisplayName.Contains \".\") ->\n                    Some (fullName |> Array.replace (fullName.Length - 1) shortDisplayName)\n                | _ -> Some fullName\n            | None -> None\n            |> Option.map (fun fullDisplayName -> String.Join (\".\", fullDisplayName))\n\n        member x.TryGetFullCompiledOperatorNameIdents() : Idents option =\n            // For operator ++ displayName is ( ++ ) compiledName is op_PlusPlus\n            if isOperator x.DisplayName && x.DisplayName <> x.CompiledName then\n                Option.attempt (fun _ -> x.EnclosingEntity)\n                |> Option.bind (fun e -> e.TryGetFullName())\n                |> Option.map (fun enclosingEntityFullName ->\n                     Array.append (enclosingEntityFullName.Split '.') [| x.CompiledName |])\n            else None\n\n    type FSharpAssemblySignature with\n        member x.TryGetEntities() = try x.Entities :> _ seq with _ -> Seq.empty\n\n[<AutoOpen>]\nmodule TypedAstPatterns =\n    let (|AbbreviatedType|_|) (entity: FSharpEntity) =\n        if entity.IsFSharpAbbreviation then Some entity.AbbreviatedType\n        else None\n\n    let (|TypeWithDefinition|_|) (ty: FSharpType) =\n        if ty.HasTypeDefinition then Some ty.TypeDefinition\n        else None\n\n    let rec getEntityAbbreviatedType (entity: FSharpEntity) =\n        if entity.IsFSharpAbbreviation then\n            match entity.AbbreviatedType with\n            | TypeWithDefinition def -> getEntityAbbreviatedType def\n            | abbreviatedType -> entity, Some abbreviatedType\n        else entity, None\n\n    let rec getAbbreviatedType (fsharpType: FSharpType) =\n        if fsharpType.IsAbbreviation then\n            getAbbreviatedType fsharpType.AbbreviatedType\n        else fsharpType\n\n    let (|Attribute|_|) (entity: FSharpEntity) =\n        let isAttribute (entity: FSharpEntity) =\n            let getBaseType (entity: FSharpEntity) =\n                try\n                    match entity.BaseType with\n                    | Some (TypeWithDefinition def) -> Some def\n                    | _ -> None\n                with _ -> None\n\n            let rec isAttributeType (ty: FSharpEntity option) =\n                match ty with\n                | None -> false\n                | Some ty ->\n                    match ty.TryGetFullName() with\n                    | None -> false\n                    | Some fullName ->\n                        fullName = \"System.Attribute\" || isAttributeType (getBaseType ty)\n            isAttributeType (Some entity)\n        if isAttribute entity then Some() else None\n\n    let (|ValueType|_|) (e: FSharpEntity) =\n        if e.IsEnum || e.IsValueType || hasAttribute<MeasureAnnotatedAbbreviationAttribute> e.Attributes then Some()\n        else None\n\n    let (|Class|_|) (original: FSharpEntity, abbreviated: FSharpEntity, _) =\n        if abbreviated.IsClass\n           && (not abbreviated.IsStaticInstantiation || original.IsFSharpAbbreviation) then Some()\n        else None\n\n    let (|Record|_|) (e: FSharpEntity) = if e.IsFSharpRecord then Some() else None\n    let (|UnionType|_|) (e: FSharpEntity) = if e.IsFSharpUnion then Some() else None\n    let (|Delegate|_|) (e: FSharpEntity) = if e.IsDelegate then Some() else None\n    let (|FSharpException|_|) (e: FSharpEntity) = if e.IsFSharpExceptionDeclaration then Some() else None\n    let (|Interface|_|) (e: FSharpEntity) = if e.IsInterface then Some() else None\n    let (|AbstractClass|_|) (e: FSharpEntity) =\n        if hasAttribute<AbstractClassAttribute> e.Attributes then Some() else None\n\n    let (|FSharpType|_|) (e: FSharpEntity) =\n        if e.IsDelegate || e.IsFSharpExceptionDeclaration || e.IsFSharpRecord || e.IsFSharpUnion\n            || e.IsInterface || e.IsMeasure\n            || (e.IsFSharp && e.IsOpaque && not e.IsFSharpModule && not e.IsNamespace) then Some()\n        else None\n\n    let (|ProvidedType|_|) (e: FSharpEntity) =\n        if (e.IsProvided || e.IsProvidedAndErased || e.IsProvidedAndGenerated) && e.CompiledName = e.DisplayName then\n            Some()\n        else None\n\n    let (|ByRef|_|) (e: FSharpEntity) = if e.IsByRef then Some() else None\n    let (|Array|_|) (e: FSharpEntity) = if e.IsArrayType then Some() else None\n    let (|FSharpModule|_|) (entity: FSharpEntity) = if entity.IsFSharpModule then Some() else None\n\n    let (|Namespace|_|) (entity: FSharpEntity) = if entity.IsNamespace then Some() else None\n    let (|ProvidedAndErasedType|_|) (entity: FSharpEntity) = if entity.IsProvidedAndErased then Some() else None\n    let (|Enum|_|) (entity: FSharpEntity) = if entity.IsEnum then Some() else None\n\n    let (|Tuple|_|) (ty: FSharpType option) =\n        ty |> Option.bind (fun ty -> if ty.IsTupleType then Some() else None)\n\n    let (|RefCell|_|) (ty: FSharpType) =\n        match getAbbreviatedType ty with\n        | TypeWithDefinition def when\n            def.IsFSharpRecord && def.FullName = \"Microsoft.FSharp.Core.FSharpRef`1\" -> Some()\n        | _ -> None\n\n    let (|FunctionType|_|) (ty: FSharpType) =\n        if ty.IsFunctionType then Some()\n        else None\n\n    let (|Pattern|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpUnionCase\n        | :? FSharpActivePatternCase -> Some()\n        | _ -> None\n\n    /// Field (field, fieldAbbreviatedType)\n    let (|Field|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpField as field -> Some (field, getAbbreviatedType field.FieldType)\n        | _ -> None\n\n    let (|MutableVar|_|) (symbol: FSharpSymbol) =\n        let isMutable =\n            match symbol with\n            | :? FSharpField as field -> field.IsMutable && not field.IsLiteral\n            | :? FSharpMemberOrFunctionOrValue as func -> func.IsMutable\n            | _ -> false\n        if isMutable then Some() else None\n\n    /// Entity (originalEntity, abbreviatedEntity, abbreviatedType)\n    let (|FSharpEntity|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpEntity as entity ->\n            let abbreviatedEntity, abbreviatedType = getEntityAbbreviatedType entity\n            Some (entity, abbreviatedEntity, abbreviatedType)\n        | _ -> None\n\n    let (|Parameter|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpParameter -> Some()\n        | _ -> None\n\n    let (|UnionCase|_|) (e: FSharpSymbol) =\n        match e with\n        | :? FSharpUnionCase as uc -> Some uc\n        | _ -> None\n\n    let (|RecordField|_|) (e: FSharpSymbol) =\n        match e with\n        | :? FSharpField as field ->\n            if field.DeclaringEntity.IsFSharpRecord then Some field else None\n        | _ -> None\n\n    let (|ActivePatternCase|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpActivePatternCase as case -> Some case\n        | _ -> None\n\n    /// Func (memberFunctionOrValue, fullType)\n    let (|MemberFunctionOrValue|_|) (symbol: FSharpSymbol) =\n        match symbol with\n        | :? FSharpMemberOrFunctionOrValue as func -> Some func\n        | _ -> None\n\n    /// Constructor (enclosingEntity)\n    let (|Constructor|_|) (func: FSharpMemberOrFunctionOrValue) =\n        match func.CompiledName with\n        | \".ctor\" | \".cctor\" -> Some func.EnclosingEntity\n        | _ -> None\n\n    let (|Function|_|) excluded (func: FSharpMemberOrFunctionOrValue) =\n        match func.FullTypeSafe |> Option.map getAbbreviatedType with\n        | Some typ when typ.IsFunctionType\n                       && not func.IsPropertyGetterMethod\n                       && not func.IsPropertySetterMethod\n                       && not excluded\n                       && not (isOperator func.DisplayName) -> Some()\n        | _ -> None\n\n    let (|ExtensionMember|_|) (func: FSharpMemberOrFunctionOrValue) =\n        if func.IsExtensionMember then Some() else None\n\n    let (|Event|_|) (func: FSharpMemberOrFunctionOrValue) =\n        if func.IsEvent then Some () else None\n\nmodule UnusedDeclarations =\n    open System.Collections.Generic\n\n    let symbolUseComparer =\n        { new IEqualityComparer<FSharpSymbolUse> with\n              member __.Equals (x, y) = x.Symbol.IsEffectivelySameAs y.Symbol\n              member __.GetHashCode x = x.Symbol.GetHashCode() }\n\n    let getSingleDeclarations (symbolsUses: SymbolUse[]): FSharpSymbol[] =\n        let symbols = Dictionary<FSharpSymbolUse, int>(symbolUseComparer)\n\n        for symbolUse in symbolsUses do\n            match symbols.TryGetValue symbolUse.SymbolUse with\n            | true, count -> symbols.[symbolUse.SymbolUse] <- count + 1\n            | _ -> symbols.[symbolUse.SymbolUse] <- 1\n\n        symbols\n        |> Seq.choose (fun (KeyValue(symbolUse, count)) ->\n            match symbolUse.Symbol with\n            | UnionCase _ when isSymbolLocalForProject symbolUse.Symbol -> Some symbolUse.Symbol\n            // Determining that a record, DU or module is used anywhere requires\n            // inspecting all their enclosed entities (fields, cases and func / vals)\n            // for usefulness, which is too expensive to do. Hence we never gray them out.\n            | FSharpEntity ((Record | UnionType | Interface | FSharpModule), _, _ | Class) -> None\n            // FCS returns inconsistent results for override members; we're skipping these symbols.\n            | MemberFunctionOrValue func when func.IsOverrideOrExplicitInterfaceImplementation -> None\n            // Usage of DU case parameters does not give any meaningful feedback; we never gray them out.\n            | Parameter -> None\n            | _ when count = 1 && symbolUse.IsFromDefinition && isSymbolLocalForProject symbolUse.Symbol ->\n                    Some symbolUse.Symbol\n                | _ -> None)\n        |> Seq.toArray","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"8e3d8af0-5987-4429-8b9e-e537f0192955"}],"companions":[],"id":{"$":0,"Item":"34a27ec3-40ab-455a-a53f-48fde25fd73c"},"expanded":true},{"name":"AssemblyContentProvider","content":"open System\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n\n//type internal ShortIdent = string\n//type Idents = ShortIdent[]\ntype IsAutoOpen = bool\ntype ModuleKind = { IsAutoOpen: bool; HasModuleSuffix: bool }\n\ntype EntityKind =\n    | Attribute\n    | Type\n    | FunctionOrValue of isActivePattern:bool\n    | Module of ModuleKind\n    override x.ToString() = sprintf \"%A\" x\n\ntype RawEntity =\n    { /// Full entity name as it's seen in compiled code (raw FSharpEntity.FullName, FSharpValueOrFunction.FullName).\n      FullName: string\n      /// Entity name parts with removed module suffixes (Ns.M1Module.M2Module.M3.entity -> Ns.M1.M2.M3.entity)\n      /// and replaced compiled names with display names (FSharpEntity.DisplayName, FSharpValueOrFucntion.DisplayName).\n      /// Note: *all* parts are cleaned, not the last one.\n      CleanedIdents: Idents\n      Namespace: Idents option\n      IsPublic: bool\n      TopRequireQualifiedAccessParent: Idents option\n      AutoOpenParent: Idents option\n      Kind: EntityKind }\n    override x.ToString() = sprintf \"%A\" x\n\ntype AssemblyPath = string\ntype AssemblyContentType = Public | Full\n\ntype Parent =\n    { Namespace: Idents option\n      RequiresQualifiedAccess: Idents option\n      AutoOpen: Idents option\n      WithModuleSuffix: Idents option }\n    static member Empty =\n        { Namespace = None\n          RequiresQualifiedAccess = None\n          AutoOpen = None\n          WithModuleSuffix = None }\n    static member RewriteParentIdents (parentIdents: Idents option) (idents: Idents) =\n        match parentIdents with\n        | Some p when p.Length <= idents.Length ->\n            for i in 0..p.Length - 1 do\n                idents.[i] <- p.[i]\n        | _ -> ()\n        idents\n\n    member x.FixParentModuleSuffix (idents: Idents) =\n        Parent.RewriteParentIdents x.WithModuleSuffix idents\n\n    member __.FormatEntityFullName (entity: FSharpEntity) =\n        // remove number of arguments from generic types\n        // e.g. System.Collections.Generic.Dictionary`2 -> System.Collections.Generic.Dictionary\n        // and System.Data.Listeners`1.Func -> System.Data.Listeners.Func\n        let removeGenericParamsCount (idents: Idents) =\n            idents\n            |> Array.map (fun ident ->\n                if ident.Length > 0 && Char.IsDigit ident.[ident.Length - 1] then\n                    let lastBacktickIndex = ident.LastIndexOf '`'\n                    if lastBacktickIndex <> -1 then\n                        ident.Substring(0, lastBacktickIndex)\n                    else ident\n                else ident)\n\n        let removeModuleSuffix (idents: Idents) =\n            if entity.IsFSharpModule && idents.Length > 0 && hasModuleSuffixAttribute entity then\n                let lastIdent = idents.[idents.Length - 1]\n                if lastIdent.EndsWith \"Module\" then\n                    idents |> Array.replace (idents.Length - 1) (lastIdent.Substring(0, lastIdent.Length - 6))\n                else idents\n            else idents\n\n        entity.TryGetFullName()\n        |> Option.bind (fun fullName ->\n            entity.TryGetFullDisplayName()\n            |> Option.map (fun fullDisplayName ->\n                fullName,\n                fullDisplayName.Split '.'\n                |> removeGenericParamsCount\n                |> removeModuleSuffix))\n\nmodule AssemblyContentProvider =\n    open System.IO\n\n    type AssemblyContentCacheEntry =\n        { FileWriteTime: DateTime\n          ContentType: AssemblyContentType\n          Entities: RawEntity list }\n\n    [<NoComparison; NoEquality>]\n    type IAssemblyContentCache =\n        abstract TryGet: AssemblyPath -> AssemblyContentCacheEntry option\n        abstract Set: AssemblyPath -> AssemblyContentCacheEntry -> unit\n\n    let private createEntity ns (parent: Parent) (entity: FSharpEntity) =\n        parent.FormatEntityFullName entity\n        |> Option.map (fun (fullName, cleanIdents) ->\n            { FullName = fullName\n              CleanedIdents = cleanIdents\n              Namespace = ns\n              IsPublic = entity.Accessibility.IsPublic\n              TopRequireQualifiedAccessParent = parent.RequiresQualifiedAccess |> Option.map parent.FixParentModuleSuffix\n              AutoOpenParent = parent.AutoOpen |> Option.map parent.FixParentModuleSuffix\n              Kind =\n                match entity with\n                | TypedAstPatterns.Attribute -> EntityKind.Attribute\n                | FSharpModule ->\n                    EntityKind.Module\n                        { IsAutoOpen = hasAttribute<AutoOpenAttribute> entity.Attributes\n                          HasModuleSuffix = hasModuleSuffixAttribute entity }\n                | _ -> EntityKind.Type })\n\n    let private traverseMemberFunctionAndValues ns (parent: Parent) (membersFunctionsAndValues: seq<FSharpMemberOrFunctionOrValue>) =\n        membersFunctionsAndValues\n        |> Seq.collect (fun func ->\n            let processIdents fullName idents =\n                { FullName = fullName\n                  CleanedIdents = parent.FixParentModuleSuffix idents\n                  Namespace = ns\n                  IsPublic = func.Accessibility.IsPublic\n                  TopRequireQualifiedAccessParent =\n                        parent.RequiresQualifiedAccess |> Option.map parent.FixParentModuleSuffix\n                  AutoOpenParent = parent.AutoOpen |> Option.map parent.FixParentModuleSuffix\n                  Kind = EntityKind.FunctionOrValue func.IsActivePattern }\n\n            [ yield! func.TryGetFullDisplayName()\n                     |> Option.map (fun fullDisplayName -> processIdents func.FullName (fullDisplayName.Split '.'))\n                     |> Option.toList\n              (* for\n                 [<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\n                 module M =\n                     let (++) x y = ()\n                 open M\n                 let _ = 1 ++ 2\n\n                 we should return additional RawEntity { FullName = MModule.op_PlusPlus; CleanedIdents = [|\"M\"; \"op_PlusPlus\"|] ... }\n              *)\n              yield! func.TryGetFullCompiledOperatorNameIdents()\n                     |> Option.map (fun fullCompiledIdents ->\n                          processIdents (fullCompiledIdents |> String.concat \".\") fullCompiledIdents)\n                     |> Option.toList ])\n\n    let rec private traverseEntity contentType (parent: Parent) (entity: FSharpEntity) =\n\n        seq { if not entity.IsProvided then\n                match contentType, entity.Accessibility.IsPublic with\n                | Full, _ | Public, true ->\n                    let ns = entity.Namespace |> Option.map (fun x -> x.Split '.') |> Option.orElseX parent.Namespace\n                    let currentEntity = createEntity ns parent entity\n\n                    match currentEntity with\n                    | Some x -> yield x\n                    | None -> ()\n\n                    let currentParent =\n                        { RequiresQualifiedAccess =\n                            parent.RequiresQualifiedAccess\n                            |> Option.orElseX (\n                                if hasAttribute<RequireQualifiedAccessAttribute> entity.Attributes then\n                                    parent.FormatEntityFullName entity |> Option.map snd\n                                else None)\n                          AutoOpen =\n                            let isAutoOpen = entity.IsFSharpModule && hasAttribute<AutoOpenAttribute> entity.Attributes\n                            match isAutoOpen, parent.AutoOpen with\n                            // if parent is also AutoOpen, then keep the parent\n                            | true, Some parent -> Some parent\n                            // if parent is not AutoOpen, but current entity is, peek the latter as a new AutoOpen module\n                            | true, None -> parent.FormatEntityFullName entity |> Option.map snd\n                            // if current entity is not AutoOpen, we discard whatever parent was\n                            | false, _ -> None\n\n                          WithModuleSuffix =\n                            if entity.IsFSharpModule && hasModuleSuffixAttribute entity then\n                                currentEntity |> Option.map (fun e -> e.CleanedIdents)\n                            else parent.WithModuleSuffix\n                          Namespace = ns }\n\n                    if entity.IsFSharpModule then\n                        match entity.TryGetMembersFunctionsAndValues with\n                        | xs when xs.Count > 0 ->\n                            yield! traverseMemberFunctionAndValues ns currentParent xs\n                        | _ -> ()\n\n                    for e in (try entity.NestedEntities :> _ seq with _ -> Seq.empty) do\n                        yield! traverseEntity contentType currentParent e\n                | _ -> () }\n\n    let getAssemblySignatureContent contentType (signature: FSharpAssemblySignature) =\n            signature.TryGetEntities()\n            |> Seq.collect (traverseEntity contentType Parent.Empty)\n            |> Seq.distinct\n\n    let private getAssemblySignaturesContent contentType (assemblies: FSharpAssembly list) =\n        assemblies\n        |> Seq.collect (fun asm -> getAssemblySignatureContent contentType asm.Contents)\n        |> Seq.toList\n\n    let getAssemblyContent (withCache: ((IAssemblyContentCache -> _) -> _) option)\n                           contentType (fileName: string option) (assemblies: FSharpAssembly list) =\n        match assemblies |> List.filter (fun x -> not x.IsProviderGenerated), fileName with\n        | [], _ -> []\n        | assemblies, Some fileName ->\n            let fileWriteTime = FileInfo(fileName).LastWriteTime\n            match withCache with\n            | Some withCache ->\n                withCache <| fun cache ->\n                    match contentType, cache.TryGet fileName with\n                    | _, Some entry\n                    | Public, Some entry when entry.FileWriteTime = fileWriteTime -> entry.Entities\n                    | _ ->\n                        let entities = getAssemblySignaturesContent contentType assemblies\n                        cache.Set fileName { FileWriteTime = fileWriteTime; ContentType = contentType; Entities = entities }\n                        entities\n            | None -> getAssemblySignaturesContent contentType assemblies\n        | assemblies, None ->\n            getAssemblySignaturesContent contentType assemblies\n        |> List.filter (fun entity ->\n            match contentType, entity.IsPublic with\n            | Full, _ | Public, true -> true\n            | _ -> false)","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"34a27ec3-40ab-455a-a53f-48fde25fd73c"},{"$":0,"Item":"a6ffc34e-45f1-4732-a3e7-7de501ad478e"},{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"companions":[],"id":{"$":0,"Item":"d8d13849-5e6f-4041-b8a8-da7a3fd94a07"},"expanded":true},{"name":"Environment","content":"\nmodule Environment =\n  let private environVar v = Environment.GetEnvironmentVariable v\n\n  let private programFilesX86 =\n      let wow64 = environVar \"PROCESSOR_ARCHITEW6432\"\n      let globalArch = environVar \"PROCESSOR_ARCHITECTURE\"\n      match wow64, globalArch with\n      | \"AMD64\", \"AMD64\"\n      | null, \"AMD64\"\n      | \"x86\", \"AMD64\" -> environVar \"ProgramFiles(x86)\"\n      | _ -> environVar \"ProgramFiles\"\n      |> fun detected -> if detected = null then @\"C:\\Program Files (x86)\\\" else detected\n\n  // Below code slightly modified from FAKE MSBuildHelper.fs\n  \n  let private tryFindFile dirs file =\n      let files =\n          dirs\n          |> Seq.map (fun (path : string) ->\n              try\n                 let path =\n                    if path.StartsWith(\"\\\"\") && path.EndsWith(\"\\\"\")\n                    then path.Substring(1, path.Length - 2)\n                    else path\n                 let dir = new DirectoryInfo(path)\n                 if not dir.Exists then \"\"\n                 else\n                     let fi = new FileInfo(dir.FullName </> file)\n                     if fi.Exists then fi.FullName\n                     else \"\"\n              with\n              | _ -> \"\")\n          |> Seq.filter ((<>) \"\")\n          |> Seq.cache\n      if not (Seq.isEmpty files) then Some(Seq.head files) \n      else None\n\n  let private tryFindPath backupPaths tool =\n      let paths = Environment.GetEnvironmentVariable \"PATH\" + string Path.PathSeparator + backupPaths\n      let paths = paths.Split(Path.PathSeparator)\n      tryFindFile paths tool\n\n  let private findPath backupPaths tool =\n      match tryFindPath backupPaths tool with\n      | Some file -> file\n      | None -> tool\n\n  let msbuild =\n      if runningOnMono then \"xbuild\"\n      else\n        let MSBuildPath = \n            (programFilesX86 </> @\"\\MSBuild\\14.0\\Bin\") + \";\" +\n            (programFilesX86 </> @\"\\MSBuild\\12.0\\Bin\") + \";\" +\n            (programFilesX86 </> @\"\\MSBuild\\12.0\\Bin\\amd64\") + \";\" +\n            @\"c:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\;\" +\n            @\"c:\\Windows\\Microsoft.NET\\Framework\\v4.0.30128\\;\" +\n            @\"c:\\Windows\\Microsoft.NET\\Framework\\v3.5\\\"\n        let ev = Environment.GetEnvironmentVariable \"MSBuild\"\n        if not (String.IsNullOrEmpty ev) then ev\n        else findPath MSBuildPath \"MSBuild.exe\"\n\n  let private fsharpInstallationPath =\n    [\"4.0\"; \"3.1\"; \"3.0\"]\n    |> List.map (fun v -> programFilesX86 </> @\"\\Microsoft SDKs\\F#\\\" </> v </> @\"\\Framework\\v4.0\")\n    |> List.tryFind Directory.Exists\n\n  let fsi =\n    if runningOnMono then \"fsharpi\"\n    else\n      Option.getOrElse \"\" fsharpInstallationPath </> \"fsi.exe\"\n\n  let fsc =\n    if Utils.runningOnMono then \"fsharpc\"\n    else\n      Option.getOrElse \"\" fsharpInstallationPath </> \"fsc.exe\"\n\n  let fsharpCoreOpt =\n    if Utils.runningOnMono then\n      let mscorlibDir = Path.GetDirectoryName typeof<obj>.Assembly.Location\n      if List.forall File.Exists (List.map (combinePaths mscorlibDir) [\"FSharp.Core.dll\"; \"FSharp.Core.optdata\"; \"FSharp.Core.sigdata\"]) then\n        Some (mscorlibDir </> \"FSharp.Core.dll\")\n      else\n        None\n    else\n      let referenceAssembliesPath =\n        programFilesX86 </> @\"Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\\"\n      let fsharpCoreVersions = [\"4.4.0.0\"; \"4.3.1.0\"; \"4.3.0.0\"]\n      tryFindFile (List.map (combinePaths referenceAssembliesPath) fsharpCoreVersions) \"FSharp.Core.dll\"\n\n  let referenceAssembliesPath = \n     programFilesX86 </> @\"Reference Assemblies\\Microsoft\\Framework\\.NETFramework\"\n  \n  let dotNetVersions () = \n    Directory.EnumerateDirectories referenceAssembliesPath\n    |> Seq.sort\n    |> Seq.toArray\n    |> Array.rev","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"companions":[],"id":{"$":0,"Item":"f611054f-fe6e-4bce-aabe-2a169271649a"},"expanded":true},{"name":"CompilerServiceInterface","content":"open System\nopen System.IO\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open Utils\nopen System.Collections.Concurrent\n\ntype ParseAndCheckResults\n    (\n        parseResults: FSharpParseFileResults,\n        checkResults: FSharpCheckFileResults\n    ) =\n\n  member __.TryGetMethodOverrides (lines: LineStr[]) (pos: Pos) = async {\n    // Find the starting point, ideally right after the first '('\n    let lineCutoff = pos.Line - 6\n    let commas, line, col =\n      let rec prevPos (line,col) =\n        match line, col with\n        | 1, 1\n        | _ when line < lineCutoff -> 1, 1\n        | _, 1 ->\n           let prevLine = lines.[line - 2]\n           if prevLine.Length = 0 then prevPos(line-1, 1)\n           else line - 1, prevLine.Length\n        | _    -> line, col - 1\n\n      let rec loop commas depth (line, col) =\n        if (line,col) <= (1,1) then (0, line, col) else\n        let ch = lines.[line - 1].[col - 1]\n        let commas = if depth = 0 && ch = ',' then commas + 1 else commas\n        if (ch = '(' || ch = '{' || ch = '[') && depth > 0 then loop commas (depth - 1) (prevPos (line,col))\n        elif ch = ')' || ch = '}' || ch = ']' then loop commas (depth + 1) (prevPos (line,col))\n        elif ch = '(' || ch = '<' then commas, line, col\n        else loop commas depth (prevPos (line,col))\n      match loop 0 0 (prevPos(pos.Line, pos.Col)) with\n      | _, 1, 1 -> 0, pos.Line, pos.Col\n      | newPos -> newPos\n\n    let lineStr = lines.[line - 1]\n    match Parsing.findLongIdentsAtGetMethodsTrigger(col - 1, lineStr) with\n    | None -> return Failure \"Could not find ident at this location\"\n    | Some identIsland ->\n\n    let! meth = checkResults.GetMethodsAlternate(line, col, lineStr, Some identIsland)\n\n    return Success(meth, commas) }\n\n  member __.TryFindDeclaration (pos: Pos) (lineStr: LineStr) = async {\n    match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n    | None -> return Failure \"Could not find ident at this location\"\n    | Some(col, identIsland) ->\n\n      let! declarations = checkResults.GetDeclarationLocationAlternate(pos.Line, col, lineStr, identIsland, false)\n\n      match declarations with\n      | FSharpFindDeclResult.DeclNotFound _ -> return Failure \"Could not find declaration\"\n      | FSharpFindDeclResult.DeclFound range -> return Success range\n    }\n\n  member __.TryGetToolTip (pos: Pos) (lineStr: LineStr) = async {\n    match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n    | None -> return Failure \"Cannot find ident for tooltip\"\n    | Some(col,identIsland) ->\n\n      // TODO: Display other tooltip types, for example for strings or comments where appropriate\n      let! tip = checkResults.GetToolTipTextAlternate(pos.Line, col, lineStr, identIsland, FSharpTokenTag.Identifier)\n      return\n        match tip with\n        | FSharpToolTipText(elems) when elems |> List.forall ((=) FSharpToolTipElement.None) ->\n            match identIsland with\n            | [ident] ->\n               KeywordList.tryGetKeywordDescription ident\n               |> Option.map (fun desc -> FSharpToolTipText [FSharpToolTipElement.Single(ident, FSharpXmlDoc.Text desc)])\n               |> function\n               | Some tip -> Success tip\n               | None -> Failure \"No tooltip information\"\n            | _ -> Failure \"No tooltip information\"\n        | _ -> Success(tip)\n  }\n\n  member __.TryGetSymbolUse (pos: Pos) (lineStr: LineStr) =\n    async {\n        match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n        | None -> return (Failure \"No ident at this location\")\n        | Some(colu, identIsland) ->\n\n        let! symboluse = checkResults.GetSymbolUseAtLocation(pos.Line, colu, lineStr, identIsland)\n        match symboluse with\n        | None -> return (Failure \"No symbol information found\")\n        | Some symboluse ->\n\n        let! symboluses = checkResults.GetUsesOfSymbolInFile symboluse.Symbol\n        return Success (symboluse, symboluses) }\n\n  member __.TryGetF1Help (pos: Pos) (lineStr: LineStr) =\n    async {\n        match Parsing.findLongIdents(pos.Col - 1, lineStr) with\n        | None -> return (Failure \"No ident at this location\")\n        | Some(colu, identIsland) ->\n\n        let! help = checkResults.GetF1KeywordAlternate(pos.Line, colu, lineStr, identIsland)\n        match help with\n        | None -> return (Failure \"No symbol information found\")\n        | Some hlp -> return Success hlp}\n\n  member __.TryGetCompletions (pos: Pos) (lineStr: LineStr) filter = async {\n    let longName, residue = Parsing.findLongIdentsAndResidue(pos.Col - 1, lineStr)\n    try\n      let! results = checkResults.GetDeclarationListInfo(Some parseResults, pos.Line, pos.Col, lineStr, longName, residue, fun (_,_) -> false)\n\n      let decls =\n        match filter with\n        | Some \"StartsWith\" -> [| for d in results.Items do if d.Name.StartsWith(residue, StringComparison.InvariantCultureIgnoreCase) then yield d |]\n        | Some \"Contains\" -> [| for d in results.Items do if d.Name.IndexOf(residue, StringComparison.InvariantCultureIgnoreCase) >= 0 then yield d |]\n        | _ -> results.Items\n      return Some (decls, residue)\n    with :? TimeoutException -> return None\n  }\n\n  member __.GetAllEntities () =\n    async {\n      try\n        return\n          Some\n            [\n              yield! AssemblyContentProvider.getAssemblySignatureContent AssemblyContentType.Full checkResults.PartialAssemblySignature\n              let ctx = checkResults.ProjectContext\n              let assembliesByFileName =\n                ctx.GetReferencedAssemblies()\n                |> Seq.groupBy (fun asm -> asm.FileName)\n                |> Seq.map (fun (fileName, asms) -> fileName, List.ofSeq asms)\n                |> Seq.toList\n                |> List.rev // if mscorlib.dll is the first then FSC raises exception when we try to\n                            // get Content.Entities from it.\n\n              for fileName, signatures in assembliesByFileName do\n                let contentType = Public // it's always Public for now since we don't support InternalsVisibleTo attribute yet\n                yield! AssemblyContentProvider.getAssemblyContent None contentType fileName signatures\n\n            ]\n      with\n      | _ -> return None\n  }\n\n  member __.GetSemanticClassification = checkResults.GetSemanticClassification None\n  member __.GetAST = parseResults.ParseTree\n  member __.GetCheckResults = checkResults\n  member __.GetParseResults = parseResults\n  member __.FileName = parseResults.FileName\n\ntype private FileState =\n    | Checked\n    | NeedChecking\n    | BeingChecked\n    | Cancelled\n\ntype Version = int\n\ntype FSharpCompilerServiceChecker() =\n  let checker =\n    FSharpChecker.Create(\n      projectCacheSize = 200,\n      keepAllBackgroundResolutions = false,\n      keepAssemblyContents = true)\n\n  let files = ConcurrentDictionary<string, Version * FileState>()\n  do checker.BeforeBackgroundFileCheck.Add ignore\n\n  let isResultObsolete fileName =\n      match files.TryGetValue fileName with\n      | true, (_, Cancelled) -> true\n      | _ -> false\n\n  let fileChanged filePath version =\n    files.AddOrUpdate (filePath, (version, NeedChecking), (fun _ (oldVersion, oldState) ->\n        if version <> oldVersion then\n           (version,\n            match oldState with\n            | BeingChecked -> Cancelled\n            | Cancelled -> Cancelled\n            | NeedChecking -> NeedChecking\n            | Checked -> NeedChecking)\n        else oldVersion, oldState))\n    |> debug \"[LanguageService] %s changed: set status to %A\" filePath\n\n\n  let fixFileName path =\n    if (try Path.GetFullPath path |> ignore; true with _ -> false) then path\n    else\n        match Environment.OSVersion.Platform with\n        | PlatformID.Unix\n        | PlatformID.MacOSX -> Environment.GetEnvironmentVariable \"HOME\"\n        | _ -> Environment.ExpandEnvironmentVariables \"%HOMEDRIVE%%HOMEPATH%\"\n        </> Path.GetFileName path\n\n  let isFSharpCore (s : string) = s.EndsWith \"FSharp.Core.dll\"\n\n\n  let ensureCorrectFSharpCore (options: string[]) =\n    Environment.fsharpCoreOpt\n    |> Option.map (fun path ->\n                   let fsharpCoreRef = sprintf \"-r:%s\" path\n                   [| yield fsharpCoreRef\n                      yield! options |> Seq.filter (not << isFSharpCore) |])\n    |> Option.getOrElse options\n\n  let ensureCorrectVersions (options: string[]) =\n    if Utils.runningOnMono then options\n    else\n      let version = Environment.dotNetVersions () |> Seq.head\n      let oldRef = Environment.referenceAssembliesPath </> \"v4.0\"\n      let newRef = Environment.referenceAssembliesPath </> version\n\n      let fsharpCoreRef = options |> Seq.find isFSharpCore\n\n      let newOptions =\n        options\n        |> Seq.filter (not << isFSharpCore)\n        |> Seq.map (fun (s : string) -> s.Replace(oldRef, newRef) )\n      [| yield fsharpCoreRef\n         yield! newOptions |]\n\n  let chooseByPrefix prefix (s: string) =\n    if s.StartsWith(prefix) then Some (s.Substring(prefix.Length))\n    else None\n\n  let getDependingProjects file (options : seq<string * FSharpProjectOptions>) =\n    let project = options |> Seq.tryFind (fun (k,_) -> k = file)\n    project |> Option.map (fun (name, option) ->\n      [\n        yield! options\n               |> Seq.map snd\n               |> Seq.filter (fun o -> o.ReferencedProjects |> Array.map (fun (k,v) -> v.ProjectFileName) |> Array.contains option.ProjectFileName )\n        yield option\n      ])\n\n  member __.GetProjectOptionsFromScript(file, source) = async {\n    let! rawOptions = checker.GetProjectOptionsFromScript(file, source)\n    let opts =\n      rawOptions.OtherOptions\n      |> ensureCorrectFSharpCore\n      |> ensureCorrectVersions\n\n    return { rawOptions with OtherOptions = opts }\n  }\n\n  member __.CheckProjectsInBackgroundForFile (file,options : seq<string * FSharpProjectOptions>) =\n    defaultArg (getDependingProjects file options) []\n    |> List.iter (checker.CheckProjectInBackground)\n\n  member __.ParseProjectsForFile(file, options : seq<string * FSharpProjectOptions> ) =\n    let project = options |> Seq.tryFind (fun (k,_) -> k = file)\n    match project with\n    | None -> async {return Failure \"Project for current file not found\"}\n    | Some (name, option) ->\n      async {\n        let projs = defaultArg (getDependingProjects file options) []\n        let! results =\n          projs\n          |> Seq.map checker.ParseAndCheckProject\n          |> Async.Parallel\n        let! currentResult =  checker.ParseAndCheckProject option\n        let res = [| yield currentResult; yield! results |]\n        return Success res\n      }\n\n  member __.GetBackgroundCheckResultsForFileInProject =\n    checker.GetBackgroundCheckResultsForFileInProject\n\n  member __.FileChecked =\n    checker.FileChecked\n\n  member __.ParseAndCheckFileInProject(filePath, version, source, options) =\n    async {\n      debug \"[LanguageService] ParseAndCheckFileInProject - enter\"\n      fileChanged filePath version\n      let fixedFilePath = fixFileName filePath\n      let! res = Async.Catch (async {\n          try\n               // wait until the previous checking completed\n               while files.ContainsKey filePath &&\n                     (match files.TryGetValue filePath with\n                      | true, (v, Checked)\n                      | true, (v, NeedChecking) ->\n                         files.[filePath] <- (v, BeingChecked)\n                         true\n                      | _ -> false) do\n                   do! Async.Sleep 20\n\n               debug \"[LanguageService] Change state for %s to `BeingChecked`\" filePath\n               debug \"[LanguageService] Parse and typecheck source...\"\n               return! checker.ParseAndCheckFileInProject (fixedFilePath, version, source, options, null) //TODO: Add cancelation again\n          finally\n               match files.TryGetValue filePath with\n               | true, (v, BeingChecked)\n               | true, (v, Cancelled) -> files.[filePath] <- (v, Checked)\n               | _ -> ()\n      })\n\n      debug \"[LanguageService]: Check completed\"\n      // Construct new typed parse result if the task succeeded\n      return\n          match res with\n          | Choice1Of2 x -> Success x\n          | Choice2Of2 e -> Failure e.Message\n    }\n\n  member __.TryGetRecentCheckResultsForFile(file, options, ?source) =\n    checker.TryGetRecentCheckResultsForFile(file, options, ?source=source)\n    |> Option.map (fun (pr, cr, _) -> ParseAndCheckResults (pr, cr))\n\n\n\n\n  member __.GetUsesOfSymbol (file, options : (SourceFilePath * FSharpProjectOptions) seq, symbol) = async {\n    let projects = getDependingProjects file options\n    return!\n      match projects with\n      | None -> async {return [||]}\n      | Some projects -> async {\n        let! res =\n          projects\n          |> Seq.map (fun (opts) -> async {\n              let! res = checker.ParseAndCheckProject opts\n              return! res.GetUsesOfSymbol symbol\n            })\n          |> Async.Parallel\n        return res |> Array.collect id }\n  }\n\n  member __.GetDeclarations (fileName, source, options, version) = async {\n    let! parseResult =\n      match checker.TryGetRecentCheckResultsForFile(fileName, options,source), version with\n      | Some (pr, _, v), Some ver when v = ver ->  async {return pr}\n      | _, None -> checker.ParseFileInProject(fileName, source, options)\n      | _ ->\n        async {\n          let! chkd =\n            checker.FileParsed\n            |> Event.filter (fun (fn,_) -> fn = fileName)\n            |> Async.AwaitEvent\n\n          return!\n            match checker.TryGetRecentCheckResultsForFile(fileName,options,source) with\n            | None -> checker.ParseFileInProject(fileName, source, options)\n            | Some (pr,_,_) -> async {return pr}\n        }\n    return parseResult.GetNavigationItems().Declarations\n  }\n\n  member __.GetDeclarationsInProjects (options : seq<string * FSharpProjectOptions>) =\n      options\n      |> Seq.distinctBy(fun (_, v) -> v.ProjectFileName)\n      |> Seq.map (fun (_, opts) -> async {\n          let! _ = checker.ParseAndCheckProject opts\n          return!\n            options\n            |> Seq.filter (fun (_, projectOpts) -> projectOpts = opts)\n            |> Seq.map (fun (projectFile,_) -> async {\n                let! parseRes, _ = checker.GetBackgroundCheckResultsForFileInProject(projectFile, opts)\n                return (parseRes.GetNavigationItems().Declarations |> Array.map (fun decl -> decl, projectFile))\n              })\n            |> Async.Parallel\n         })\n      |> Async.Parallel\n      |> Async.map (Seq.collect (Seq.collect id) >> Seq.toArray)\n\n\n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"f611054f-fe6e-4bce-aabe-2a169271649a"},{"$":0,"Item":"d8d13849-5e6f-4041-b8a8-da7a3fd94a07"}],"companions":[],"id":{"$":0,"Item":"1a3fb4d0-2291-4f98-805f-9eff6b63a3b4"},"expanded":true},{"name":"FileSystem","content":"\nopen Microsoft.FSharp.Compiler.AbstractIL.Internal.Library\nopen System\n\ntype VolatileFile =\n  { Touched: DateTime\n    Lines: string [] }\n\nopen System.IO\n\ntype FileSystem (actualFs: IFileSystem, tryFindFile: SourceFilePath -> VolatileFile option) =\n    let normalize = normalizePath\n    let getFile = normalize >> tryFindFile\n\n    let getContent (filename: string) =\n        filename \n        |> getFile\n        |> Option.map (fun file ->\n             System.Text.Encoding.UTF8.GetBytes (String.Join (\"\\n\", file.Lines)))\n\n    interface IFileSystem with\n        member __.FileStreamReadShim fileName =\n            getContent fileName\n            |> Option.map (fun bytes -> new MemoryStream (bytes) :> Stream)\n            |> Option.getOrElseFun (fun _ -> actualFs.FileStreamReadShim fileName)\n\n        member __.ReadAllBytesShim fileName =\n            getContent fileName\n            |> Option.getOrElseFun (fun _ -> actualFs.ReadAllBytesShim fileName)\n\n        member __.GetLastWriteTimeShim fileName =\n            getFile fileName\n            |> Option.map (fun x -> x.Touched)\n            |> Option.getOrElseFun (fun _ -> actualFs.GetLastWriteTimeShim fileName)\n\n        member __.GetTempPathShim() = actualFs.GetTempPathShim()\n        member __.FileStreamCreateShim file = file |> normalize |> actualFs.FileStreamCreateShim\n        member __.FileStreamWriteExistingShim file = file |> normalize |> actualFs.FileStreamWriteExistingShim\n        member __.GetFullPathShim file = file |> normalize |> actualFs.GetFullPathShim\n        member __.IsInvalidPathShim file = file |> normalize |> actualFs.IsInvalidPathShim\n        member __.IsPathRootedShim file = file |> normalize |> actualFs.IsPathRootedShim\n        member __.SafeExists file = file |> normalize |> actualFs.SafeExists\n        member __.FileDelete file = file |> normalize |> actualFs.FileDelete\n        member __.AssemblyLoadFrom file = file |> normalize |> actualFs.AssemblyLoadFrom\n        member __.AssemblyLoad assemblyName = actualFs.AssemblyLoad assemblyName","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"companions":[],"id":{"$":0,"Item":"3497daa6-5fa6-4bb3-b2bc-8af00e1d1995"},"expanded":true},{"name":"State","content":"open System\nopen Microsoft.FSharp.Compiler.SourceCodeServices\nopen System.Collections.Concurrent\n\ntype DeclName = string\n\ntype State =\n  {\n    Files : ConcurrentDictionary<SourceFilePath, VolatileFile>\n    FileCheckOptions : ConcurrentDictionary<SourceFilePath, FSharpProjectOptions>\n    HelpText : ConcurrentDictionary<DeclName, FSharpToolTipText>\n    mutable ColorizationOutput: bool\n  }\n\n  static member Initial =\n    { Files = ConcurrentDictionary()\n      FileCheckOptions = ConcurrentDictionary()\n      HelpText = ConcurrentDictionary()\n      ColorizationOutput = false }\n\n  member x.GetCheckerOptions(file: SourceFilePath, lines: LineStr[]) : FSharpProjectOptions option =\n    let file = Utils.normalizePath file\n\n    x.FileCheckOptions.TryFind file\n    |> Option.map (fun opts ->\n        x.Files.[file] <- { Lines = lines; Touched = DateTime.Now }\n        x.FileCheckOptions.[file] <- opts\n        opts\n    )\n\n  member x.AddFileTextAndCheckerOptions(file: SourceFilePath, lines: LineStr[], opts) =\n    let file = Utils.normalizePath file\n    let fileState = { Lines = lines; Touched = DateTime.Now }\n    x.Files.[file] <- fileState\n    x.FileCheckOptions.[file] <- opts\n\n  static member private FileWithoutProjectOptions(file) =\n    let opts=\n        defaultArg (Environment.fsharpCoreOpt  |> Option.map (fun path -> [| yield sprintf \"-r:%s\" path; yield \"--noframework\" |] )) [|\"--noframework\"|]\n\n    { ProjectFileName = file + \".fsproj\"\n      ProjectFileNames = [|file|]\n      OtherOptions = opts // \"--noframework\"\n      ReferencedProjects = [| |]\n      IsIncompleteTypeCheckEnvironment = true\n      UseScriptResolutionRules = false\n      LoadTime = DateTime.Now\n      UnresolvedReferences = None\n      OriginalLoadReferences = []\n      ExtraProjectInfo = None }\n\n  member x.TryGetFileCheckerOptionsWithLines(file: SourceFilePath) : Result<FSharpProjectOptions * LineStr[]> =\n    let file = Utils.normalizePath file\n    match x.Files.TryFind(file) with\n    | None -> Failure (sprintf \"File '%s' not parsed\" file)\n    | Some (volFile) ->\n\n      match x.FileCheckOptions.TryFind(file) with\n      | None -> Success (State.FileWithoutProjectOptions(file), volFile.Lines)\n      | Some opts -> Success (opts, volFile.Lines)\n\n  member x.TryGetFileCheckerOptionsWithSource(file: SourceFilePath) : Result<FSharpProjectOptions * string> =\n    let file = Utils.normalizePath file\n    match x.TryGetFileCheckerOptionsWithLines(file) with\n    | Failure x -> Failure x\n    | Success (opts, lines) -> Success (opts, String.concat \"\\n\" lines)\n\n  member x.TryGetFileCheckerOptionsWithLinesAndLineStr(file: SourceFilePath, pos : Pos) : Result<FSharpProjectOptions * LineStr[] * LineStr> =\n    let file = Utils.normalizePath file\n    match x.TryGetFileCheckerOptionsWithLines(file) with\n    | Failure x -> Failure x\n    | Success (opts, lines) ->\n      let ok = pos.Line <= lines.Length && pos.Line >= 1 &&\n               pos.Col <= lines.[pos.Line - 1].Length + 1 && pos.Col >= 1\n      if not ok then Failure \"Position is out of range\"\n      else Success (opts, lines, lines.[pos.Line - 1])","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"f611054f-fe6e-4bce-aabe-2a169271649a"},{"$":0,"Item":"3497daa6-5fa6-4bb3-b2bc-8af00e1d1995"}],"companions":[],"id":{"$":0,"Item":"032c8d14-697f-45c9-a306-1e0e3f275d72"},"expanded":true},{"name":"TipFormatter","content":"// --------------------------------------------------------------------------------------\n// (c) Tomas Petricek, http://tomasp.net/blog\n// --------------------------------------------------------------------------------------\nmodule TipFormatter =\n \n open System\n open System.IO\n open System.Xml\n open System.Text.RegularExpressions\n open Microsoft.FSharp.Compiler.SourceCodeServices\n \n // TODO: Improve this parser. Is there any other XmlDoc parser available?\n type private XmlDocMember(doc: XmlDocument) =\n   let nl = System.Environment.NewLine\n   let readContent (node: XmlNode) =\n     match node with\n     | null -> null\n     | _ ->\n         // Many definitions contain references like <paramref name=\"keyName\" /> or <see cref=\"T:System.IO.IOException\">\n     // Replace them by the attribute content (keyName and System.IO.Exception in the samples above)\n         Regex.Replace(node.InnerXml,\"\"\"<\\w+ \\w+=\"(?:\\w:){0,1}(.+?)\" />\"\"\", \"$1\")\n   let readChildren name (doc: XmlDocument) =\n     doc.DocumentElement.GetElementsByTagName name\n     |> Seq.cast<XmlNode>\n     |> Seq.map (fun node -> node.Attributes.[0].InnerText.Replace(\"T:\",\"\"), readContent node)\n     |> Map.ofSeq\n   let summary = readContent doc.DocumentElement.ChildNodes.[0]\n   let pars = readChildren \"param\" doc\n   let exceptions = readChildren \"exception\" doc\n   override x.ToString() =\n     summary + nl + nl +\n     (pars |> Seq.map (fun kv -> kv.Key + \": \" + kv.Value) |> String.concat nl) +\n     (if exceptions.Count = 0 then \"\"\n      else nl + nl + \"Exceptions:\" + nl +\n           (exceptions |> Seq.map (fun kv -> \"\\t\" + kv.Key + \": \" + kv.Value) |> String.concat nl))\n \n let rec private readXmlDoc (reader: XmlReader) (acc: Map<string,XmlDocMember>) =\n   let acc' =\n     match reader.Read() with\n     | false -> None\n     | true when reader.Name = \"member\" && reader.NodeType = XmlNodeType.Element ->\n       try\n         let key = reader.GetAttribute(\"name\")\n         use subReader = reader.ReadSubtree()\n         let doc = XmlDocument()\n         doc.Load(subReader)\n         acc |> Map.add key (XmlDocMember doc) |> Some\n       with\n       | _ -> Some acc\n     | _ -> Some acc\n   match acc' with\n   | None -> acc\n   | Some acc' -> readXmlDoc reader acc'\n \n let private getXmlDoc =\n   let xmlDocCache = System.Collections.Concurrent.ConcurrentDictionary<string, Map<string, XmlDocMember>>()\n   fun dllFile ->\n     let xmlFile = Path.ChangeExtension(dllFile, \".xml\")\n     if xmlDocCache.ContainsKey xmlFile then\n       Some xmlDocCache.[xmlFile]\n     else\n       let rec exists filePath tryAgain =\n         match File.Exists filePath, tryAgain with\n         | true, _ -> Some filePath\n         | false, false -> None\n         | false, true ->\n           // In Linux, we need to check for upper case extension separately\n           let filePath = Path.ChangeExtension(filePath, Path.GetExtension(filePath).ToUpper())\n           exists filePath false\n \n       match exists xmlFile true with\n       | None -> None\n       | Some actualXmlFile ->\n         // Prevent other threads from tying to add the same doc simultaneously\n         xmlDocCache.AddOrUpdate(xmlFile, Map.empty, fun _ _ -> Map.empty) |> ignore\n         try\n           use reader = XmlReader.Create actualXmlFile\n           let xmlDoc = readXmlDoc reader Map.empty\n           xmlDocCache.AddOrUpdate(xmlFile, xmlDoc, fun _ _ -> xmlDoc) |> ignore\n           Some xmlDoc\n         with _ ->\n           None  // TODO: Remove the empty map from cache to try again in the next request?\n \n // --------------------------------------------------------------------------------------\n // Formatting of tool-tip information displayed in F# IntelliSense\n // --------------------------------------------------------------------------------------\n let private buildFormatComment cmt =\n     match cmt with\n     | FSharpXmlDoc.Text s -> s\n     | FSharpXmlDoc.XmlDocFileSignature(dllFile, memberName) ->\n        match getXmlDoc dllFile with\n        | Some doc when doc.ContainsKey memberName -> string doc.[memberName]\n        | _ -> \"\"\n     | _ -> \"\"\n \n let formatTip (FSharpToolTipText tips) : (string * string) list list =\n     tips\n     |> List.choose (function\n         | FSharpToolTipElement.Single (it, comment) -> Some [it, buildFormatComment comment]\n         | FSharpToolTipElement.Group items ->\n             Some (items |> List.map (fun (it, comment) ->  (it, buildFormatComment comment)))\n         | FSharpToolTipElement.CompositionError (error) -> Some [(\"<Note>\", error)]\n         | _ -> None)\n \n let extractSignature (FSharpToolTipText tips) =\n     let getSignature (str: string) =\n         let nlpos = str.IndexOfAny([|'\\r';'\\n'|])\n         let firstLine =\n             if nlpos > 0 then str.[0..nlpos-1]\n             else str\n \n         if firstLine.StartsWith(\"type \", StringComparison.Ordinal) then\n             let index = firstLine.LastIndexOf(\"=\", StringComparison.Ordinal)\n             if index > 0 then firstLine.[0..index-1]\n             else firstLine\n         else firstLine\n \n     let firstResult x =\n         match x with\n         | FSharpToolTipElement.Single (t, _) when not (String.IsNullOrWhiteSpace t) -> Some t\n         | FSharpToolTipElement.Group gs -> List.tryPick (fun (t, _) -> if not (String.IsNullOrWhiteSpace t) then Some t else None) gs\n         | _ -> None\n \n     tips\n     |> Seq.sortBy (function FSharpToolTipElement.Single _ -> 0 | _ -> 1)\n     |> Seq.tryPick firstResult\n     |> Option.map getSignature\n     |> Option.getOrElse \"\"","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"companions":[],"id":{"$":0,"Item":"de1ff71b-1245-4eef-816d-975da9252207"},"expanded":true},{"name":"UnopenedNamespacesResolver","content":"/// Original code from VisualFSharpPowerTools project: https://github.com/fsprojects/VisualFSharpPowerTools/blob/master/src/FSharp.Editing/Coloring/UnopenedNamespacesResolver.fs\n//namespace FsAutoComplete.UnopenedNamespacesResolver\n\n//open FsAutoComplete.UntypedAstUtils\n\ntype LongIdent = string\n\n\ntype Entity =\n    { FullRelativeName: LongIdent\n      Qualifier: LongIdent\n      Namespace: LongIdent option\n      Name: LongIdent }\n    override x.ToString() = sprintf \"%A\" x\n\n[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Entity =\n    let getRelativeNamespace (targetNs: Idents) (sourceNs: Idents) =\n        let rec loop index =\n            if index > targetNs.Length - 1 then sourceNs.[index..]\n            // target namespace is not a full parent of source namespace, keep the source ns as is\n            elif index > sourceNs.Length - 1 then sourceNs\n            elif targetNs.[index] = sourceNs.[index] then loop (index + 1)\n            else sourceNs.[index..]\n        if sourceNs.Length = 0 || targetNs.Length = 0 then sourceNs\n        else loop 0\n\n    let cutAutoOpenModules (autoOpenParent: Idents option) (candidateNs: Idents) =\n        let nsCount =\n            match autoOpenParent with\n            | Some parent when parent.Length > 0 ->\n                min (parent.Length - 1) candidateNs.Length\n            | _ -> candidateNs.Length\n        candidateNs.[0..nsCount - 1]\n\n    let tryCreate (targetNamespace: Idents option, targetScope: Idents, partiallyQualifiedName: Idents,\n                   requiresQualifiedAccessParent: Idents option, autoOpenParent: Idents option,\n                   candidateNamespace: Idents option, candidate: Idents) =\n        match candidate with\n        | [||] -> [||]\n        | _ ->\n            partiallyQualifiedName\n            |> Array.heads\n            |> Array.choose (fun parts ->\n                if not (candidate |> Array.endsWith parts) then None\n                else\n                  let identCount = parts.Length\n                  let fullOpenableNs, restIdents =\n                      let openableNsCount =\n                          match requiresQualifiedAccessParent with\n                          | Some parent -> min parent.Length candidate.Length\n                          | None -> candidate.Length\n                      candidate.[0..openableNsCount - 2], candidate.[openableNsCount - 1..]\n\n                  let openableNs = cutAutoOpenModules autoOpenParent fullOpenableNs\n\n                  let getRelativeNs ns =\n                      match targetNamespace, candidateNamespace with\n                      | Some targetNs, Some candidateNs when candidateNs = targetNs ->\n                          getRelativeNamespace targetScope ns\n                      | None, _ -> getRelativeNamespace targetScope ns\n                      | _ -> ns\n\n                  let relativeNs = getRelativeNs openableNs\n\n                  match relativeNs, restIdents with\n                  | [||], [||] -> None\n                  | [||], [|_|] -> None\n                  | _ ->\n                      let fullRelativeName = Array.append (getRelativeNs fullOpenableNs) restIdents\n                      let ns =\n                          match relativeNs with\n                          | [||] -> None\n                          | _ when identCount > 1 && relativeNs.Length >= identCount ->\n                              Some (relativeNs.[0..relativeNs.Length - identCount] |> String.concat \".\")\n                          | _ -> Some (relativeNs |> String.concat \".\")\n                      let qualifier =\n                          if fullRelativeName.Length > 1 && fullRelativeName.Length >= identCount then\n                              fullRelativeName.[0..fullRelativeName.Length - identCount]\n                          else fullRelativeName\n                      Some\n                          { FullRelativeName = String.concat \".\" fullRelativeName //.[0..fullRelativeName.Length - identCount - 1]\n                            Qualifier = String.concat \".\" qualifier\n                            Namespace = ns\n                            Name = match restIdents with [|_|] -> \"\" | _ -> String.concat \".\" restIdents })\n\ntype ScopeKind =\n    | Namespace\n    | TopModule\n    | NestedModule\n    | OpenDeclaration\n    | HashDirective\n    override x.ToString() = sprintf \"%A\" x\n\ntype InsertContext =\n    { ScopeKind: ScopeKind\n      Pos: Pos }\n\nmodule ParsedInput =\n    open Microsoft.FSharp.Compiler\n    open Microsoft.FSharp.Compiler.Ast\n\n    type private EndLine = int\n\n    let getEntityKind (input: ParsedInput) (p: Pos) : EntityKind option =\n        let pos = Range.mkPos p.Line p.Col\n\n        let (|ConstructorPats|) = function\n            | Pats ps -> ps\n            | NamePatPairs(xs, _) -> List.map snd xs\n\n        let isPosInRange range = Range.rangeContainsPos range pos\n\n        let ifPosInRange range f =\n            if isPosInRange range then f()\n            else None\n\n        let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n            List.tryPick (walkSynModuleOrNamespace true) moduleOrNamespaceList\n\n        and walkSynModuleOrNamespace isTopLevel (SynModuleOrNamespace(_, _, isModule, decls, _, attrs, _, r)) =\n            if isModule && isTopLevel then None else List.tryPick walkAttribute attrs\n            |> Option.orElseX (ifPosInRange r (fun _ -> List.tryPick (walkSynModuleDecl isTopLevel) decls))\n\n        and walkAttribute (attr: SynAttribute) =\n            if isPosInRange attr.Range then Some EntityKind.Attribute else None\n            |> Option.orElseX (walkExprWithKind (Some EntityKind.Type) attr.ArgExpr)\n\n        and walkTypar (Typar (ident, _, _)) = ifPosInRange ident.idRange (fun _ -> Some EntityKind.Type)\n\n        and walkTyparDecl (SynTyparDecl.TyparDecl (attrs, typar)) =\n            List.tryPick walkAttribute attrs\n            |> Option.orElseX (walkTypar typar)\n\n        and walkTypeConstraint = function\n            | SynTypeConstraint.WhereTyparDefaultsToType (t1, t2, _) -> walkTypar t1 |> Option.orElseX (walkType t2)\n            | SynTypeConstraint.WhereTyparIsValueType(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsReferenceType(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsUnmanaged(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparSupportsNull (t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsComparable(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparIsEquatable(t, _) -> walkTypar t\n            | SynTypeConstraint.WhereTyparSubtypeOfType(t, ty, _) -> walkTypar t |> Option.orElseX (walkType ty)\n            | SynTypeConstraint.WhereTyparSupportsMember(ts, sign, _) ->\n                List.tryPick walkType ts |> Option.orElseX (walkMemberSig sign)\n            | SynTypeConstraint.WhereTyparIsEnum(t, ts, _) -> walkTypar t |> Option.orElseX (List.tryPick walkType ts)\n            | SynTypeConstraint.WhereTyparIsDelegate(t, ts, _) -> walkTypar t |> Option.orElseX (List.tryPick walkType ts)\n\n        and walkPatWithKind (kind: EntityKind option) = function\n            | SynPat.Ands (pats, _) -> List.tryPick walkPat pats\n            | SynPat.Named(SynPat.Wild nameRange as pat, _, _, _, _) ->\n                if isPosInRange nameRange then None\n                else walkPat pat\n            | SynPat.Typed(pat, t, _) -> walkPat pat |> Option.orElseX (walkType t)\n            | SynPat.Attrib(pat, attrs, _) -> walkPat pat |> Option.orElseX (List.tryPick walkAttribute attrs)\n            | SynPat.Or(pat1, pat2, _) -> List.tryPick walkPat [pat1; pat2]\n            | SynPat.LongIdent(_, _, typars, ConstructorPats pats, _, r) ->\n                ifPosInRange r (fun _ -> kind)\n                |> Option.orElseX (\n                    typars\n                    |> Option.bind (fun (SynValTyparDecls (typars, _, constraints)) ->\n                        List.tryPick walkTyparDecl typars\n                        |> Option.orElseX (List.tryPick walkTypeConstraint constraints)))\n                |> Option.orElseX (List.tryPick walkPat pats)\n            | SynPat.Tuple(pats, _) -> List.tryPick walkPat pats\n            | SynPat.Paren(pat, _) -> walkPat pat\n            | SynPat.ArrayOrList(_, pats, _) -> List.tryPick walkPat pats\n            | SynPat.IsInst(t, _) -> walkType t\n            | SynPat.QuoteExpr(e, _) -> walkExpr e\n            | _ -> None\n\n        and walkPat = walkPatWithKind None\n\n        and walkBinding (SynBinding.Binding(_, _, _, _, attrs, _, _, pat, returnInfo, e, _, _)) =\n            List.tryPick walkAttribute attrs\n            |> Option.orElseX (walkPat pat)\n            |> Option.orElseX (walkExpr e)\n            |> Option.orElseX (\n                match returnInfo with\n                | Some (SynBindingReturnInfo (t, _, _)) -> walkType t\n                | None -> None)\n\n        and walkInterfaceImpl (InterfaceImpl(_, bindings, _)) =\n            List.tryPick walkBinding bindings\n\n        and walkIndexerArg = function\n            | SynIndexerArg.One e -> walkExpr e\n            | SynIndexerArg.Two(e1, e2) -> List.tryPick walkExpr [e1; e2]\n\n        and walkType = function\n            | SynType.LongIdent ident -> ifPosInRange ident.Range (fun _ -> Some EntityKind.Type)\n            | SynType.App(ty, _, types, _, _, _, _) ->\n                walkType ty |> Option.orElseX (List.tryPick walkType types)\n            | SynType.LongIdentApp(_, _, _, types, _, _, _) -> List.tryPick walkType types\n            | SynType.Tuple(ts, _) -> ts |> List.tryPick (fun (_, t) -> walkType t)\n            | SynType.Array(_, t, _) -> walkType t\n            | SynType.Fun(t1, t2, _) -> walkType t1 |> Option.orElseX (walkType t2)\n            | SynType.WithGlobalConstraints(t, _, _) -> walkType t\n            | SynType.HashConstraint(t, _) -> walkType t\n            | SynType.MeasureDivide(t1, t2, _) -> walkType t1 |> Option.orElseX (walkType t2)\n            | SynType.MeasurePower(t, _, _) -> walkType t\n            | _ -> None\n\n        and walkClause (Clause(pat, e1, e2, _, _)) =\n            walkPatWithKind (Some EntityKind.Type) pat\n            |> Option.orElseX (walkExpr e2)\n            |> Option.orElseX (Option.bind walkExpr e1)\n\n        and walkExprWithKind (parentKind: EntityKind option) = function\n            | SynExpr.LongIdent (_, LongIdentWithDots(_, dotRanges), _, r) ->\n                match dotRanges with\n                | [] when isPosInRange r -> parentKind |> Option.orElseX (Some (EntityKind.FunctionOrValue false))\n                | firstDotRange :: _  ->\n                    let firstPartRange =\n                        Range.mkRange \"\" r.Start (Range.mkPos firstDotRange.StartLine (firstDotRange.StartColumn - 1))\n                    if isPosInRange firstPartRange then\n                        parentKind |> Option.orElseX (Some (EntityKind.FunctionOrValue false))\n                    else None\n                | _ -> None\n            | SynExpr.Paren (e, _, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.Quote(_, _, e, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.Typed(e, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.Tuple(es, _, _) -> List.tryPick (walkExprWithKind parentKind) es\n            | SynExpr.ArrayOrList(_, es, _) -> List.tryPick (walkExprWithKind parentKind) es\n            | SynExpr.Record(_, _, fields, r) ->\n                ifPosInRange r (fun _ ->\n                    fields |> List.tryPick (fun (_, e, _) -> e |> Option.bind (walkExprWithKind parentKind)))\n            | SynExpr.New(_, t, e, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.ObjExpr(ty, _, bindings, ifaces, _, _) ->\n                walkType ty\n                |> Option.orElseX (List.tryPick walkBinding bindings)\n                |> Option.orElseX (List.tryPick walkInterfaceImpl ifaces)\n            | SynExpr.While(_, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.For(_, _, e1, _, e2, e3, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2; e3]\n            | SynExpr.ForEach(_, _, _, _, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.ArrayOrListOfSeqExpr(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.CompExpr(_, _, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.Lambda(_, _, _, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.MatchLambda(_, _, synMatchClauseList, _, _) ->\n                List.tryPick walkClause synMatchClauseList\n            | SynExpr.Match(_, e, synMatchClauseList, _, _) ->\n                walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkClause synMatchClauseList)\n            | SynExpr.Do(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.Assert(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.App(_, _, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.TypeApp(e, _, tys, _, _, _, _) ->\n                walkExprWithKind (Some EntityKind.Type) e |> Option.orElseX (List.tryPick walkType tys)\n            | SynExpr.LetOrUse(_, _, bindings, e, _) -> List.tryPick walkBinding bindings |> Option.orElseX (walkExprWithKind parentKind e)\n            | SynExpr.TryWith(e, _, clauses, _, _, _, _) -> walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkClause clauses)\n            | SynExpr.TryFinally(e1, e2, _, _, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.Lazy(e, _) -> walkExprWithKind parentKind e\n            | Sequentials es -> List.tryPick (walkExprWithKind parentKind) es\n            | SynExpr.IfThenElse(e1, e2, e3, _, _, _, _) ->\n                List.tryPick (walkExprWithKind parentKind) [e1; e2] |> Option.orElseX (match e3 with None -> None | Some e -> walkExprWithKind parentKind e)\n            | SynExpr.Ident ident -> ifPosInRange ident.idRange (fun _ -> Some (EntityKind.FunctionOrValue false))\n            | SynExpr.LongIdentSet(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.DotGet(e, _, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.DotSet(e, _, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.DotIndexedGet(e, args, _, _) -> walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkIndexerArg args)\n            | SynExpr.DotIndexedSet(e, args, _, _, _, _) -> walkExprWithKind parentKind e |> Option.orElseX (List.tryPick walkIndexerArg args)\n            | SynExpr.NamedIndexedPropertySet(_, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.DotNamedIndexedPropertySet(e1, _, e2, e3, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2; e3]\n            | SynExpr.TypeTest(e, t, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.Upcast(e, t, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.Downcast(e, t, _) -> walkExprWithKind parentKind e |> Option.orElseX (walkType t)\n            | SynExpr.InferredUpcast(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.InferredDowncast(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.AddressOf(_, e, _, _) -> walkExprWithKind parentKind e\n            | SynExpr.JoinIn(e1, _, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.YieldOrReturn(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.YieldOrReturnFrom(_, e, _) -> walkExprWithKind parentKind e\n            | SynExpr.LetOrUseBang(_, _, _, _, e1, e2, _) -> List.tryPick (walkExprWithKind parentKind) [e1; e2]\n            | SynExpr.DoBang(e, _) -> walkExprWithKind parentKind e\n            | SynExpr.TraitCall (ts, sign, e, _) ->\n                List.tryPick walkTypar ts\n                |> Option.orElseX (walkMemberSig sign)\n                |> Option.orElseX (walkExprWithKind parentKind e)\n            | _ -> None\n\n        and walkExpr = walkExprWithKind None\n\n        and walkSimplePat = function\n            | SynSimplePat.Attrib (pat, attrs, _) ->\n                walkSimplePat pat |> Option.orElseX (List.tryPick walkAttribute attrs)\n            | SynSimplePat.Typed(pat, t, _) -> walkSimplePat pat |> Option.orElseX (walkType t)\n            | _ -> None\n\n        and walkField (SynField.Field(attrs, _, _, t, _, _, _, _)) =\n            List.tryPick walkAttribute attrs |> Option.orElseX (walkType t)\n\n        and walkValSig (SynValSig.ValSpfn(attrs, _, _, t, _, _, _, _, _, _, _)) =\n            List.tryPick walkAttribute attrs |> Option.orElseX (walkType t)\n\n        and walkMemberSig = function\n            | SynMemberSig.Inherit (t, _) -> walkType t\n            | SynMemberSig.Member(vs, _, _) -> walkValSig vs\n            | SynMemberSig.Interface(t, _) -> walkType t\n            | SynMemberSig.ValField(f, _) -> walkField f\n            | SynMemberSig.NestedType(SynTypeDefnSig.TypeDefnSig (info, repr, memberSigs, _), _) ->\n                walkComponentInfo false info\n                |> Option.orElseX (walkTypeDefnSigRepr repr)\n                |> Option.orElseX (List.tryPick walkMemberSig memberSigs)\n\n        and walkMember = function\n            | SynMemberDefn.AbstractSlot (valSig, _, _) -> walkValSig valSig\n            | SynMemberDefn.Member(binding, _) -> walkBinding binding\n            | SynMemberDefn.ImplicitCtor(_, attrs, pats, _, _) ->\n                List.tryPick walkAttribute attrs |> Option.orElseX (List.tryPick walkSimplePat pats)\n            | SynMemberDefn.ImplicitInherit(t, e, _, _) -> walkType t |> Option.orElseX (walkExpr e)\n            | SynMemberDefn.LetBindings(bindings, _, _, _) -> List.tryPick walkBinding bindings\n            | SynMemberDefn.Interface(t, members, _) ->\n                walkType t\n                |> Option.orElseX (members |> Option.bind (List.tryPick walkMember))\n            | SynMemberDefn.Inherit(t, _, _) -> walkType t\n            | SynMemberDefn.ValField(field, _) -> walkField field\n            | SynMemberDefn.NestedType(tdef, _, _) -> walkTypeDefn tdef\n            | SynMemberDefn.AutoProperty(attrs, _, _, t, _, _, _, _, e, _, _) ->\n                List.tryPick walkAttribute attrs\n                |> Option.orElseX (Option.bind walkType t)\n                |> Option.orElseX (walkExpr e)\n            | _ -> None\n\n        and walkEnumCase (EnumCase(attrs, _, _, _, _)) = List.tryPick walkAttribute attrs\n\n        and walkUnionCaseType = function\n            | SynUnionCaseType.UnionCaseFields fields -> List.tryPick walkField fields\n            | SynUnionCaseType.UnionCaseFullType(t, _) -> walkType t\n\n        and walkUnionCase (UnionCase(attrs, _, t, _, _, _)) =\n            List.tryPick walkAttribute attrs |> Option.orElseX (walkUnionCaseType t)\n\n        and walkTypeDefnSimple = function\n            | SynTypeDefnSimpleRepr.Enum (cases, _) -> List.tryPick walkEnumCase cases\n            | SynTypeDefnSimpleRepr.Union(_, cases, _) -> List.tryPick walkUnionCase cases\n            | SynTypeDefnSimpleRepr.Record(_, fields, _) -> List.tryPick walkField fields\n            | SynTypeDefnSimpleRepr.TypeAbbrev(_, t, _) -> walkType t\n            | _ -> None\n\n        and walkComponentInfo isModule (ComponentInfo(attrs, typars, constraints, _, _, _, _, r)) =\n            if isModule then None else ifPosInRange r (fun _ -> Some EntityKind.Type)\n            |> Option.orElseX (\n                List.tryPick walkAttribute attrs\n                |> Option.orElseX (List.tryPick walkTyparDecl typars)\n                |> Option.orElseX (List.tryPick walkTypeConstraint constraints))\n\n        and walkTypeDefnRepr = function\n            | SynTypeDefnRepr.ObjectModel (_, defns, _) -> List.tryPick walkMember defns\n            | SynTypeDefnRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n            | SynTypeDefnRepr.Exception(_) -> None\n\n        and walkTypeDefnSigRepr = function\n            | SynTypeDefnSigRepr.ObjectModel (_, defns, _) -> List.tryPick walkMemberSig defns\n            | SynTypeDefnSigRepr.Simple(defn, _) -> walkTypeDefnSimple defn\n            | SynTypeDefnSigRepr.Exception(_) -> None\n\n        and walkTypeDefn (TypeDefn (info, repr, members, _)) =\n            walkComponentInfo false info\n            |> Option.orElseX (walkTypeDefnRepr repr)\n            |> Option.orElseX (List.tryPick walkMember members)\n\n        and walkSynModuleDecl isTopLevel (decl: SynModuleDecl) =\n            match decl with\n            | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace isTopLevel fragment\n            | SynModuleDecl.NestedModule(info, _, modules, _, range) ->\n                walkComponentInfo true info\n                |> Option.orElseX (ifPosInRange range (fun _ -> List.tryPick (walkSynModuleDecl false) modules))\n            | SynModuleDecl.Open _ -> None\n            | SynModuleDecl.Let (_, bindings, _) -> List.tryPick walkBinding bindings\n            | SynModuleDecl.DoExpr (_, expr, _) -> walkExpr expr\n            | SynModuleDecl.Types (types, _) -> List.tryPick walkTypeDefn types\n            | _ -> None\n\n        let res =\n            match input with\n            | ParsedInput.SigFile _ -> None\n            | ParsedInput.ImplFile input -> walkImplFileInput input\n        //debug \"%A\" ast\n        res\n\n    type Col = int\n\n    type Scope =\n        { Idents: Idents\n          Kind: ScopeKind }\n\n    let tryFindInsertionContext (currentLine: int) (ast: ParsedInput) =\n        let result: (Scope * Pos) option ref = ref None\n        let ns: string[] option ref = ref None\n        let modules = ResizeArray<Idents * EndLine * Col>()\n\n        let inline longIdentToIdents ident = ident |> Seq.map (fun x -> string x) |> Seq.toArray\n\n        let addModule (longIdent: LongIdent) endLine col =\n            modules.Add(longIdent |> List.map string |> List.toArray, endLine, col)\n\n        let doRange kind (scope: LongIdent) line col =\n            if line <= currentLine then\n                match !result with\n                | None ->\n                    result := Some ({ Idents = longIdentToIdents scope; Kind = kind }, Pos.make line col)\n                | Some (oldScope, oldPos) ->\n                    match kind, oldScope.Kind with\n                    | (Namespace | NestedModule | TopModule), OpenDeclaration\n                    | _ when oldPos.Line <= line ->\n                        result :=\n                            Some ({ Idents =\n                                        match scope with\n                                        | [] -> oldScope.Idents\n                                        | _ -> longIdentToIdents scope\n                                    Kind = kind },\n                                  Pos.make line col)\n                    | _ -> ()\n\n        let getMinColumn (decls: SynModuleDecls) =\n            match decls with\n            | [] -> None\n            | firstDecl :: _ ->\n                match firstDecl with\n                | SynModuleDecl.NestedModule (_, _, _, _, r) -> Some r\n                | SynModuleDecl.Let (_, _, r) -> Some r\n                | SynModuleDecl.DoExpr (_, _, r) -> Some r\n                | SynModuleDecl.Types (_, r) -> Some r\n                | SynModuleDecl.Exception (_, r) -> Some r\n                | SynModuleDecl.Open (_, r) -> Some r\n                | SynModuleDecl.HashDirective (_, r) -> Some r\n                | _ -> None\n                |> Option.map (fun r -> r.StartColumn)\n\n\n        let rec walkImplFileInput (ParsedImplFileInput(_, _, _, _, _, moduleOrNamespaceList, _)) =\n            List.iter (walkSynModuleOrNamespace []) moduleOrNamespaceList\n\n        and walkSynModuleOrNamespace (parent: LongIdent) (SynModuleOrNamespace(ident, _, isModule, decls, _, _, _, range)) =\n            if range.EndLine >= currentLine then\n                match isModule, parent, ident with\n                | false, _, _ -> ns := Some (longIdentToIdents ident)\n                // top level module with \"inlined\" namespace like Ns1.Ns2.TopModule\n                | true, [], _f :: _s :: _ ->\n                    let ident = longIdentToIdents ident\n                    ns := Some (ident.[0..ident.Length - 2])\n                | _ -> ()\n\n                let fullIdent = parent @ ident\n\n                let startLine =\n                    if isModule then range.StartLine\n                    else range.StartLine - 1\n\n                let scopeKind =\n                    match isModule, parent with\n                    | true, [] -> TopModule\n                    | true, _ -> NestedModule\n                    | _ -> Namespace\n\n                doRange scopeKind fullIdent startLine range.StartColumn\n                addModule fullIdent range.EndLine range.StartColumn\n                List.iter (walkSynModuleDecl fullIdent) decls\n\n        and walkSynModuleDecl (parent: LongIdent) (decl: SynModuleDecl) =\n            match decl with\n            | SynModuleDecl.NamespaceFragment fragment -> walkSynModuleOrNamespace parent fragment\n            | SynModuleDecl.NestedModule(ComponentInfo(_, _, _, ident, _, _, _, _), _, decls, _, range) ->\n                let fullIdent = parent @ ident\n                addModule fullIdent range.EndLine range.StartColumn\n                if range.EndLine >= currentLine then\n                    let moduleBodyIdentation = getMinColumn decls |> Option.getOrElse (range.StartColumn + 4)\n                    doRange NestedModule fullIdent range.StartLine moduleBodyIdentation\n                    List.iter (walkSynModuleDecl fullIdent) decls\n            | SynModuleDecl.Open (_, range) -> doRange OpenDeclaration [] range.EndLine (range.StartColumn - 5)\n            | SynModuleDecl.HashDirective (_, range) -> doRange HashDirective [] range.EndLine range.StartColumn\n            | _ -> ()\n\n        match ast with\n        | ParsedInput.SigFile _ -> ()\n        | ParsedInput.ImplFile input -> walkImplFileInput input\n\n        let res =\n            !result\n            |> Option.map (fun (scope, pos) ->\n                let ns = !ns |> Option.map longIdentToIdents\n                scope, ns, { pos with Line = pos.Line + 1 } )\n\n        let modules =\n            modules\n            |> Seq.filter (fun (_, endLine, _) -> endLine < currentLine)\n            |> Seq.sortBy (fun (m, _, _) -> -m.Length)\n            |> Seq.toList\n\n        fun (partiallyQualifiedName: Idents) (requiresQualifiedAccessParent: Idents option, autoOpenParent: Idents option,\n                                              entityNamespace: Idents option, entity: Idents) ->\n            match res with\n            | None -> [||]\n            | Some (scope, ns, pos) ->\n                Entity.tryCreate(ns, scope.Idents, partiallyQualifiedName, requiresQualifiedAccessParent,\n                                 autoOpenParent, entityNamespace, entity)\n                |> Array.map (fun e ->\n                    e,\n                    match modules |> List.filter (fun (m, _, _) -> entity |> Array.startsWith m ) with\n                    | [] -> { ScopeKind = scope.Kind; Pos = pos }\n                    | (_, endLine, startCol) :: _ ->\n                        //printfn \"All modules: %A, Win module: %A\" modules m\n                        let scopeKind =\n                            match scope.Kind with\n                            | TopModule -> NestedModule\n                            | x -> x\n                        { ScopeKind = scopeKind; Pos = Pos.make (endLine + 1) startCol })","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"d8d13849-5e6f-4041-b8a8-da7a3fd94a07"},{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"},{"$":0,"Item":"8e3d8af0-5987-4429-8b9e-e537f0192955"}],"companions":[],"id":{"$":0,"Item":"76c26c6f-cd19-43a5-bcfb-751329719f87"},"expanded":true},{"name":"CommandResponse","content":"open System\n\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open FsAutoComplete.UnopenedNamespacesResolver\n//open FSharpLint.Application\n\nmodule internal CompletionUtils =\n  let map =\n    [ 0x0000,  (\"Class\", \"C\")\n      0x0003,  (\"Enum\", \"E\")\n      0x00012, (\"Struct\", \"S\")\n      0x00018, (\"Struct\", \"S\") (* value type *)\n      0x0002,  (\"Delegate\", \"D\")\n      0x0008,  (\"Interface\", \"I\")\n      0x000e,  (\"Module\", \"N\") (* module *)\n      0x000f,  (\"Namespace\", \"N\")\n      0x000c,  (\"Method\", \"M\")\n      0x000d,  (\"Extension Method\", \"M\") (* method2 ? *)\n      0x00011, (\"Property\", \"P\")\n      0x0005,  (\"Event\", \"e\")\n      0x0007,  (\"Field\", \"F\") (* fieldblue ? *)\n      0x0020,  (\"Field\", \"Fy\") (* fieldyellow ? *)\n      0x0001,  (\"Function\", \"Fc\") (* const *)\n      0x0004,  (\"Property\", \"P\") (* enummember *)\n      0x0006,  (\"Exception\", \"X\") (* exception *)\n      0x0009,  (\"Text File Icon\", \"t\") (* TextLine *)\n      0x000a,  (\"Regular File\", \"R\") (* Script *)\n      0x000b,  (\"Script\", \"s\") (* Script2 *)\n      0x0010,  (\"Tip of the day\", \"t\") (* Formula *);\n      0x00013, (\"Class\", \"C\") (* Template *)\n      0x00014, (\"Class\", \"C\") (* Typedef *)\n      0x00015, (\"Type\", \"T\") (* Type *)\n      0x00016, (\"Type\", \"T\") (* Union *)\n      0x00017, (\"Field\", \"V\") (* Variable *)\n      0x00019, (\"Class\", \"C\") (* Intrinsic *)\n      0x0001f, (\"Other\", \"o\") (* error *)\n      0x00021, (\"Other\", \"o\") (* Misc1 *)\n      0x0022,  (\"Other\", \"o\") (* Misc2 *)\n      0x00023, (\"Other\", \"o\") (* Misc3 *) ] |> Map.ofSeq\n\n  let getIcon glyph =\n    match map.TryFind (glyph / 6), map.TryFind (glyph % 6) with\n    | Some(s), _ -> s // Is the second number good for anything?\n    | _, _ -> (\"\", \"\")\n\n  let getEnclosingEntityChar = function\n    | FSharpEnclosingEntityKind.Namespace -> \"N\"\n    | FSharpEnclosingEntityKind.Module -> \"M\"\n    | FSharpEnclosingEntityKind.Class -> \"C\"\n    | FSharpEnclosingEntityKind.Exception -> \"E\"\n    | FSharpEnclosingEntityKind.Interface -> \"I\"\n    | FSharpEnclosingEntityKind.Record -> \"R\"\n    | FSharpEnclosingEntityKind.Enum -> \"En\"\n    | FSharpEnclosingEntityKind.DU -> \"D\"\n\nmodule CommandResponse =\n\n  type ResponseMsg<'T> =\n    {\n      Kind: string\n      Data: 'T\n    }\n\n  type Location =\n    {\n      File: string\n      Line: int\n      Column: int\n    }\n\n  type CompletionResponse =\n    {\n      Name: string\n      ReplacementText: string\n      Glyph: string\n      GlyphChar: string\n    }\n\n  type ProjectResponse =\n    {\n      Project: ProjectFilePath\n      Files: List<SourceFilePath>\n      Output: string\n      References: List<ProjectFilePath>\n      Logs: Map<string, string>\n    }\n\n  type OverloadDescription =\n    {\n      Signature: string\n      Comment: string\n    }\n\n  type OverloadParameter =\n    {\n      Name : string\n      CanonicalTypeTextForSorting : string\n      Display : string\n      Description : string\n    }\n  type Overload =\n    {\n      Tip : OverloadDescription list list\n      TypeText : string\n      Parameters : OverloadParameter list\n      IsStaticArguments : bool\n    }\n  type MethodResponse =\n    {\n      Name : string\n      CurrentParameter : int\n      Overloads : Overload list\n    }\n\n  type SymbolUseRange =\n    {\n      FileName: string\n      StartLine: int\n      StartColumn: int\n      EndLine: int\n      EndColumn: int\n      IsFromDefinition: bool\n      IsFromAttribute : bool\n      IsFromComputationExpression : bool\n      IsFromDispatchSlotImplementation : bool\n      IsFromPattern : bool\n      IsFromType : bool\n    }\n\n  type SymbolUseResponse =\n    {\n      Name: string\n      Uses: SymbolUseRange list\n    }\n\n\n\n  type HelpTextResponse =\n    {\n      Name: string\n      Overloads: OverloadDescription list list\n    }\n\n  type CompilerLocationResponse =\n    {\n      Fsc: string\n      Fsi: string\n      MSBuild: string\n    }\n\n  type FSharpErrorInfo =\n    {\n      FileName: string\n      StartLine:int\n      EndLine:int\n      StartColumn:int\n      EndColumn:int\n      Severity:FSharpErrorSeverity\n      Message:string\n      Subcategory:string\n    }\n    static member OfFSharpError(e:Microsoft.FSharp.Compiler.FSharpErrorInfo) =\n      {\n        FileName = e.FileName\n        StartLine = e.StartLineAlternate\n        EndLine = e.EndLineAlternate\n        StartColumn = e.StartColumn + 1\n        EndColumn = e.EndColumn + 1\n        Severity = e.Severity\n        Message = e.Message\n        Subcategory = e.Subcategory\n      }\n\n  type ErrorResponse =\n    {\n      File: string\n      Errors: FSharpErrorInfo []\n    }\n\n  type Colorization =\n    {\n      Range: Range.range\n      Kind: string\n    }\n\n  type Declaration =\n    {\n      UniqueName: string\n      Name: string\n      Glyph: string\n      GlyphChar: string\n      IsTopLevel: bool\n      Range: Range.range\n      BodyRange : Range.range\n      File : string\n      EnclosingEntity: string\n      IsAbstract: bool\n    }\n    static member OfDeclarationItem(e:FSharpNavigationDeclarationItem, fn) =\n      let (glyph, glyphChar) = CompletionUtils.getIcon e.Glyph\n      {\n        UniqueName = e.UniqueName\n        Name = e.Name\n        Glyph = glyph\n        GlyphChar = glyphChar\n        IsTopLevel = e.IsSingleTopLevel\n        Range = e.Range\n        BodyRange = e.BodyRange\n        File = fn\n        EnclosingEntity = CompletionUtils.getEnclosingEntityChar e.EnclosingEntityKind\n        IsAbstract = e.IsAbstract\n      }\n\n  type DeclarationResponse = {\n      Declaration : Declaration;\n      Nested : Declaration []\n  }\n\n  type OpenNamespace = {\n    Namespace : string\n    Name : string\n    Type : string\n    Line : int\n    Column : int\n    MultipleNames : bool\n  }\n\n  type QualifySymbol = {\n    Name : string\n    Qualifier : string\n  }\n\n  type ResolveNamespaceResponse = {\n    Opens : OpenNamespace []\n    Qualifies: QualifySymbol []\n    Word : string\n  }\n\n  type UnionCaseResponse = {\n    Text : string\n    Position : Pos\n  }\n\n\n\n  let info (serialize : Serializer) (s: string) = serialize { Kind = \"info\"; Data = s }\n  let error (serialize : Serializer) (s: string) = serialize { Kind = \"error\"; Data = s }\n\n  let helpText (serialize : Serializer) (name: string, tip: FSharpToolTipText) =\n    let data = TipFormatter.formatTip tip |> List.map(List.map(fun (n,m) -> {Signature = n; Comment = m} ))\n    serialize { Kind = \"helptext\"; Data = { HelpTextResponse.Name = name; Overloads = data } }\n\n//  let project (serialize : Serializer) (projectFileName, projectFiles, outFileOpt, references, logMap) =\n//    let projectData =\n//      { Project = projectFileName\n//        Files = projectFiles\n//        Output = match outFileOpt with Some x -> x | None -> \"null\"\n//        References = List.sortBy IO.Path.GetFileName references\n//        Logs = logMap }\n//    serialize { Kind = \"project\"; Data = projectData }\n\n  let completion (serialize : Serializer) (decls: FSharpDeclarationListItem[]) includeKeywords =\n      serialize {  Kind = \"completion\"\n                   Data = [ for d in decls do\n                               let code = Microsoft.FSharp.Compiler.SourceCodeServices.PrettyNaming.QuoteIdentifierIfNeeded d.Name\n                               let (glyph, glyphChar) = CompletionUtils.getIcon d.Glyph\n                               yield {CompletionResponse.Name = d.Name; ReplacementText = code; Glyph = glyph; GlyphChar = glyphChar }\n                            if includeKeywords then\n                              for k in KeywordList.allKeywords do\n                                yield {CompletionResponse.Name = k; ReplacementText = k; Glyph = \"Keyword\"; GlyphChar = \"K\"}\n                          ] }\n\n  let symbolUse (serialize : Serializer) (symbol: FSharpSymbolUse, uses: FSharpSymbolUse[]) =\n    let su =\n      { Name = symbol.Symbol.DisplayName\n        Uses =\n          [ for su in uses do\n              yield { StartLine = su.RangeAlternate.StartLine\n                      StartColumn = su.RangeAlternate.StartColumn + 1\n                      EndLine = su.RangeAlternate.EndLine\n                      EndColumn = su.RangeAlternate.EndColumn + 1\n                      FileName = su.FileName\n                      IsFromDefinition = su.IsFromDefinition\n                      IsFromAttribute = su.IsFromAttribute\n                      IsFromComputationExpression = su.IsFromComputationExpression\n                      IsFromDispatchSlotImplementation = su.IsFromDispatchSlotImplementation\n                      IsFromPattern = su.IsFromPattern\n                      IsFromType = su.IsFromType } ] |> Seq.distinct |> Seq.toList }\n    serialize { Kind = \"symboluse\"; Data = su }\n\n  let help (serialize : Serializer) (data : string) =\n    serialize { Kind = \"help\"; Data = data }\n\n  let methods (serialize : Serializer) (meth: FSharpMethodGroup, commas: int) =\n      serialize {  Kind = \"method\"\n                   Data = {  Name = meth.MethodName\n                             CurrentParameter = commas\n                             Overloads =\n                              [ for o in meth.Methods do\n                                 let tip = TipFormatter.formatTip o.Description |> List.map(List.map(fun (n,m) -> {Signature = n; Comment = m} ))\n                                 yield {\n                                   Tip = tip\n                                   TypeText = o.TypeText\n                                   Parameters =\n                                     [ for p in o.Parameters do\n                                        yield {\n                                          Name = p.ParameterName\n                                          CanonicalTypeTextForSorting = p.CanonicalTypeTextForSorting\n                                          Display = p.Display\n                                          Description = p.Description\n                                        }\n                                   ]\n                                   IsStaticArguments = not o.HasParameters\n                                 }\n                              ] }\n                }\n\n  let errors (serialize : Serializer) (errors: Microsoft.FSharp.Compiler.FSharpErrorInfo[], file: string) =\n    serialize { Kind = \"errors\";\n                Data = { File = file\n                         Errors = Array.map FSharpErrorInfo.OfFSharpError errors }}\n\n  let colorizations (serialize : Serializer) (colorizations: (Range.range * SemanticClassificationType)[]) =\n    // let data = [ for r, k in colorizations do\n    //                yield { Range = r; Kind = Enum.GetName(typeof<SemanticClassificationType>, k) } ]\n    serialize { Kind = \"colorizations\"; Data = [] } //TODO: Fix colorization\n\n  let findDeclaration (serialize : Serializer) (range: Range.range) =\n    let data = { Line = range.StartLine; Column = range.StartColumn + 1; File = range.FileName }\n    serialize { Kind = \"finddecl\"; Data = data }\n\n  let declarations (serialize : Serializer) (decls : (FSharpNavigationTopLevelDeclaration * string) []) =\n     let decls' =\n      decls |> Array.map (fun (d, fn) ->\n        { Declaration = Declaration.OfDeclarationItem (d.Declaration, fn);\n          Nested = d.Nested |> Array.map ( fun a -> Declaration.OfDeclarationItem(a,fn))\n        })\n     serialize { Kind = \"declarations\"; Data = decls' }\n\n  let toolTip (serialize : Serializer) (tip) =\n    let data = TipFormatter.formatTip tip |> List.map(List.map(fun (n,m) -> {Signature = n; Comment = m} ))\n    serialize { Kind = \"tooltip\"; Data = data }\n\n  let typeSig (serialize : Serializer) (tip) =\n    let data = TipFormatter.extractSignature tip\n    serialize { Kind = \"typesig\"; Data = data }\n\n  let compilerLocation (serialize : Serializer) fsc fsi msbuild =\n    let data = { Fsi = fsi; Fsc = fsc; MSBuild = msbuild }\n    serialize { Kind = \"compilerlocation\"; Data = data }\n\n  let message (serialize : Serializer) (kind: string, data: 'a) =\n    serialize { Kind = kind; Data = data }\n\n//  let lint (serialize : Serializer) (warnings : LintWarning.Warning list) =\n//    let data = warnings |> List.toArray\n//    serialize { Kind = \"lint\"; Data = data }\n\n\n  let resolveNamespace (serialize : Serializer) (word: string, opens : (string * string * InsertContext * bool) list, qualfies : (string * string) list) =\n    let ops =\n      opens\n      |> List.map (fun (ns, name, ctx, multiple) ->\n        {\n          Namespace = ns\n          Name = name\n          Type = ctx.ScopeKind.ToString()\n          Line = ctx.Pos.Line\n          Column = ctx.Pos.Col\n          MultipleNames = multiple\n        })\n      |> List.toArray\n\n    let quals =\n      qualfies\n      |> List.map (fun (name, q) ->\n        {\n          Name = name\n          Qualifier = q\n        })\n      |> List.toArray\n\n    let data = {\n      Opens = ops\n      Qualifies = quals\n      Word = word\n    }\n\n    serialize { Kind = \"namespaces\"; Data = data}\n\n  let unionCase (serialize : Serializer) (text : string) position =\n    let data = {\n      Text = text\n      Position = position\n    }\n    serialize { Kind = \"unionCase\"; Data = data}\n","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"76c26c6f-cd19-43a5-bcfb-751329719f87"},{"$":0,"Item":"205b5e59-899b-4351-ab75-788ff73f20e7"},{"$":0,"Item":"de1ff71b-1245-4eef-816d-975da9252207"},{"$":0,"Item":"e49f4514-9b78-4a39-8b30-7289648edbb5"}],"companions":[],"id":{"$":0,"Item":"95c3cd5f-4472-4a86-9f2e-0ce0d99196e8"},"expanded":true},{"name":"Extensions","content":"open Microsoft.FSharp.Compiler.SourceCodeServices\n\n\ntype FSharpSymbol with\n    member this.IsPrivateToFile =\n        match this with\n        | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember\n        | :? FSharpEntity as m -> m.Accessibility.IsPrivate\n        | :? FSharpGenericParameter -> true\n        | :? FSharpUnionCase as m -> m.Accessibility.IsPrivate\n        | :? FSharpField as m -> m.Accessibility.IsPrivate\n        | _ -> false\n\n    member this.IsInternalToProject =\n        match this with\n        | :? FSharpParameter -> true\n        | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember || not m.Accessibility.IsPublic\n        | :? FSharpEntity as m -> not m.Accessibility.IsPublic\n        | :? FSharpGenericParameter -> true\n        | :? FSharpUnionCase as m -> not m.Accessibility.IsPublic\n        | :? FSharpField as m -> not m.Accessibility.IsPublic\n        | _ -> false","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"58592fc9-77d6-4563-8ebd-95aed86d0c82"},"expanded":true},{"name":"Commands","content":"\nopen System\nopen System.IO\nopen Microsoft.FSharp.Compiler\nopen Microsoft.FSharp.Compiler.SourceCodeServices\n//open FSharpLint.Application\n//open FsAutoComplete.UnopenedNamespacesResolver\n//open FsAutoComplete.UnionPatternMatchCaseGenerator\n\n\nmodule Response = CommandResponse\n\ntype Commands (serialize : Serializer) =\n    let checker = FSharpCompilerServiceChecker()\n    let state = State.Initial\n//    let fsharpLintConfig = ConfigurationManager.ConfigurationManager()\n\n    member private __.SerializeResultAsync (successToString: Serializer -> 'a -> Async<string>, ?failureToString: Serializer -> string -> string) =\n        Async.bind <| function\n            // A failure is only info here, as this command is expected to be\n            // used 'on idle', and frequent errors are expected.\n            | Result.Failure e -> async.Return [(defaultArg failureToString Response.info) serialize e]\n            | Result.Success r -> successToString serialize r |> Async.map List.singleton\n\n    member private x.SerializeResult (successToString: Serializer -> 'a -> string, ?failureToString: Serializer -> string -> string) =\n        x.SerializeResultAsync ((fun s x -> successToString s x |> async.Return), ?failureToString = failureToString)\n\n    member __.TryGetRecentTypeCheckResultsForFile = checker.TryGetRecentCheckResultsForFile\n    member __.TryGetFileCheckerOptionsWithLinesAndLineStr = state.TryGetFileCheckerOptionsWithLinesAndLineStr\n    member __.TryGetFileCheckerOptionsWithLines = state.TryGetFileCheckerOptionsWithLines\n    member __.Files = state.Files\n\n    member __.Parse file lines version = async {\n        let colorizations = state.ColorizationOutput\n        let parse' fileName text options =\n            async {\n                let! result = checker.ParseAndCheckFileInProject(fileName, version, text, options)\n                return\n                    match result with\n                    | Failure e -> [Response.error serialize e]\n                    | Success (parseResult, checkResults) ->\n                        match checkResults with\n                        | FSharpCheckFileAnswer.Aborted -> [Response.info serialize \"Parse aborted\"]\n                        | FSharpCheckFileAnswer.Succeeded results ->\n                            let errors = Array.append results.Errors parseResult.Errors\n                            if colorizations then\n                                [ Response.errors serialize (errors, fileName)\n                                  Response.colorizations serialize (results.GetSemanticClassification None) ]\n                            else [ Response.errors serialize (errors, fileName) ]\n            }\n        let file = Path.GetFullPath file\n        let text = String.concat \"\\n\" lines\n\n        if Utils.isAScript file then\n            let! checkOptions = checker.GetProjectOptionsFromScript(file, text)\n            state.AddFileTextAndCheckerOptions(file, lines, checkOptions)\n            return! parse' file text checkOptions\n        else\n            let! checkOptions =\n                match state.GetCheckerOptions(file, lines) with\n                | Some c -> async.Return c\n                | None -> async {\n                    let! checkOptions = checker.GetProjectOptionsFromScript(file, text)\n                    state.AddFileTextAndCheckerOptions(file, lines, checkOptions)\n                    return checkOptions\n                }\n            return! parse' file text checkOptions\n    }\n\n    member __.ParseAndCheckProjectsInBackgroundForFile file = async {\n        do checker.CheckProjectsInBackgroundForFile (file, state.FileCheckOptions.ToSeq() )\n        return [Response.errors serialize ([||], \"\") ]\n    }\n\n    member __.ParseProjectsForFile file = async {\n        let! res = checker.ParseProjectsForFile(file, state.FileCheckOptions.ToSeq())\n        return\n            match res with\n            | Failure e -> [Response.error serialize e]\n            | Success results ->\n                let errors = results |> Array.collect (fun r -> r.Errors)\n                [ Response.errors serialize (errors, file)]\n    }\n\n    // member __.FileChecked =\n    //     checker.FileChecked\n    //     |> Event.map (fun fn ->\n    //         let file = Path.GetFullPath fn\n    //         let res = state.FileCheckOptions |> Seq.tryFind (fun kv -> Path.GetFullPath kv.Key = file)\n    //         match res with\n    //         | None  -> async { return [Response.info serialize ( sprintf \"Project for file not found: %s\" file) ]  }\n    //         | Some kv ->\n    //             async {\n    //                 let result= checker.TryGetRecentCheckResultsForFile(fn, kv.Value)\n    //                 return\n    //                     match result with\n    //                     | None -> [Response.info serialize \"File not parsed\"]\n    //                     | Some res -> [ Response.errors serialize (res.GetCheckResults.Errors, file) ]\n    //             })\n\n//    member __.Project projectFileName verbose onChange = async {\n//        let projectFileName = Path.GetFullPath projectFileName\n//        let project = state.Projects.TryFind projectFileName\n//\n//        let project = project |> Option.getOrElseFun (fun _ ->\n//            let project = new Project(projectFileName, onChange)\n//            state.Projects.[projectFileName] <- project\n//            project)\n//\n//        let (|NetCoreProjectJson|NetCoreSdk|Net45|Unsupported|) file =\n//            //.NET Core Sdk preview3+ replace project.json with fsproj\n//            //Easy way to detect new fsproj is to check the msbuild version of .fsproj\n//            //  MSBuild version 15 (`ToolsVersion=\"15.0\"`) is the new project format\n//            //Post preview5 has (`Sdk=\"FSharp.NET.Sdk;Microsoft.NET.Sdk\"`), use that\n//            //  for checking .NET Core fsproj. NB: casing of FSharp may be inconsistent.\n//            //The `dotnet-compile-fsc.rsp` are created also in `preview3+`, so we can\n//            //  reuse the same behaviour of `preview2`\n//            let rec getProjectType (sr:StreamReader) limit =\n//                // only preview3-5 uses ToolsVersion='15.0'\n//                // post preview5 dropped this, check Sdk field\n//                let isNetCore (line:string) = line.Contains(\"=\\\"15.0\\\"\") || line.ToLower().Contains(\"sdk=\")\n//                if limit = 0 then\n//                    Unsupported // unsupported project type\n//                else\n//                    let line = sr.ReadLine()\n//                    if not <| line.Contains(\"ToolsVersion\") && not <| line.Contains(\"Sdk=\") then\n//                        getProjectType sr (limit-1)\n//                    else // both net45 and preview3-5 have 'ToolsVersion', > 5 has 'Sdk'\n//                        if isNetCore line then NetCoreSdk else Net45\n//            if not <| File.Exists(projectFileName) then Net45 // no such file is handled downstream\n//            elif Path.GetExtension file = \".json\" then NetCoreProjectJson // dotnet core preview 2 or earlier\n//            else\n//                use sr = File.OpenText(file)\n//                getProjectType sr 3\n//\n//\n//        return\n//            match project.Response with\n//            | Some response -> [response]\n//            | None ->\n//                let options =\n//                    match projectFileName with\n//                    | NetCoreProjectJson -> checker.TryGetProjectJsonProjectOptions projectFileName\n//                    | NetCoreSdk -> checker.TryGetCoreProjectOptions projectFileName\n//                    | Net45 -> checker.TryGetProjectOptions (projectFileName, verbose)\n//                    | Unsupported -> checker.TryGetProjectOptions (projectFileName, verbose)\n//\n//                match options with\n//                | Result.Failure error ->\n//                    project.Response <- None\n//                    [Response.error serialize error]\n//                | Result.Success (opts, projectFiles, outFileOpt, references, logMap) ->\n//                    let projectFiles = projectFiles |> List.map (Path.GetFullPath >> Utils.normalizePath)\n//                    let response = Response.project serialize (projectFileName, projectFiles, outFileOpt, references, logMap)\n//                    for file in projectFiles do\n//                        state.FileCheckOptions.[file] <- opts\n//                    project.Response <- Some response\n//                    [response]\n//    }\n//\n    member __.Declarations file version = async {\n        let file = Path.GetFullPath file\n        match state.TryGetFileCheckerOptionsWithSource file with\n        | Failure s -> return [Response.error serialize s]\n        | Success (checkOptions, source) ->\n            let! decls = checker.GetDeclarations(file, source, checkOptions, version)\n            let decls = decls |> Array.map (fun a -> a,file)\n            return [Response.declarations serialize decls]\n    }\n\n    member __.DeclarationsInProjects () = async {\n        let! decls = checker.GetDeclarationsInProjects <| state.FileCheckOptions.ToSeq()\n        return [Response.declarations serialize decls]\n    }\n\n    member __.Helptext sym =\n        match state.HelpText.TryFind sym with\n        | None -> [Response.error serialize (sprintf \"No help text available for symbol '%s'\" sym)]\n        | Some tip -> [Response.helpText serialize (sym, tip)]\n\n    member __.CompilerLocation () = [Response.compilerLocation serialize Environment.fsc Environment.fsi Environment.msbuild]\n    member __.Colorization enabled = state.ColorizationOutput <- enabled\n    member __.Error msg = [Response.error serialize msg]\n\n    member __.Completion (tyRes : ParseAndCheckResults) (pos: Pos) lineStr filter includeKeywords = async {\n        let! res = tyRes.TryGetCompletions pos lineStr filter\n        return match res with\n                | Some (decls, residue) ->\n                    let declName (d: FSharpDeclarationListItem) = d.Name\n\n                    // Send the first helptext without being requested.\n                    // This allows it to be displayed immediately in the editor.\n                    let firstMatchOpt =\n                      Array.sortBy declName decls\n                      |> Array.tryFind (fun d -> (declName d).StartsWith(residue, StringComparison.InvariantCultureIgnoreCase))\n                    let res = match firstMatchOpt with\n                                | None -> [Response.completion serialize decls includeKeywords]\n                                | Some d ->\n                                    [Response.helpText serialize (d.Name, d.DescriptionText)\n                                     Response.completion serialize decls includeKeywords]\n\n                    for decl in decls do\n                        state.HelpText.[declName decl] <- decl.DescriptionText\n                    res\n                | None -> [Response.error serialize \"Timed out while fetching completions\"]\n    }\n\n    member x.ToolTip (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetToolTip pos lineStr |> x.SerializeResult Response.toolTip\n\n    member x.Typesig (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetToolTip pos lineStr |> x.SerializeResult Response.typeSig\n\n    member x.SymbolUse (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetSymbolUse pos lineStr |> x.SerializeResult Response.symbolUse\n\n    member x.Help (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryGetF1Help pos lineStr |> x.SerializeResult Response.help\n\n    member x.SymbolUseProject (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        let fn = tyRes.FileName\n        tyRes.TryGetSymbolUse pos lineStr |> x.SerializeResultAsync (fun _ (sym, usages) ->\n            async {\n                let fsym = sym.Symbol\n                if fsym.IsPrivateToFile then\n                    return Response.symbolUse serialize (sym, usages)\n                elif fsym.IsInternalToProject then\n                    let opts = state.FileCheckOptions.[tyRes.FileName]\n                    let! symbols = checker.GetUsesOfSymbol (fn, [tyRes.FileName, opts] , sym.Symbol)\n                    return Response.symbolUse serialize (sym, symbols)\n                else\n                    let! symbols = checker.GetUsesOfSymbol (fn, state.FileCheckOptions.ToSeq(), sym.Symbol)\n                    return Response.symbolUse serialize (sym, symbols)\n            })\n\n    member x.FindDeclarations (tyRes : ParseAndCheckResults) (pos: Pos) lineStr =\n        tyRes.TryFindDeclaration pos lineStr |> x.SerializeResult (Response.findDeclaration, Response.error)\n\n    member x.Methods (tyRes : ParseAndCheckResults) (pos: Pos) (lines: LineStr[]) =\n        tyRes.TryGetMethodOverrides lines pos |> x.SerializeResult (Response.methods, Response.error)\n\n//    member __.Lint (file: SourceFilePath) = async {\n//        let file = Path.GetFullPath file\n//        let res =\n//            match state.TryGetFileCheckerOptionsWithSource file with\n//            | Failure s -> [Response.error serialize s]\n//            | Success (options, source) ->\n//                let tyResOpt = checker.TryGetRecentCheckResultsForFile(file, options)\n//\n//                match tyResOpt with\n//                | None -> [ Response.info serialize \"Cached typecheck results not yet available\"]\n//                | Some tyRes ->\n//                    match tyRes.GetAST with\n//                    | None -> [ Response.info serialize \"Something went wrong during parsing\"]\n//                    | Some tree ->\n//                        fsharpLintConfig.LoadConfigurationForProject file\n//                        let opts = fsharpLintConfig.GetConfigurationForProject (file)\n//                        let res =\n//                            Lint.lintParsedSource\n//                                { Lint.OptionalLintParameters.Default with Configuration = Some opts}\n//                                { Ast = tree\n//                                  Source = source\n//                                  TypeCheckResults = Some tyRes.GetCheckResults\n//                                  FSharpVersion = Version() }\n//                        let res' =\n//                            match res with\n//                            | LintResult.Failure _ -> [ Response.info serialize \"Something went wrong during parsing\"]\n//                            | LintResult.Success warnings -> [ Response.lint serialize warnings ]\n//\n//                        res'\n//        return res\n//    }\n\n    member __.GetNamespaceSuggestions (tyRes : ParseAndCheckResults) (pos: Pos) (line: LineStr) = async {\n        match tyRes.GetAST with\n        | None -> return [Response.info serialize \"Parsed Tree not avaliable\"]\n        | Some parsedTree ->\n        match Parsing.findLongIdents(pos.Col, line) with\n        | None -> return [Response.info serialize \"Ident not found\"]\n        | Some (_,idents) ->\n        match ParsedInput.getEntityKind parsedTree pos with\n        | None -> return [Response.info serialize \"EntityKind not found\"]\n        | Some entityKind ->\n\n        let symbol = Lexer.getSymbol pos.Line pos.Col line SymbolLookupKind.Fuzzy [||]\n        match symbol with\n        | None -> return [Response.info serialize \"Symbol at position not found\"]\n        | Some sym ->\n\n        let! entitiesRes = tyRes.GetAllEntities ()\n        match entitiesRes with\n        | None -> return [Response.info serialize \"Something went wrong\"]\n        | Some entities ->\n            let isAttribute = entityKind = EntityKind.Attribute\n            let entities =\n                entities |> List.filter (fun e ->\n                    match entityKind, e.Kind with\n                    | EntityKind.Attribute, EntityKind.Attribute\n                    | EntityKind.Type, (EntityKind.Type | EntityKind.Attribute)\n                    | EntityKind.FunctionOrValue _, _ -> true\n                    | EntityKind.Attribute, _\n                    | _, EntityKind.Module _\n                    | EntityKind.Module _, _\n                    | EntityKind.Type, _ -> false)\n\n            let entities =\n                entities\n                |> List.collect (fun e ->\n                      [ yield e.TopRequireQualifiedAccessParent, e.AutoOpenParent, e.Namespace, e.CleanedIdents\n                        if isAttribute then\n                            let lastIdent = e.CleanedIdents.[e.CleanedIdents.Length - 1]\n                            if e.Kind = EntityKind.Attribute && lastIdent.EndsWith \"Attribute\" then\n                                yield\n                                    e.TopRequireQualifiedAccessParent,\n                                    e.AutoOpenParent,\n                                    e.Namespace,\n                                    e.CleanedIdents\n                                    |> Array.replace (e.CleanedIdents.Length - 1) (lastIdent.Substring(0, lastIdent.Length - 9)) ])\n            let createEntity = ParsedInput.tryFindInsertionContext pos.Line parsedTree (idents |> List.toArray)\n            let word = sym.Text\n            let candidates = entities |> Seq.collect createEntity |> Seq.toList\n\n            let openNamespace =\n                candidates\n                |> Seq.choose (fun (entity, ctx) -> entity.Namespace |> Option.map (fun ns -> ns, entity.Name, ctx))\n                |> Seq.groupBy (fun (ns, _, _) -> ns)\n                |> Seq.map (fun (ns, xs) ->\n                    ns,\n                    xs\n                    |> Seq.map (fun (_, name, ctx) -> name, ctx)\n                    |> Seq.distinctBy (fun (name, _) -> name)\n                    |> Seq.sortBy fst\n                    |> Seq.toArray)\n                |> Seq.collect (fun (ns, names) ->\n                    let multipleNames = names |> Array.length > 1\n                    names |> Seq.map (fun (name, ctx) -> ns, name, ctx, multipleNames))\n                |> Seq.toList\n\n            let qualifySymbolActions =\n                candidates\n                |> Seq.map (fun (entity, _) -> entity.FullRelativeName, entity.Qualifier)\n                |> Seq.distinct\n                |> Seq.sort\n                |> Seq.toList\n\n            return [ Response.resolveNamespace serialize (word, openNamespace, qualifySymbolActions) ]\n    }\n\n//    member __.GetUnionPatternMatchCases (tyRes : ParseAndCheckResults) (pos: Pos) (lines: LineStr[]) (line: LineStr) = async {\n//        let codeGenService = CodeGenerationService(checker, state)\n//        let doc = {\n//            Document.LineCount = lines.Length\n//            FullName = tyRes.FileName\n//            GetText = fun _ -> lines |> String.concat \"\\n\"\n//            GetLineText0 = fun i -> lines.[i]\n//            GetLineText1 = fun i -> lines.[i - 1]\n//        }\n//\n//        let! res = tryFindUnionDefinitionFromPos codeGenService pos doc\n//        match res with\n//        | None -> return [Response.info serialize \"Union at position not found\"]\n//        | Some (symbolRange, patMatchExpr, unionTypeDefinition, insertionPos) ->\n//\n//        if shouldGenerateUnionPatternMatchCases patMatchExpr unionTypeDefinition then\n//            let result = formatMatchExpr insertionPos \"$1\" patMatchExpr unionTypeDefinition\n//            let pos = {\n//                Col = insertionPos.InsertionPos.Column\n//                Line = insertionPos.InsertionPos.Line\n//            }\n//            return [Response.unionCase serialize result pos ]\n//        else\n//            return [Response.info serialize \"Union at position not found\"]\n//    }","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"58592fc9-77d6-4563-8ebd-95aed86d0c82"},{"$":0,"Item":"95c3cd5f-4472-4a86-9f2e-0ce0d99196e8"},{"$":0,"Item":"032c8d14-697f-45c9-a306-1e0e3f275d72"},{"$":0,"Item":"1a3fb4d0-2291-4f98-805f-9eff6b63a3b4"}],"companions":[],"id":{"$":0,"Item":"1002c4bd-6116-45e3-9982-e1b0b4b01ec8"},"expanded":true},{"name":"Program","content":"//#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.IO\nopen Microsoft.FSharp.Compiler\n\nmodule internal Main =\n  open System.Collections.Concurrent\n\n  let originalFs = AbstractIL.Internal.Library.Shim.FileSystem\n  let writeJson = sprintf \"%A\"\n  let commands = Commands writeJson\n  let fs = new FileSystem(originalFs, commands.Files.TryFind)\n  AbstractIL.Internal.Library.Shim.FileSystem <- fs\n  //let commandQueue = new BlockingCollection<Command>(10)\n\n  let main () : int =\n    let mutable quit = false\n\n    while not quit do\n      async {\n          match commandQueue.Take() with\n          | Parse (file, kind, lines) ->\n              let! res = commands.Parse file lines 0\n              //Hack for tests\n              let r = match kind with\n                      | Synchronous -> Response.info writeJson \"Synchronous parsing started\"\n                      | Normal -> Response.info writeJson \"Background parsing started\"\n              return r :: res\n\n          | Project (file, verbose) ->\n              return! commands.Project file verbose (fun fullPath -> commandQueue.Add(Project (fullPath, verbose)))\n          | Declarations file -> return! commands.Declarations file None\n          | HelpText sym -> return commands.Helptext sym\n          | PosCommand (cmd, file, lineStr, pos, _timeout, filter) ->\n              let file = Path.GetFullPath file\n              match commands.TryGetFileCheckerOptionsWithLines file with\n              | Failure s -> return [Response.error writeJson s]\n              | Success options ->\n                  let projectOptions, lines = options\n                  let ok = pos.Line <= lines.Length && pos.Line >= 1 &&\n                           pos.Col <= lineStr.Length + 1 && pos.Col >= 1\n                  if not ok then\n                      return [Response.error writeJson \"Position is out of range\"]\n                  else\n                    // TODO: Should sometimes pass options.Source in here to force a reparse\n                    //       for completions e.g. `(some typed expr).$`\n                    let tyResOpt = commands.TryGetRecentTypeCheckResultsForFile(file, projectOptions)\n                    match tyResOpt with\n                    | None -> return [ Response.info writeJson \"Cached typecheck results not yet available\"]\n                    | Some tyRes ->\n                        return!\n                            match cmd with\n                            | Completion -> commands.Completion tyRes pos lineStr filter false\n                            | ToolTip -> commands.ToolTip tyRes pos lineStr\n                            | TypeSig -> commands.Typesig tyRes pos lineStr\n                            | SymbolUse -> commands.SymbolUse tyRes pos lineStr\n                            | FindDeclaration -> commands.FindDeclarations tyRes pos lineStr\n                            | Methods -> commands.Methods tyRes pos lines\n                            | SymbolUseProject -> commands.SymbolUseProject tyRes pos lineStr\n\n          | CompilerLocation -> return commands.CompilerLocation()\n          | Colorization enabled -> commands.Colorization enabled; return []\n          | Lint filename -> return! commands.Lint filename\n          | Error msg -> return commands.Error msg\n          | Quit ->\n              quit <- true\n              return []\n      }\n      |> Async.Catch\n      |> Async.RunSynchronously\n      |> function\n         | Choice1Of2 res -> res |> List.iter Console.WriteLine\n         | Choice2Of2 exn ->\n            exn\n            |> sprintf \"Unexpected internal error. Please report at https://github.com/fsharp/FsAutoComplete/issues, attaching the exception information:\\n%O\"\n            |> Response.error writeJson\n            |> Console.WriteLine\n    0\n\n  [<EntryPoint>]\n  let entry args =\n    System.Threading.ThreadPool.SetMinThreads(8, 8) |> ignore\n    Console.InputEncoding <- Text.Encoding.UTF8\n    Console.OutputEncoding <- new Text.UTF8Encoding(false, false)\n    let extra = Options.p.Parse args\n    if extra.Count <> 0 then\n      printfn \"Unrecognised arguments: %s\" (String.concat \",\" extra)\n      1\n    else\n      try\n        async {\n          while true do\n            commandQueue.Add (CommandInput.parseCommand(Console.ReadLine()))\n        }\n        |> Async.Start\n\n        main()\n      finally\n        (!Debug.output).Close()","parent":{"$":0,"Item":"40789dbb-34ba-4490-96d0-d0c1848dfad6"},"predecessors":[{"$":0,"Item":"1002c4bd-6116-45e3-9982-e1b0b4b01ec8"},{"$":0,"Item":"1a3fb4d0-2291-4f98-805f-9eff6b63a3b4"},{"$":0,"Item":"3497daa6-5fa6-4bb3-b2bc-8af00e1d1995"}],"companions":[],"id":{"$":0,"Item":"6653d6a0-75e7-4116-bce2-620df1f2c31a"},"expanded":true},{"name":">>>>Invoke Commands","content":"let input = \"\"\"\n@r @@\"FSharp.Compiler.Service.dll\"\n@if INTERACTIVE\n//#I @\"../WebServer/bin\"\nmodule FSharpStationMD   =\n@else\nnamespace FSharpStationNS\n@nowarn \"1182\"\n@endif\n\n// Code to be evaluated using FSI: `Evaluate F#`\n//@ 1 \"SNIPP.fsx\"\n    module Snippets =\n      open System\n      open Microsoft.FSharp.Compiler\n      open Microsoft.FSharp.Compiler.SourceCodeServices\n      \n      // Create an interactive checker instance \n      let checker = FSharpChecker.Create()\n      \n      // Sample input as a multi-line string\n      let input = \"\"\n      // Split the input & define file name\n      let inputLines = input.Split('\\n')\n      let file = \"/home/user/Test.fsx\"\n      \n      async {\n          let! projOptions, errors           = checker.GetProjectOptionsFromScript(file, input)\n          let! parseResults, checkFileAnswer = checker.ParseAndCheckFileInProject(file, 0, input, projOptions) \n          let! tip                           =\n              match checkFileAnswer with\n              | FSharpCheckFileAnswer.Succeeded res -> async { let! tip = res.GetToolTipTextAlternate(4, 13, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier) \n                                                               return sprintf \"%A\" tip                              }\n              | res                                 -> async { return sprintf \"Parsing did not finish... (%A)\" res }      \n          printfn \"%s\" tip\n      } |> Async.RunSynchronously\n\"\"\"              .Replace(\"@\", \"#\").Replace(\"##\", \"@\")\n// Split the input & define file name \"\nlet inputLines = input.Split('\\n')\n\nopen FSharpStationMD.FSAutoComplete\nopen FSharpStationMD.FSAutoComplete.Utils\nopen System.IO\nmodule Response = CommandResponse\n\nlet writeJson = sprintf \"%A\"\n//let commands = Commands writeJson\n\nlet file = Path.GetFullPath \"Test.fsx\"\nlet pos  = Pos.make 19 35\n//printfn \"%A\"  <| commands.CompilerLocation()\n\nasync {\n//    let! res   = commands.Parse file inputLines 0\n//    printfn \"%d %A\" res.Length res\n    match commands.TryGetFileCheckerOptionsWithLinesAndLineStr (file, pos) with\n    | Failure s -> return [Response.error writeJson s]\n    | Success(projectOptions, lines, lineStr) ->\n    do  printfn \">%s\" lineStr\n    let tyResOpt = commands.TryGetRecentTypeCheckResultsForFile(file, projectOptions)\n    match tyResOpt with\n    | None       -> return  [ Response.info writeJson \"Cached typecheck results not yet available\"]\n    | Some tyRes -> return!   commands.ToolTip tyRes pos lineStr\n} \n|> Async.RunSynchronously\n|> printfn \"%A\"","predecessors":[],"companions":[],"id":{"$":0,"Item":"d5d1c9fc-856e-44fd-aa74-9a8e88c3818f"},"expanded":true},{"name":"WebSharper Code","content":"(*\n Code to be Compiled to Javascript and run in the browser\n using `Compile WebSharper` or `Run WebSharper`\n*)","parent":{"$":0,"Item":"bf864f3c-1370-42f2-ac8a-565a604892e8"},"predecessors":[{"$":0,"Item":"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}],"companions":[],"id":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"expanded":true},{"name":"open WebSharper","content":"#define WEBSHARPER\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Client\ntype on   = WebSharper.UI.Next.Html.on\ntype attr = WebSharper.UI.Next.Html.attr\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},"expanded":true},{"name":"","content":"#nowarn \"1182\"\n[<JavaScript>]\nmodule HtmlNode      =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"expanded":false},{"name":"","content":"[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa     |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View\n\n\n    type HelperType = HelperType with\n        static member inline (&>) (HelperType, a : string      ) = Constant  a\n        static member (&>) (HelperType, a : bool        ) = Constant  a\n        static member (&>) (HelperType, a : int         ) = Constant  a\n        static member (&>) (HelperType, a : float       ) = Constant  a\n        static member (&>) (HelperType, a : Doc         ) = Constant  a\n        static member (&>) (HelperType, va: Val<string> ) =          va\n        static member (&>) (HelperType, va: Val<bool  > ) =          va\n        static member (&>) (HelperType, va: Val<int   > ) =          va\n        static member (&>) (HelperType, va: Val<float > ) =          va\n        static member (&>) (HelperType, va: Val<Doc   > ) =          va\n        static member (&>) (HelperType, va: Val<_     > ) =          va\n        static member (&>) (HelperType, vr: IRef<_    > ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_    > ) = Dynamic  vw\n\n    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"FSharpStationNS.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n\n    [< Inline >]\n    let inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n    \n        contentVar.View |> View.Sink (fun v -> !changingIRefO |> Option.iter (fun r -> if r.Value <> v then r.Value <- v))\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun v -> contentVar.Value <- v)\n        contentVar\n    \n    let inline toDoc       v           = toView      (fixit v ) |> Doc.EmbedView\n    [< Inline >]\n    let inline bindIRef f  v           = bindIRef0 f (fixit v   |> toView)\n    let inline iter     f  v           = iterV     f (fixit v )\n    let inline bind     f  v           = bindV     f (fixit v )\n    let inline map      f  v           = mapV      f (fixit v )\n    let inline map2     f  v1 v2       = map2V     f (fixit v1) (fixit v2)\n    let inline map3     f  v1 v2 v3    = map3V     f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4     f  v1 v2 v3 v4 = map4V     f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n    let inline sink     f  v           = fixit v |> toView |> View.Sink f\n\n    let inline iter2    f  v1 v2       = map2      f v1 v2       |> iterV id\n    let inline iter3    f  v1 v2 v3    = map3      f v1 v2 v3    |> iterV id\n    let inline iter4    f  v1 v2 v3 v4 = map4      f v1 v2 v3 v4 |> iterV id\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement   of name: string * children: HtmlNode seq\n    | HtmlAttribute of name: string * value:    Val<string>\n    | HtmlText      of Val<string>\n    | HtmlEmpty\n    | SomeDoc       of Doc\n    | SomeAttr      of Attr\n    \nlet addClass    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\nlet removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\nlet callAddClass = addClass \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV name value\n    | SomeAttr             value     -> Some <|                value\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement(name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText    vtext           -> Some <| Val.tagDoc WebSharper.UI.Next.Html.text vtext\n    | SomeDoc     doc             -> Some <| doc\n    | _                           -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet mapHtmlElement f element =\n    match element with\n    | HtmlElement(name, children) -> f name  children\n    | _                           -> element\n\nlet getAttr attr element =\n    match element with\n    | HtmlElement(_, children) -> children\n    | _                        -> seq []\n    |> getAttrChildren attr\n\nlet getClass = getAttr \"class\"\nlet getStyle = getAttr \"style\"\n\nlet replaceAttribute att (children: HtmlNode seq) newVal =\n    HtmlAttribute(att, newVal)\n    :: (children\n        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n        |> Seq.toList\n       )\n\nlet replaceAtt att node newVal = mapHtmlElement (fun n ch -> HtmlElement(n, replaceAttribute att ch newVal)) node\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    member inline   this.Class          clas = Val.fixit clas |> replaceAtt \"class\" this\n    member          this.AddChildren    add  = mapHtmlElement (fun n ch -> HtmlElement(n, Seq.append ch  add )) this\n    member          this.InsertChildren add  = mapHtmlElement (fun n ch -> HtmlElement(n, Seq.append add ch  )) this\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"companions":[],"id":{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"},"expanded":true},{"name":"","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline htmlElement   name ch = HtmlElement  (name, ch           )\nlet inline htmlAttribute name v  = HtmlAttribute(name, Val.fixit v  )\nlet inline htmlText      txt     = HtmlText     (      Val.fixit txt)\nlet inline someElt       elt     = SomeDoc      (elt :> Doc         )    \n  \nlet inline ul          ch = htmlElement   \"ul\"          ch\nlet inline li          ch = htmlElement   \"li\"          ch\nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\nlet inline body        ch = htmlElement   \"body\"        ch\n\n\nlet inline href        v  = htmlAttribute \"href\"        v\nlet inline rel         v  = htmlAttribute \"rel\"         v\nlet inline src         v  = htmlAttribute \"src\"         v\nlet inline ``class``   v  = htmlAttribute \"class\"       v\nlet inline ``type``    v  = htmlAttribute \"type\"        v\nlet inline width       v  = htmlAttribute \"width\"       v\nlet inline title       v  = htmlAttribute \"title\"       v\nlet inline Id          v  = htmlAttribute \"id\"          v\nlet inline frameborder v  = htmlAttribute \"frameborder\" v\nlet inline spellcheck  v  = htmlAttribute \"spellcheck\"  v\nlet inline draggable   v  = htmlAttribute \"draggable\"   v\nlet inline style       v  = htmlAttribute \"style\"       v\n\nlet inline style1    n v  = style <| Val.map ((+) (n + \":\")) v\n\nlet inline css         v  = styleH [ htmlText v ] \n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet inline ``xclass`` v  = \n    match Val.fixit v with\n    | Constant c  -> Attr.Class        c       \n    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\nlet composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElem v  = Doc.BindView (hElem >> renderDoc)  (Val.toView <| Val.fixit v)            |> SomeDoc\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"}],"companions":[],"id":{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"},"expanded":true},{"name":"","content":"[< Inline >]\nlet inline storeVar<'T> storeName (var:IRef<_>) =\n    JS.Window.LocalStorage.GetItem storeName |> fun v -> if v <> null then           var.Value <- Json.Deserialize<'T> v\n    Val.sink (fun v -> JS.Window.LocalStorage.SetItem (storeName, Json.Serialize v)) var\n\n[< Inline \"\"\"(!$v)\"\"\">]\nlet isUndefined v = true","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},"expanded":true},{"name":"LoadFiles","content":"[< Inline \"CIPHERSpaceLoadFiles($files, $cb)\" >]\nlet LoadFiles (files: string []) (cb: unit -> unit) : unit = X<_>","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}],"companions":[],"id":{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},"expanded":true},{"name":"","content":"open HtmlNode","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}],"companions":[],"id":{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},"expanded":true},{"name":"","content":"[<JavaScript>]\nmodule Template      =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}],"companions":[],"id":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"expanded":false},{"name":"","content":"let container content = div <| [ ``class`` \"container\" ] @ content","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\" \n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ]\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : IRef<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                            }\n  static member  New(v)   = Input.New(Var.Create v)\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Var              = this.var","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : IRef<bool>\n    content    : HtmlNode seq\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n        content    = []\n    }\n  static member  Demo  = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n        content    = [ style \"flex-flow: column;\"\n                     ]\n    }\n  member        this.Render          =\n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  this.content\n    |> div\n  member inline this.Content    c = { this with content    =       c }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"}],"companions":[],"id":{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    spellcheck  : Val<bool>\n    id          : string\n    var         : IRef<string>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              spellcheck  = Val.fixit false\n                              id          = \"\"\n                              var         = var \n                            }\n  static member  New(v)   = TextArea.New(Var.Create v)\n  member        this.Render    =    \n    someElt \n    <| Doc.InputArea\n        [ \n          _class              this._class\n          attr.id             this.id  \n          atr \"spellcheck\" <| Val.map (fun spl -> if spl then \"true\" else \"false\") this.spellcheck\n          atr \"title\"         this.title\n          atr \"style\"        \"height: 100%;  width: 100%\"\n          _placeholder        this.placeholder \n        ]\n        this.var\n    |> Seq.singleton |> span\n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Spellcheck  spl  = { this with spellcheck  = spl            }\n  member inline this.Id          id   = { this with id          = id             }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Var              = this.var\n  ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},"expanded":true},{"name":"","content":"let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n//      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"                 \n   |]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"},"expanded":true},{"name":"","content":"type CodeMirrorEditor() =\n    let a = 1\n  with\n    [< Inline \"CodeMirror($elt, {\n\t    theme        : 'rubyblue'\n\t  , lineNumbers  : true\n\t  , matchBrackets: true\n      , extraKeys    : {\n\t\t    Tab  : function (cm) { cm.replaceSelection('    ', 'end'); }\n\t\t  , 'F11': function (cm) { cm.setOption('fullScreen', !cm.getOption('fullScreen')); }\n        }\n})\"    >]\n//    [< Inline \"setupEditor($elt)\" >]\n    static member SetupEditor elt                               : CodeMirrorEditor = X<_>\n    [< Inline \"$this.getValue()\"              >]\n    member this.GetValue()                                      : string     = X<_>\n    [< Inline \"$this.setValue($v)\"            >]\n    member this.SetValue (v:string)                             : unit       = X<_>\n    [< Inline \"$this.getDoc().markText({line:$fl, ch:$fc}, {line:$tl, ch:$tc}, {className: $className, title: $title})\" >]\n    member this.MarkText (fl:int, fc:int) (tl:int, tc:int) (className: string) (title: string): unit       = X<_>\n    [< Inline \"while($this.getAllMarks().length > 0) { $this.getAllMarks()[0].clear() }\" >]\n    member this.RemoveMarks() : unit       = X<_>\n    [< Inline \"$this.getDoc().clearHistory()\" >]\n    member this.ClearHistory()                                  : unit       = X<_>\n    [< Inline \"$this.on($event, $f)\"          >]\n    member this.On(event: string, f:(CodeMirrorEditor * obj) -> unit) : unit     = X<_>\n\n[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class          : Val<string>\n    style           : Val<string>\n    id              : string\n    var             : IRef<string>\n    onChange        : (unit -> unit)\n    mutable editorO : CodeMirrorEditor option\n} with\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        style    = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n        editorO  = None\n      }\n  static member  New(v)   = CodeMirror.New(Var.Create v)\n  member        this.Render    =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          style                this.style\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                  LoadFiles codeMirrorIncludes\n                    (fun () ->                       \n                       let editor = CodeMirrorEditor.SetupEditor el\n                       this.editorO <- Some editor\n                       editor.On(\"change\", fun (cm, change) -> \n                           let v = editor.GetValue() \n                           if this.var.Value <> v then this.var.Value <- v; this.onChange() )\n                       this.var.View |> View.Sink (fun v -> if editor.GetValue() <> v then editor.SetValue v ; editor.ClearHistory())\n                    )\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/theme/rubyblue.css\"           ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          css  \".CodeMirror { height: 100% }\"\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.Style    sty  = { this with style     = Val.fixit sty  }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.Var           = this.var\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"companions":[],"id":{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},"expanded":true},{"name":"type SplitterBar = {","content":"[<NoComparison ; NoEquality>]\ntype HtmlMeasure =\n| Percentage of Val<float>\n| Pixel      of Val<float>\n\n[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : IRef<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    children         : HtmlNode seq\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New(var) = \n        {\n            value    = var\n            min      = Val.fixit  10.0\n            max      = Val.fixit  75.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            children = []\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    static member New(value)    = SplitterBar.New(Var.Create value)\n    member        this.Var      = this.value\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging _ (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                Val.map2 (fun startP dirV ->\n                    this.dragging <- true\n                    this.startVer <- dirV\n                    this.startP   <- startP\n                    this.start    <- mouseCoord ev\n                    this.size     <- size()\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                ) this.GetValue this.vertical\n                |> Val.iter id\n        this.node\n          .AddChildren(\n          [\n            ``class`` <| Val.map (fun ver -> if ver then \"Vertical\" else \"Horizontal\") this.vertical \n            SomeAttr  <| on.mouseDown startDragging\n            SomeAttr  <| on.afterRender (fun el -> this.domElem <- Some el)\n            css \"\n                .Splitter.Vertical   { cursor: col-resize; background-color: #eef ; width : 5px ; margin-left:-7px; }\n                .Splitter.Horizontal { cursor: row-resize; background-color: #eef ; height: 5px ; margin-top :-7px; }\n            \"\n          ])\n          .AddChildren this.children\n    member inline this.Value       v =   this.value.Value <- v  ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }\n    member inline this.Children   ch = { this with children     = ch                          }\n    ","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},"expanded":true},{"name":"type Grid","content":"[<NoComparison ; NoEquality>]\ntype Area =\n| Auto     of SplitterBar\n| Fixed    of HtmlMeasure\n| Splitter of SplitterBar\n\n[< Inline \"new ResizeObserver($f).observe($el)\" >]\nlet resizeObserver (f: unit->unit) (el:Dom.Element) = X<_> \n\n[<NoComparison ; NoEquality>]\ntype Grid = {\n    padding       : float\n    gap           : float\n    content       : (string option * HtmlNode) []\n    cols          : Area []\n    rows          : Area []\n    width         : Var<float>\n    height        : Var<float>\n    lastSplitter  : (int * bool) option\n}\nwith\n    static member New = {\n       padding       = 9.0\n       gap           = 9.0\n       cols          = [| |]\n       rows          = [| |]\n       content       = [| |]\n       width         = Var.Create 1000.0\n       height        = Var.Create  100.0\n       lastSplitter  = None\n    }\n    member this.NewSplitter  (f: float)  col =\n        let spl = SplitterBar.New(f)\n        if col then\n            { this with lastSplitter = Some (this.cols.Length, col) ; cols = Array.append this.cols [| spl              |> Splitter |] }\n        else \n            { this with lastSplitter = Some (this.rows.Length, col) ; rows = Array.append this.rows [| spl.Horizontal() |> Splitter |] }\n    member inline this.ColFixedPx   f              = { this with cols    = Array.append this.cols    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.ColFixed     f              = { this with cols    = Array.append this.cols    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.ColVariable (s:SplitterBar) = { this with cols    = Array.append this.cols    [| s                                    |> Splitter |] }\n    member inline this.ColVariable (f:float)       = this.NewSplitter f true\n    member inline this.ColAuto     (f:float)       = { this with cols    = Array.append this.cols    [| SplitterBar.New(     f)              |> Auto     |] }\n    member inline this.RowFixedPx   f              = { this with rows    = Array.append this.rows    [| Pixel     (Val.fixit f)              |> Fixed    |] }\n    member inline this.RowFixed     f              = { this with rows    = Array.append this.rows    [| Percentage(Val.fixit f)              |> Fixed    |] }\n    member inline this.RowVariable (s:SplitterBar) = { this with rows    = Array.append this.rows    [| s                                    |> Splitter |] }\n    member inline this.RowVariable (f:float)       = this.NewSplitter f false\n    member inline this.RowAuto     (f:float)       = { this with rows    = Array.append this.rows    [| SplitterBar.New(     f).Horizontal() |> Auto     |] }\n    member        this.Content (area, html)        = { this with content = Array.append this.content [| Some area, html                                  |] }\n    member        this.Content        html         = { this with content = Array.append this.content [| None     , html                                  |] }\n    member inline this.Padding      f              = { this with padding = f                                                                                }\n    member inline this.Gap          f              = { this with gap     = f                                                                                }\n    member this.changeSplitter f =\n        this.lastSplitter\n        |> Option.iter (fun (pos, col) ->\n            if col then\n                match this.cols.[pos] with\n                | Splitter spl -> this.cols.[pos] <- Splitter <| f spl \n                | _            -> ()\n            else \n                match this.rows.[pos] with\n                | Splitter spl -> this.rows.[pos] <- Splitter <| f spl \n                | _            -> ()\n        )\n        this\n    member        this.Before                = this.changeSplitter (fun spl -> spl.Before     )\n    member inline this.Max                 v = this.changeSplitter (fun spl -> spl.Max       v)\n    member inline this.Min                 v = this.changeSplitter (fun spl -> spl.Min       v)\n    member inline this.Children           ch = this.changeSplitter (fun spl -> spl.Children ch)\n    member this.style    (areas:Area[]) size =\n        if areas.Length = 0 then Val.Constant \"100%\" else\n        let pcs, pxs = \n            areas \n            |> Seq.fold (fun (pcs, pxs) a ->\n                match a with\n                | Auto              spl -> (                          pcs,                pxs)          \n                | Splitter          spl -> (Val.map2 (+) spl.GetValue pcs,                pxs) \n                | Fixed (Percentage v)  -> (Val.map2 (+) v            pcs,                pxs)\n                | Fixed (Pixel      v)  -> (                          pcs, Val.map2 (+) v pxs)\n            ) (Val.Constant 0.0, Val.Constant 0.0)\n        let finalPerc = Val.map2 (fun v size -> (size - this.padding * 2. - this.gap * ((float areas.Length) - 1.) - v) / (size - this.padding * 2.)) pxs size\n        let autoPct   = Val.map  ((-) 100.0)  pcs \n        let perc   pc = Val.map2 (fun finalPerc pc -> finalPerc * pc |> max 0.0 |> sprintf \"%f%%\") finalPerc pc\n        let pixel  px = Val.map  (fun           px ->             px |> max 0.0 |> sprintf \"%fpx\")           px\n        areas\n        |> Seq.foldBack (fun a state ->\n            match a with\n            |  Auto              spl -> perc  autoPct          \n            |  Splitter          spl -> perc  spl.GetValue\n            |  Fixed (Percentage v)  -> perc  v\n            |  Fixed (Pixel      v)  -> pixel v\n            |> Val.map2(fun state v -> v::state) state\n           )  <| (Val.Constant [])\n        |> Val.map (String.concat \" \")\n    member this.styles() =\n        [ style1 \"grid-template-columns\" <| this.style this.cols this.width\n          style1 \"grid-template-rows\"    <| this.style this.rows this.height\n        ]\n    member this.GridTemplate() =\n        [ \n            yield!\n                this.content\n                |> Seq.map (fun (area, html) ->\n                    match area with\n                    | None   -> html\n                    | Some a -> html.AddChildren([ style <| sprintf \"grid-area: %s\" a ])\n                   )\n            yield!\n                this.cols\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-column\" (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-row\"    (sprintf \"1 / %d\" (this.rows.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield!\n                this.rows\n                |> Seq.indexed\n                |> Seq.choose (function\n                    | i, Auto     spl -> None           \n                    | i, Splitter spl -> Some <| spl.Render.InsertChildren( \n                                            [ style1 \"grid-row\"    (string (i + if spl.after then 2 else 1))\n                                              style1 \"grid-column\" (sprintf \"1 / %d\" (this.cols.Length + 1)) ] ) \n                    | i, Fixed    _   -> None\n               )\n            yield! this.styles() \n            yield style    <| sprintf \"display: grid; grid-gap: %fpx; padding: %fpx; box-sizing: border-box\" this.gap this.padding \n            yield SomeAttr <| on.afterRender(fun el   -> \n                let setDimensions () =\n                    this.width.Value  <- el.GetBoundingClientRect().Width\n                    this.height.Value <- el.GetBoundingClientRect().Height\n                JS.SetTimeout setDimensions 60 |> ignore\n                resizeObserver setDimensions el\n              ) \n        ]\n    member this.Render =\n        div <| this.GridTemplate()","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"companions":[],"id":{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},"expanded":true},{"name":"","content":"[<JavaScript>]\nmodule RunCode       =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1095ae38-19fc-4195-840c-c368a3a486c4"}],"companions":[],"id":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"expanded":false},{"name":"","content":"#r @\"ZafirTranspiler.dll\"\nmodule EditorRpc =\n    let callRPC asy callback =\n        Async.StartWithContinuations(asy, callback, (fun e -> JS.Alert(e.ToString()) ), fun c -> JS.Alert(c.ToString()))\n\n    let checkSource  callback          source = CIPHERPrototype.Editor.checkSource  source          |> callRPC <| callback\n    let methods      callback line col source = CIPHERPrototype.Editor.methods      source line col |> callRPC <| callback\n    let declarations callback line col source = CIPHERPrototype.Editor.declarations source line col |> callRPC <| callback\n    let translate    callback minified source = CIPHERPrototype.Editor.translate    source minified |> callRPC <| callback\n    let evaluate     callback          source = CIPHERPrototype.Editor.evaluate     source          |> callRPC <| callback\n\nlet completeJS js = \n  \"\"\"\n    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      try { window[key].$cctor(); } catch (e) {} \n  } \n})\n                 \"\"\" + js\n\nlet compile fThen fFail code =\n    EditorRpc.translate \n        <| (fun (jsO, msgs) ->\n             jsO\n             |> Option.map completeJS\n             |> function\n             | Some js -> fThen  msgs   js\n             | None    -> fFail  msgs\n            )\n        <| false <| code\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},"expanded":true},{"name":"","content":"type RunNode(nodeName, ?clearNode: bool) =\n  let bClearNode    = defaultArg clearNode true\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      match baseNode.ShadowRoot with\n      | null -> let e = JS.Document.CreateElement \"div\"\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild e |> ignore\n                e?style <- \"height: 100%; width: 100%;\"\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool) = RunNode(\"TestNode\", defaultArg clearNode true)\n  member this.RunNode   = runNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},"expanded":true},{"name":"AddBootstrap","content":"  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n          @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n           \"\n        runNode.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"companions":[],"id":{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},"expanded":true},{"name":"RunDoc","content":"  member inline this.RunDoc  doc  = doc  :> Doc       |> Doc.Run this.RunNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},{"$":0,"Item":"aba6c516-0ac9-4abe-95a2-7257d077e338"}],"companions":[],"id":{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"},"expanded":true},{"name":"RunHtml","content":"  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}],"companions":[],"id":{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},"expanded":true},{"name":"RunHtmlPlusFree","content":"  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        freeMsgs.Value <- \"Compiling to JavaScript...\"\n        freeJS.Value   <- \"\"\n        compile (fun msgs js -> freeJS.Value <- js ; runJS() ) sendMsg freeFS.Value\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"companions":[],"id":{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},"expanded":true},{"name":"ShowHtmlResult","content":"  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"companions":[],"id":{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"},"expanded":true},{"name":"ShowResult","content":"  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"}],"companions":[],"id":{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},"expanded":true},{"name":"","content":"[<JavaScript>]\nmodule FSharpStation =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"336d6f19-0c57-4af9-8716-1b3fbf6b112c"},{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"expanded":true},{"name":"","content":"type CodeSnippetId = CodeSnippetId of System.Guid        \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n\nlet snippetName name (content: string) =\n    if name <> \"\" then name else \n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\") || l.StartsWith(\"//\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\nlet sanitize n =\n    let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                    '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                    '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                    '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                    '\\\\'  ; '/'|] //\"\n    n |> String.filter (fun c -> not <| Array.contains c illegal)\n\n\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    companions   : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n} with\n    member this.Name = snippetName this.name this.content\n\n//let codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\n//let codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\nlet codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n\nlet tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n\ntype CodeSnippet \n    with\n    static member PickIO id = codeSnippets.Value |> tryPickI (fun (_, snp) -> snp.id = id)\n    static member FetchO id = codeSnippets.TryFindByKey id\n    static member FetchL id = CodeSnippet.FetchO id |> Option.toList\n    static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n    static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n    static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n    static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n    static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n    static member New(od, nm, pa, pred, co, cnt) =\n        let newS =\n            {\n                name         = nm\n                content      = cnt\n                parent       = pa\n                predecessors = pred\n                companions   = co\n                id           = CodeSnippetId.New\n                expanded     = true\n            }\n        match od, codeSnippets.Length with\n        | _, 0            -> codeSnippets.Append newS\n        | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n        | i, n when i < n -> codeSnippets.Value \n                                |> Seq.toArray\n                                |> Array.splitAt od\n                                |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                |> codeSnippets.Set \n        | _, _            -> codeSnippets.Append newS\n        newS\n    member this.UniquePredecesors() =\n        let rec preds (ins : CodeSnippetId list) outs : CodeSnippetId list =\n            match ins with\n            | []         -> outs\n            | hd :: rest -> List.collect id [ rest ; hd |> CodeSnippet.FetchL |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            |> preds <| if outs |> Seq.contains hd then outs else hd::outs\n        preds [ this.id ] []\n    member this.Level() =\n        let rec level snp out = \n            snp.parent\n            |> Option.bind CodeSnippet.FetchO\n            |> Option.map (fun p -> level p <| out + 1) \n            |> Option.defaultValue out\n        level this 0\n    member this.NameSanitized =\n        this.Name\n        |> sanitize\n        |> (fun c -> \"F# \" + c + \".fsx\")\n    member this.ContentIndented() =\n        let lvl = this.Level()\n        if lvl = 0 || lvl = 1 then this.content \n        else this.content.Split('\\n')\n                |> Array.map (fun l -> if l.StartsWith \"#\" then l else  (String.replicate lvl \"  \") + l)\n                |> String.concat \"\\n\"\n        |> sprintf \"# 1 @\\\"%s %s\\\"\\n%s\" (if lvl = 0 || lvl = 1 then \"\" else sprintf\"(%d)\" (lvl * 2)) this.NameSanitized\n    member this.Code() =\n        let preds = this.UniquePredecesors() |> Seq.toArray\n        codeSnippets.Value\n        |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n        |> Seq.map    (fun snp -> snp.ContentIndented()         )\n        |> String.concat \"\\n\"\n    member this.IsDescendantOf antId =\n        let rec isDescendantOf snp =\n            match snp.parent with\n            | None       -> false\n            | Some parId ->\n            if parId = antId then true else\n            CodeSnippet.FetchO parId\n            |> Option.map isDescendantOf\n            |> Option.defaultValue false\n        isDescendantOf this\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},"expanded":true},{"name":"currentCodeSnippetId","content":"let missingVar  = Var.Create \"\"\nlet missing find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> \"\") (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\n[< Inline >]\nlet inline storeVarCodeEditor name = storeVar <| \"CodeEditor.\" + name\nstoreVarCodeEditor \"currentCodeSnippetId\" currentCodeSnippetId\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name   ) (fun s n -> { s with name    = n }) <| k\nlet curSnippetCodeOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content) (fun s n -> { s with content = n }) <| k\n    \ntype Position =\n    | Below\n    | Right\n    | Tab\n    | NewBrowser\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\nstoreVarCodeEditor \"position\" position\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"companions":[],"id":{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"},"expanded":true},{"name":"CodeEditorMain","content":"let noSelection cur = CodeSnippet.FetchO cur = None\nlet noSelectionVal  = Val.map noSelection currentCodeSnippetId\n\nlet dirty    = Var.Create false \nlet codeFS   = Var.Create \"\"\nlet codeJS   = Var.Create \"\"\nlet codeMsgs = Var.Create \"\"\n\n//storeVarCodeEditor \"dirty\" dirty\n\nlet sendMsg msg =\n    if isUndefined msg then () else\n    codeMsgs.Value  <- \n        match codeMsgs.Value, msg.ToString() with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\nlet setDirty() = dirty.Value <- true\nlet setClean() = dirty.Value <- false\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.Code())\n\nlet evalIFrameJS success failure js =\n    createIFrame (fun frame ->\n        try\n             let window   = frame?contentWindow\n             let eval   s = JS.Apply window \"eval\" [| s |]\n             eval js           |> success\n        with e -> e.ToString() |> failure\n    )\n    |> RunCode.RunNode().RunHtml\n\nlet evalWindowJS success failure js =\n    let window       = JS.Apply JS.Window \"open\" [| JS.Window.Location.Origin + \"/Main.html\" |]\n    match window with\n    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n    | _    ->\n    600 \n    |> JS.SetTimeout (fun () -> \n        try\n             let eval   s = JS.Apply window   \"eval\" [| s |]\n             //printfn \"Evaluating...\"\n             JS.Apply window   \"focus\" [|  |]\n             eval js           |> success\n        with e -> e.ToString() |> failure)\n    |> ignore\n                               \nlet runJS msgs js =\n    sendMsg \"Running JavaScript...\"\n    match position.Value with\n    | NewBrowser -> evalWindowJS\n    | _          -> evalIFrameJS\n    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n    <| js\n\nlet processSnippet msg processCode =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> \n        codeMsgs.Value <- msg\n        codeJS.Value   <- \"\"\n        let code = snp.Code()\n        codeFS.Value   <- code\n        processCode       code\n    )\n\nlet compileSnippet fThen fFail = \n    processSnippet \"Compiling to JavaScript...\" (RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail)\n\nlet compileRun  () = compileSnippet runJS                                               sendMsg\nlet justCompile () = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs)  sendMsg\nlet evaluateFS  () = \n    processSnippet \"Evaluating F# code...\" \n        (RunCode.EditorRpc.evaluate \n          (function \n           | None    , \"\"\n           | Some \"\" , \"\"   -> \"Done!\"\n           | None    , msgs -> msgs\n           | Some out, \"\"   ->               out\n           | Some out, msgs -> msgs + \"\\n\" + out\n           >> sendMsg))\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirty()\n    refreshView()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirty()\n        refreshView()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirty()\n        refreshView()\n    )\n\nlet mutable draggedId   = CodeSnippetId.New\n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"a28fe808-236e-4b7e-9509-51ebe21e35fc"},{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"}],"companions":[],"id":{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},"expanded":true},{"name":"let listEntry code =","content":"let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\nlet curPredecessors =\n    Val.map (   Option.map          (fun (snp:CodeSnippet) -> snp.UniquePredecesors())\n              >> Option.defaultValue [])  currentCodeSnippetO  \n\nlet isIndirectPredecessor pre predecessors = predecessors |> List.contains pre\n    \nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecesors()) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirty()\n        refreshView()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ \n                    ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                   code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor   code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                              )\n                    SomeAttr <| on.drag    (fun _ _  ->                                              draggedId <- code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"v\"        else \">\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (sprintf \"%dem\" <| code.Level())\n                              style  \"white-space: pre\"\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n        .Render\n\nlet listEntries snps =\n    snps\n    |> Seq.indexed\n    |> Seq.mapFold (fun expanded (i, snp) ->\n        if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n            let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n            let isExpanded  = isParent && snp.expanded\n            (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n        else  (None, expanded)\n    )  (Set [])\n    |> fst\n    |> Seq.choose (Option.map renderDoc)\n    |> Doc.Concat","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"companions":[],"id":{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},"expanded":true},{"name":"","content":"let addCode   ()   =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) -> CodeSnippet.New(i + 1, \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then\n      let root = \n          e.GetRootNode()?body \n          |> unbox\n          |> (fun (body:Dom.Element) -> if isUndefined(body) then e.GetRootNode().FirstChild :?> Dom.Element else body)\n      loadTextFile (root.QuerySelector(\"#\" + fileInputElementId))\n        (fun txt ->\n            try\n                txt\n                |> Json.Deserialize<CodeSnippet[]>\n                |> codeSnippets.Set\n                setClean()\n                refreshView()\n            with e -> JS.Alert <| e.ToString()\n        )\n\n[< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\nlet saveAs (txt:string) (name:string) = ()\n\nlet downloadFile() =\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n\nlet Do f = (fun _ _ -> f())","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"companions":[],"id":{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},"expanded":true},{"name":"","content":"let styleEditor    =\n     \"\"\"\ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n.CodeMirror { height: 100%; }\n\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n.Warning { background-color: blue      } \n.Error   { background-color: orangered } \n    \"\"\"","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"companions":[],"id":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"expanded":true},{"name":"","content":"let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n\nlet codeMirror = Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId).OnChange(setDirty ).Style(\"height: 100%\")\n\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nlet mutable prior = \"\", \"\"\n\nVal.map2 (fun msgs curO -> msgs, curO) codeMsgs currentCodeSnippetO\n|> Val.sink (fun (msgs, curO) ->\n    async {\n        match codeMirror.editorO  with\n        | None        -> () \n        | Some editor ->\n            match curO with \n            | None -> () \n            | Some cur ->\n            curSnippetNameOf cur.id\n            |> Val.iter (fun name ->\n                printfn \"RemoveMarks: %s\" name\n                if prior = (msgs, name) then () else\n                prior   <- (msgs, name)\n                editor.RemoveMarks()\n                match msgs with\n                | REGEX rex \"g\" m -> m\n                | _               -> [||]\n                |> Array.choose (fun v ->\n                    match v with\n                    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent    , int tl, int tc - int indent, sev, from , msg)\n                    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent - 1, int fl, int fc - int indent, sev, \"fsi\", msg)\n                    | _ -> None\n                )\n                |> Array.iter (fun (file, fl, fc, tl, tc, sev, from, msg) ->\n                    printfn \"inside -%s-%s-\" file (sanitize name)\n                    if file = sanitize name then\n                        100\n                        |> JS.SetTimeout (fun () ->\n                            editor.MarkText (fl - 1, fc) (tl - 1, tc) (if sev.ToUpper().StartsWith(\"ERR\") then \"Error\" else \"Warning\")  msg)\n                        |> ignore\n    \n                )\n            )\n    } |> Async.Start\n)\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"companions":[],"id":{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},"expanded":true},{"name":"Messaging","content":"type FSMessage =\n    | GetSnippetContentById of CodeSnippetId\n    | GetSnippetCodeById    of CodeSnippetId\n    | GetSnippetById        of CodeSnippetId\n    | GetSnippetContent     of string []\n    | GetSnippetCode        of string []\n    | GetSnippet            of string []\n    | GenericMessage        of string\n    | GetIdentification\n\ntype FSResponse =\n    | SnippetResponse   of CodeSnippet option\n    | StringResponse    of string option\n    | IdResponse        of CIPHERPrototype.Editor.AddressId\n\nlet fsId = CIPHERPrototype.Editor.AddressId \"FSharpStation1\"\n\nlet respondMessage fsMsg =\n    match fsMsg with\n    | GetSnippetContentById sId  -> CodeSnippet.FetchO sId |> Option.map (fun snp -> snp.Code()) |> StringResponse       \n    | GetSnippetCodeById    sId  -> CodeSnippet.FetchO sId |> Option.map (fun snp -> snp.Code()) |> StringResponse \n    | GetSnippetById        sId  -> CodeSnippet.FetchO sId                                       |> SnippetResponse \n    | GetSnippetContent     path -> StringResponse <|  Some    \"Not implemented.\"\n    | GetSnippetCode        path -> StringResponse <|  Some    \"Not implemented.\"\n    | GetSnippet            path -> StringResponse <|  Some    \"Not implemented.\"\n    | GenericMessage        txt  -> StringResponse <| (Some <| \"Message received: \" + txt)\n    | GetIdentification          -> IdResponse fsId \n\nlet awaitMessage () =\n    async {\n        while true do\n            let! msg   = CIPHERPrototype.Editor.awaitRequestFor fsId\n            let  fsMsg = msg.content |> Json.Deserialize<FSMessage>\n            let  resp  = respondMessage fsMsg\n            do!  CIPHERPrototype.Editor.replyTo msg.messageId.Value (resp |> Json.Serialize)\n    } |> Async.Start\n\nawaitMessage()    \n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},"expanded":true},{"name":"CodeEditor","content":"let spl1         = Template.SplitterBar.New(20.0).Children([ style \"grid-row: 2 / 4\" ])\nstoreVarCodeEditor \"splitterV1\" spl1.Var\n//storeVarCodeEditor \"splitterV2\" splitterV2.Var\n//storeVarCodeEditor \"splitterH3\" splitterH3.Var\nlet CodeEditor() =\n  Template.Grid.New\n     .ColVariable(spl1).ColVariable(50.0).Max(Val.map ((-) 92.0) spl1.GetValue).Children([ style \"grid-row: 3 / 5\" ]).ColAuto(0.0)\n     .RowFixedPx(34.0) .RowAuto(0.0).RowVariable(17.0).Children([ style \"grid-column: 2 / 4\" ]).Before.RowFixedPx(80.0)\n     .Padding(1.0)\n     .Content( style  \"\"\" \n                    grid-template-areas:\n                        'header0 header   header  '\n                        'sidebar content1 content1'\n                        'sidebar content2 content3'\n                        'footer  footer   footer2 ';\n                    color      : #333;\n                    height     : 100%;\n                    font-size  : small;\n                    font-family: monospace;\n                    line-height: 1.2;\n                \"\"\")\n     .Content(\"sidebar\", \n        div [ style \"overflow: auto\"\n              codeSnippets.View\n              |> View.SnapshotOn codeSnippets.Value refresh.View\n              |> View.Map listEntries\n              |> Doc.BindView id |> SomeDoc\n            ])\n     .Content(\"header\"  , Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")         .Render)\n     .Content(\"content1\", codeMirror                                                                                                   .Render)\n     .Content(\"content2\", Template.TextArea  .New(codeMsgs).Placeholder(\"Output:\"    ).Title(\"Messages\"                 )              .Render)\n     .Content(\"content3\", Template.TextArea  .New(codeJS  ).Placeholder(\"Javascript:\").Title(\"JavaScript code generated\")              .Render)\n     .Content(\"footer2\" , Template.TextArea  .New(codeFS  ).Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        )              .Render) \n     .Content(\"footer\"  ,       \n        div [ \n              Template.Button.New(\"Add code\"              ).Class(\"btn btn-xs\"     ).OnClick(Do addCode      )                          .Render\n              Template.Button.New(\"<<\"                    ).Class(\"btn btn-xs\"     ).OnClick(Do indentCodeOut).Disabled(noSelectionVal) .Render\n              Template.Button.New(\">>\"                    ).Class(\"btn btn-xs\"     ).OnClick(Do indentCodeIn ).Disabled(noSelectionVal) .Render\n              loadFileElement.Render.AddChildren([ style \"grid-column: 4/6\" ])\n              span []       \n              Template.Button.New(\"Evaluate F# (FSI)\"     ).Class(\"btn btn-xs\"     ).OnClick(Do evaluateFS   ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Get F# code ==>\"       ).Class(\"btn btn-xs\"     ).OnClick(Do getFSCode    ).Disabled(noSelectionVal) .Render\n       \n              Template.Button.New(\"Delete code\"           ).Class(\"btn btn-xs\"     ).OnClick(Do deleteCode   ).Disabled(noSelectionVal) .Render\n              span []       \n              span []       \n              Template.Button.New(\"Save as...\"            ).Class(\"btn            \").OnClick(Do downloadFile )                          .Render.AddChildren([classIf \"btn-primary\" dirty])\n              span []\n              Template.Button.New(\"Compile WebSharper\"    ).Class(\"btn btn-xs\"     ).OnClick(Do justCompile  ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Run WebSharper in ...\" ).Class(\"btn btn-xs\").OnClick(Do compileRun ).Disabled(noSelectionVal) .Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n              style \"\"\"\n                  overflow: hidden;\n                  display: grid;\n                  grid-template-columns: repeat(8, 12.1%);\n                  bxackground-color: #eee;\n                  padding : 5px;\n                  grid-gap: 5px;\n              \"\"\"\n            ]\n        )\n     .Content( script [ src  \"/EPFileX/FileSaver/FileSaver.js\"                                     ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://code.jquery.com/jquery-3.1.1.min.js\"                          ; ``type`` \"text/javascript\"             ] )\n     .Content( script [ src  \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"  ; ``type`` \"text/javascript\"             ] )\n     .Content( link   [ href \"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( link   [ href \"/EPFileX/css/main.css\"                                               ; ``type`` \"text/css\" ; rel \"stylesheet\" ] )\n     .Content( css styleEditor                                                                                                                )\n     .Render\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"47f7c0ba-35b0-466e-a759-4e4d9963e524"},{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}],"companions":[],"id":{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},"expanded":true},{"name":"CodeEditor page","content":"let splitterMain1 =\n    Template.SplitterBar.New( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n\nlet splitterMain2 =\n    Template.SplitterBar.New(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n\nstoreVarCodeEditor \"splitterMain1\" splitterMain1.Var\nstoreVarCodeEditor \"splitterMain2\" splitterMain2.Var\n\n//RunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\n//addNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\n//addNodeById \"splitterMain1\"                        <| splitterMain1.Render\n//addNodeById \"splitterMain2\"                        <| splitterMain2.Render\n\nlet grid = \n    Template.Grid.New\n       .Padding(0.0)\n       .Content(\"editor\", CodeEditor())\n       .Content(style    \"height: 100vh; margin: 0px; \")\n       .Content(css \"\"\"\n           #CodeEditor              { grid-area: editor  ; overflow: hidden; }\n           #TestNode                { grid-area: testNode; overflow: auto  ; }\n           body > div:first-of-type { grid-area: header  ; overflow: hidden; }\n       \"\"\")\n\ndirectionVertical\n|> Val.map (fun dir ->\n    (if dir\n     then grid.ColVariable(splitterMain1).ColAuto(16.0).ColVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header   editor   testNode'; \"\"\")\n     else grid.RowVariable(splitterMain1).RowAuto(16.0).RowVariable(splitterMain2).Content(style \"\"\" grid-template-areas: 'header' 'editor' 'testNode'; \"\"\")\n    ).GridTemplate())\n|> bindHElem body\n|> renderDoc\n|> Doc.RunReplace JS.Document.Body\n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"95ca1e9f-4029-4fc1-8b1c-ab12db71c90b"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"}],"companions":[],"id":{"$":0,"Item":"07f11803-2084-4a0a-9066-a43fd11be1c7"},"expanded":true},{"name":"","content":"[< JavaScript >]\nmodule Snippets      =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"companions":[],"id":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"expanded":true},{"name":"","content":"\ntype Grid = {  before : bool }\nwith\n    static member New  = {           before = false }\n    member this.Before = { this with before = true  }\n\n\nGrid.New\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n    .Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before.Before\n|> printfn \"%A\"    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"b3d2418a-1cb8-48bd-9f12-e90b61dcc572"},"expanded":true},{"name":"Demo Button","content":"\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode().RunHtmlPlusFree\n   \n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"companions":[],"id":{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},"expanded":true},{"name":"Demo Input","content":"let inp = Template.Input.New(\"Type something...\")\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nh3 [\n  inp.Render\n  htmlText inp.Var\n  htmlElement \"h2\" [ htmlText inp.Var ]\n  h1 [ htmlText inp.Var ]\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},"expanded":true},{"name":"Demo Code","content":"let code = Template.CodeMirror.New(\"Type something...\")\ndiv [ h1 [ htmlText code.Var ]\n      code.Render\n      Template.Button.New(\"Mark\").OnClick(fun _ _ -> \n          printfn \"Mark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.MarkText (0,5) (0,12) \"Error\"   \"this is wrong!\"\n              ed.MarkText (0,0) (0, 3) \"Warning\" \"this is not so bad.\nFix it now.\n              \"\n            )\n      ).Render\n      Template.Button.New(\"Unmark\").OnClick(fun _ _ -> \n          printfn \"Unmark\"\n          code.editorO \n          |> Option.iter (fun ed -> \n              printfn \"inside\"\n              ed.RemoveMarks()\n            )\n      ).Render\n      css  \".Error   { text-decoration: underline; text-decoration-color: orange; text-decoration-style: wavy } \n            .Warning { text-decoration: underline; text-decoration-color: yellow                              } \"\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"companions":[],"id":{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},"expanded":true},{"name":"Demo SplitterBar","content":"let styleT   p =\n  sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% %f%%;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    width: 1000px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     :   -7px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"  (p * 0.99) (0.99 * (100.0 - p))\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     \n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"companions":[],"id":{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},"expanded":true},{"name":"Demo Grid","content":"open Template\n        \nlet sc1 = SplitterBar.New(30.0)\nlet sr1 = SplitterBar.New(30.0).Horizontal()\n\nlet inline content1 v     (g: Grid) = g.Content(v   )\nlet inline content2 (a,b) (g: Grid) = g.Content(a, b)\nlet inline render         (g: Grid)         = g.Render\n\nGrid.New\n    .ColFixed(8.0).ColVariable(sc1).ColAuto(16.0).ColVariable(50.0).Before.Max(Val.map ((-) 84.0) sc1.GetValue)\n    .RowFixed(8.0).RowVariable(sr1).RowAuto(16.0).RowVariable(50.0).Before.Max(Val.map ((-) 84.0) sr1.GetValue)\n    .Content(         div [ htmlText \"Div11\" ; style \"background-color: lightblue\"  ])\n    .Content(\"1 / 2\", div [ htmlText \"Div12\" ; style \"background-color: lightgreen\" ])\n    .Content(\"1 / 3\", div [ htmlText \"Div13\" ; style \"background-color: pink\"       ])\n    .Content(\"1 / 4\", div [ htmlText \"Div14\" ; style \"background-color: magenta\"    ])\n    .Content(\"2 / 1\", div [ htmlText \"Div21\" ; style \"background-color: lightblue\"  ])\n    .Content(\"2 / 2\", div [ htmlText \"Div22\" ; style \"background-color: lightgreen\" ])\n    .Content(\"3 / 3\", div [ htmlText \"Div33\" ; style \"background-color: pink\"       ])\n    .Content(\"4 / 4\", div [ htmlText \"Div44\" ; style \"background-color: magenta\"    ])\n    .Render\n|> fun el -> el.AddChildren [ style \"height: 600px\" ]\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"0047d2f0-ec1d-43b1-b432-95462c318445"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"companions":[],"id":{"$":0,"Item":"9682eb8f-e1de-4d7c-adca-a5e2322558c2"},"expanded":true},{"name":"","content":"let snippetName0 (content: string) =\n    content.Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map    (fun l -> l.Trim())\n    |> Seq.filter (fun l -> not (l.StartsWith(\"#\") || l.StartsWith(\"[<\")))\n    |> Seq.tryHead\n    |> Option.defaultValue \"<empty>\"\n\n[\n  \"\"\"#if INTERACTIVE\n  #I @\"../WebServer/bin\"\n  #else\n  namespace TestFS\n  #endif\n  #nowarn \"1182\"\n  \"\"\"    \n  |> snippetName0    \n  \"[< hjhj >]\n    let name = \n  \" \n  |> snippetName0\n]\n|> Seq.map (htmlText >> List.singleton >> li)\n|> ul\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},"expanded":true},{"name":"Test mouse","content":"//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"companions":[],"id":{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},"expanded":true},{"name":"","content":"[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},"expanded":true},{"name":"","content":"type Position =\n    | Below\n    | Right\n    | Tab\n    | NewBrowser\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\" \n\nlet position = Var.Create Below \n\nlet inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n    match s with\n    | \"Below\"        -> Below     \n    | \"Right\"        -> Right     \n    | \"In Tab\"       -> Tab       \n    | \"New Browser\"  -> NewBrowser\n    | _              -> prev\n    ) )\n\ndiv [\n  inp.Render\n  Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n]\n|> RunCode.RunNode().RunHtml\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},"expanded":true},{"name":"Regex Pattern matching","content":"// from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\nlet str    = new String(\"Bob likes pineapples.\")\nlet regex  = new RegExp(@\"^\\w+\") // matches the first word\nlet newstr = str.Replace(regex,\"Alice\")\n\nlet (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n    \nlet duple a b = a, b\n4\nlet txt = \"\"\"Compiling to JavaScript...\n2 errors, 0 warnings\nErrFSharp\n  \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\nErrFSharp\n  \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \nWarningFSharp\n  \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \nEvaluating F# code...\n(6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \nCompiling to JavaScript...\n6 errors, 1 warnings\nWarningFSharp\n  \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n\"\"\"\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+) \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\n//\"\nlet rex = rex1 + \"|\" + rex2\n\n//[ \"JavaScript RegExp:\"\n//  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n//  sprintf \"Active pattern: %A\" <|\n//      match txt with\n//      | REGEX rex m -> m\n//      | _           -> \"<no match>\"\n//]\n//|> List.map  (fun t -> div [ htmlText t ] )\n//|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n//|> List.map  (htmlText >> List.singleton >> div )\n//|> (duple (style \"text-align: left\") >> List.Cons) \n//|> RunCode.RunNode().ShowHtmlResult\n\nlet inp = Template.TextArea.New(txt)                            .Placeholder(\"Text\")\nlet rx  = Template.Input   .New(rex).Prefix(htmlText \"RegEx  :\").Placeholder(\"Regex: . \\d \\w \\s \\n \\r \\t \\f (|)[a-z]+*?{3,5}\")  \nlet opt = Template.Input   .New(\"g\").Prefix(htmlText \"Options:\").Placeholder(\"Options: g i m u y\") \n\nh5 [\n  inp.Render\n  rx .Render\n  opt.Render\n  Val.map3 (fun inp rx opt -> \n          match inp with\n          | REGEX rx opt m -> m |> Array.map (htmlText >> List.singleton >> li)\n          | _              -> [| htmlText \"<no match>\" |]\n      ) inp.Var rx.Var opt.Var\n      |> composeDoc ul []\n]\n|> RunCode.RunNode().ShowHtmlResult\n\n//#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.dll\"\n//open System.Text.RegularExpressions\n//\n//let (|Regex|_|) pattern input =\n//    let m = Regex.Match(input, pattern)\n//    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n//    else None\n//\n////Example:\n//let phone = \"(555) 555-5555\"\n//match phone with\n//| Regex @\"\\(([0-9]{3})\\)[-. ]?([0-9]{3})[-. ]?([0-9]{4})\" [ area; prefix; suffix ] ->\n//    printfn \"Area: %s, Prefix: %s, Suffix: %s\" area prefix suffix\n//| _ -> printfn \"Not a phone number\"","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},"expanded":true},{"name":"","content":"let (|REGEX|_|) (expr: string) (opt: string) (value: string) =\n    if value = null then None else\n    try \n        match String(value).Match(RegExp(expr, opt)) with\n        | null         -> None\n        | [| |]        -> None\n        | m            -> Some m\n    with e -> None\n   \nlet txt = \"\"\"Compiling to JavaScript...\n2 errors, 0 warnings\nErrFSharp\n  \"F# Regex Pattern matching (47,39) - (47,40) parse 10: Unexpected symbol '<' in expression\"\nErrFSharp\n  \"F# Regex Pattern matching (47,49) - (47,50) parse 514: End of file in string begun at or before here\" \nWarningFSharp\n  \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"  \nEvaluating F# code...\n(6) F# 7k.fsx(1,7): error FS1156: This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).  \nCompiling to JavaScript...\n6 errors, 1 warnings\nWarningFSharp\n  \"F# Regex Pattern matching (16,0) - (16,1) typecheck 20: The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (120, 19) - (120, 46) Type not found in JavaScript compilation: System.Text.RegularExpressions.Regex\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 14) - (121, 23) Type not found in JavaScript compilation: System.Text.RegularExpressions.Group\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 67) - (121, 74) Type not found in JavaScript compilation: System.Text.RegularExpressions.Capture\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.Match\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Method name not found in JavaScript compilation: (EnumerateFromFunctions<_,_> : (unit -> 'T0) * ('T0 -> System.Boolean) * ('T0 -> 'T1) -> System.Collections.Generic.IEnumerable`1<'T1>), Members: safeDispose, EnumerateThenFinally, EnumerateUsing, EnumerateWhile, CreateEvent\"\nErrWebSharper\n  \"(6) F# Regex Pattern matching.fsx (121, 55) - (121, 63) Type not found in JavaScript compilation: System.Text.RegularExpressions.GroupCollection\"\n\"\"\"\nlet rex1 = \"\"\"\\((\\d+)\\) F# (.+).fsx\\((\\d+)\\,(\\d+)\\): (error|warning) ((.|\\b)+)\\.\"\"\"\nlet rex2 = \"\"\"(Err|Warning)(FSharp|WebSharper)\\s+\"(\\((\\d+)\\) )?F# (.+?)(.fsx)? \\((\\d+)\\,\\s*(\\d+)\\) - \\((\\d+)\\,\\s*(\\d+)\\) ((.|\\s)+?)\"\"\" + \"\\\"\"\nlet rex = rex1 + \"|\" + rex2\n\nmatch txt with\n| REGEX rex \"g\" m -> m\n| _               -> [||]\n|> Array.choose (fun v ->\n    match v with\n    | REGEX rex2 \"\" [| _ ; sev; from;  _; indent; file; _; fl; fc; tl; tc; msg; _ |] -> Some (file, int fl, int fc - int indent, int tl, int tc - int indent, sev, from , msg)\n    | REGEX rex1 \"\" [| _ ;                indent; file   ; fl; fc;    sev; msg; _ |] -> Some (file, int fl, int fc - int indent, int fl, int fc - int indent, sev, \"fsi\", msg)\n    | _ -> None\n)\n|> Array.map (fun (file, fl, fc, tl, tc, sev, from, msg) -> sprintf \"%s (%d,%d)-(%d,%d) %s %s : %s\" file fl fc tl tc sev from msg)\n|> Array.map (htmlText >> List.singleton >> List.append [ style \"text-align: left\" ] >> li)\n|> h5\n|> RunCode.RunNode().ShowHtmlResult\n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"ff6bfed0-83ae-4497-b197-fea6432aa958"},"expanded":true},{"name":"Load File","content":"let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},"expanded":true},{"name":"Storage","content":"let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n\nlet settingsStorage = JS.Window.LocalStorage\n\nsettingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\nsettingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\nsettingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n\nVal.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\nVal.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\nVal.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n\nlet styleT   p =\n  p |> sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% auto;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     : -7.5px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"\n\nlet splitter   = Template.SplitterBar\n                     .New(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     \n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},"expanded":true},{"name":"let awaitMessage () ","content":"#r @\"ZafirTranspiler.dll\"\n\nopen CIPHERPrototype.Editor\n\nlet message = Var.Create \"\" \n\nlet awaitMessage () =\n    async {\n        while true do\n            let! msg = CIPHERPrototype.Editor.awaitRequestFor <| AddressId \"FSharpStation1\"\n            message.Value <- msg.content\n            do! CIPHERPrototype.Editor.replyTo msg.messageId.Value (sprintf \"Ok message %A received.\" msg.messageId.Value)\n    } |> Async.Start\n\nawaitMessage()\n\ndiv [\n    Template.Input.New(message).Render\n    Template.Button.New(\"Send Message to Server\").OnClick(fun _ _ ->\n        async {\n          let! response = \n              CIPHERPrototype.Editor.sendRequest \n                      (AddressId \"FSharpStation1\"    )\n                      (AddressId \"ButtonTest\"        )\n                      (\"Message is \" + message.Value )\n          JS.Alert response\n          return ()\n        }  |> Async.Start\n      ).Render\n]    \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"e9c3ceaf-8fe5-4752-aa4c-2db6e1ac4577"},"expanded":true},{"name":"","content":"6 * 8.0\n//|> printfn \"result is: %A\"","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"b47dbe9c-8623-4b35-98ee-5073edfc21b3"},"expanded":true}]