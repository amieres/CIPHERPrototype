[{"name":"READ ME","content":"PENDING:\n\n- Store last state in local storage:  splitter position/ execute/ file name/ dirty state\n    \n- Intellisense\n    - Autocompletion\n    - Code tips\n    - Error highlight\n    \n- Implement Tab(s)\n\n- Create splitter template\n\n- Create website load/upload/invoke/precompiled code\n\n- Create non-Javascript invocation (pure .Net F#) version for only local use.\n\n- Give it a web site look\n- Get rid of undefined message when running JS and maybe show possible result value\n\nERROR:\n\nSOLVED:\n- Detect dirty state and not allow Load/close before saving\n    - Download ( Save as ...) with automatic extension\n- make Choose File and Load one action and one button\n- Limit undo to the current field\n- Error:\nCompiling...\nRunning...\nFailed!\nTypeError: Cannot read property 'appendChild' of undefined  // it was due to the busy CPU taking longer than 300ms to load. Changed to 600ms.","predecessors":[],"companions":[],"id":{"$":0,"Item":"b4b48226-deb9-44da-98de-e2bf5b7cd889"},"expanded":true},{"name":"","content":"namespace Test\n#nowarn \"1182\"\n//#I @\"../WebServer/bin\"","predecessors":[{"$":0,"Item":"66ab3e22-f5ed-4e75-966d-28394d24f3d7"}],"companions":[],"id":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"expanded":true},{"name":"open WebSharper","content":"#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Web.dll\"\n#r @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Core.dll\"\n\n#r @\"WebSharper.Core.dll\"\n#r @\"WebSharper.Collections.dll\"\n#r @\"WebSharper.Main.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.JavaScript.dll\"\n#r @\"WebSharper.Web.dll\"\n#r @\"WebSharper.UI.Next.dll\"\n#r @\"WebSharper.Sitelets.dll\"\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI.Next\nopen WebSharper.UI.Next.Client\ntype on   = WebSharper.UI.Next.Html.on\ntype attr = WebSharper.UI.Next.Html.attr\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"},"expanded":true},{"name":"","content":"[<JavaScript>]\nmodule HtmlNode =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"expanded":false},{"name":"","content":"[<NoComparison>]\ntype Val<'a> =\n    | Constant  of 'a\n    | DynamicV  of IRef<'a>\n    | Dynamic   of View<'a>\n\nmodule Val =\n    \n    let mapV : ('a -> 'b) -> Val<'a> -> Val<'b> =\n        fun    f             va      ->\n            match va with\n            | Constant  a -> f a                   |> Constant\n            | Dynamic  wa -> wa      |> View.Map f |> Dynamic \n            | DynamicV va -> va.View |> View.Map f |> Dynamic \n\n    let iterV : ('a -> unit) -> Val<'a> -> unit = //f v = toView v |> View.Get f\n        fun     f               va      ->\n            match va with\n            | Constant  a ->          f  a                  \n            | Dynamic  wa -> View.Get f wa \n            | DynamicV va ->          f va.Value \n\n    let toView v =\n        match v with\n        | Constant  a -> View.Const a\n        | Dynamic  wa -> wa\n        | DynamicV va -> va.View\n\n    let bindV : ('a -> Val<'b>) -> Val<'a> -> Val<'b> =\n        fun     f                  v       -> \n            match v with\n            | Constant  a -> f a\n            | Dynamic  wa -> wa      |> View.Bind (f >> toView) |> Dynamic \n            | DynamicV va -> va.View |> View.Bind (f >> toView) |> Dynamic \n\n    let inline map2V f = // : ('a -> 'b -> 'c) -> Val<'a> -> Val<'b> -> Val<'c> =\n        //fun     f                ->\n        let inline swap f a b = f b a\n        let inline fv vb = bindV (swap (f >> mapV) vb)\n        swap fv\n\n    let inline map3V f3 v1 v2 v3    = map2V f3 v1 v2    |> map2V (|>) v3\n    let inline map4V f3 v1 v2 v3 v4 = map3V f3 v1 v2 v3 |> map2V (|>) v4\n    \n    let tagDoc: ('a -> Doc) -> Val<'a> -> Doc =\n        fun     tag            va      ->\n            match va with\n            | Constant  a -> tag   a\n            | Dynamic  wa -> wa      |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let tagElt: ('a -> Elt) -> Val<'a> -> Doc =\n        fun     tag            va     ->\n            match va with\n            | Constant  a -> tag   a :> Doc\n            | Dynamic  wa -> wa     |> View.Map tag |> Doc.EmbedView\n            | DynamicV va -> va.View |> View.Map tag |> Doc.EmbedView\n\n    let attrV att       va      =\n            match va with\n            | Constant  a -> Attr.Create  att   a\n            | Dynamic  wa -> Attr.Dynamic att  wa\n            | DynamicV va -> Attr.Dynamic att  va.View\n\n\n    type HelperType = HelperType with\n        static member inline (&>) (HelperType, a : string      ) = Constant  a\n        static member (&>) (HelperType, a : bool        ) = Constant  a\n        static member (&>) (HelperType, a : int         ) = Constant  a\n        static member (&>) (HelperType, a : float       ) = Constant  a\n        static member (&>) (HelperType, a : Doc         ) = Constant  a\n        static member (&>) (HelperType, va: Val<string> ) =          va\n        static member (&>) (HelperType, va: Val<bool  > ) =          va\n        static member (&>) (HelperType, va: Val<int   > ) =          va\n        static member (&>) (HelperType, va: Val<float > ) =          va\n        static member (&>) (HelperType, va: Val<Doc   > ) =          va\n        static member (&>) (HelperType, va: Val<_     > ) =          va\n        static member (&>) (HelperType, vr: IRef<_    > ) = DynamicV vr\n        static member (&>) (HelperType, vw: View<_    > ) = Dynamic  vw\n\n    [< Inline @\"(\n            typeof($v) == 'function' ? {$:2, $0:$v} // View\n            :   typeof($v) == 'object'\n                      ? typeof($v.$) != 'undefined' // Val\n                            ? $v \n                            : typeof($v.Id) == 'number' || typeof($v.i) == 'number' || typeof($v.RView == 'function')// Var\n                                 ? {$:1, $0:$v}\n                                 : typeof($v.docNode) != 'undefined'\n                                     ? {$:0, $0:$v} // Doc\n                                     : {$:2, $0:$v} // View?\n                      : {$:0, $0:$v}) // other\n                                     \" >]\n    let fixit0 v = Constant v\n    let fixit2 v = let result = fixit0 v\n                   result\n                   \n    [< Direct \"Test.HtmlNode.Val.fixit2($v)\" >]\n    //[< Inline >]\n    let inline fixit v = HelperType &> v\n\n    [< Inline >]\n    let inline bindIRef0 (f: 'a->IRef<'b>) (view: View<'a>) = \n        let contentVar = Var.Create Unchecked.defaultof<'b>\n        let changingIRefO : IRef<'b> option ref = ref None\n    \n        contentVar.View |> View.Sink (fun v -> !changingIRefO |> Option.iter (fun r -> if r.Value <> v then r.Value <- v))\n    \n        view |> View.Bind (fun cur ->\n            let r = f cur\n            changingIRefO    := Some r\n            contentVar.Value <- r.Value\n            r.View\n        ) |> View.Sink (fun v -> contentVar.Value <- v)\n        contentVar\n    \n    let inline toDoc       v           = toView      (fixit v ) |> Doc.EmbedView\n    [< Inline >]\n    let inline bindIRef f  v           = bindIRef0 f (fixit v   |> toView)\n    let inline iter     f  v           = iterV     f (fixit v )\n    let inline bind     f  v           = bindV     f (fixit v )\n    let inline map      f  v           = mapV      f (fixit v )\n    let inline map2     f  v1 v2       = map2V     f (fixit v1) (fixit v2)\n    let inline map3     f  v1 v2 v3    = map3V     f (fixit v1) (fixit v2) (fixit v3)\n    let inline map4     f  v1 v2 v3 v4 = map4V     f (fixit v1) (fixit v2) (fixit v3) (fixit v4)\n    let inline sink     f  v           = fixit v |> toView |> View.Sink f\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype HtmlNode =\n    | HtmlElement   of name: string * children: HtmlNode seq\n    | HtmlAttribute of name: string * value:    Val<string>\n    | HtmlText      of Val<string>\n    | HtmlEmpty\n    | SomeDoc       of Doc\n    | SomeAttr      of Attr\n    \nlet addClass    (classes:string) (add:string) = classes.Split ' ' |> Set.ofSeq |> Set.union  (Set.ofSeq <| add.Split ' ') |> String.concat \" \"\nlet removeClass (classes:string) (rem:string) = classes.Split ' ' |> Set.ofSeq |> Set.remove               rem            |> String.concat \" \"\n\nlet callAddClass = addClass \"a\" \"b\" // so that WebSharper.Collections.js is included\n\nlet inline chooseAttr node = \n    match node with\n    | HtmlAttribute (name, value   ) when name <> \"class\" && name <> \"style\" \n                                     -> Some <| Val.attrV name value\n    | SomeAttr             value     -> Some <|                value\n    | _                              -> None\n\nlet chooseThisAttr this node =\n    match node with\n    | HtmlAttribute (att, value) when att = this -> Some value\n    | _                                          -> None\n\nlet concat s a b = a + s + b\nlet groupAttr name sep children = \n    children \n    |> Seq.choose (chooseThisAttr name)\n    |> (fun ss -> if ss |> Seq.isEmpty \n                  then None \n                  else ss |> Seq.reduce (Val.map2 <| concat sep ) |> Val.attrV name |> Some)\n\nlet inline getAttrsFromSeq children =\n    children \n    |> Seq.choose chooseAttr\n    |> Seq.append (List.choose id [ children |> groupAttr \"class\" \" \" ; children |> groupAttr \"style\" \"; \" ])\n\nlet rec chooseNode node =\n    match node with\n    | HtmlElement(name, children) -> Some <| (Doc.Element name (getAttrsFromSeq children) (children |> Seq.choose chooseNode) :> Doc)\n    | HtmlText    vtext           -> Some <| Val.tagDoc WebSharper.UI.Next.Html.text vtext\n    | SomeDoc     doc             -> Some <| doc\n    | _                           -> None\n\nlet getAttrChildren attr =\n    Seq.tryPick (function \n                | HtmlAttribute(a, v) when a = attr -> Some v \n                | _                                 -> None)\n    >> Option.defaultValue (Constant \"\")\n\nlet mapHtmlElement f element =\n    match element with\n    | HtmlElement(name, children) -> f name  children\n    | _                           -> element\n\nlet getAttr attr element =\n    match element with\n    | HtmlElement(_, children) -> children\n    | _                        -> seq []\n    |> getAttrChildren attr\n\nlet getClass = getAttr \"class\"\nlet getStyle = getAttr \"style\"\n\nlet replaceAttribute att (children: HtmlNode seq) newVal =\n    HtmlAttribute(att, newVal)\n    :: (children\n        |> Seq.filter (function HtmlAttribute(old, _) when old = att -> false | _ -> true)\n        |> Seq.toList\n       )\n\nlet replaceAtt att node newVal = mapHtmlElement (fun n ch -> HtmlElement(n, replaceAttribute att ch newVal)) node\n\ntype HtmlNode with\n    member inline this.toDoc = \n        match this with\n        | HtmlAttribute _\n        | HtmlEmpty       -> Doc.Empty\n        | _               -> chooseNode this |> Option.defaultValue Doc.Empty\n    member inline   this.Class       clas = Val.fixit clas |> replaceAtt \"class\" this\n    member inline   this.AddChildren add  = mapHtmlElement (fun n ch -> HtmlElement(n, Seq.append add ch )) this\n\nlet renderDoc = chooseNode >> Option.defaultValue Doc.Empty\n    ","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"0f5719f0-e95e-498d-ab88-f89ff1440e32"}],"companions":[],"id":{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"},"expanded":true},{"name":"","content":"let inline atr att v = Val.attrV  att (Val.fixit v)\nlet inline tag tag v = Val.tagDoc tag (Val.fixit v)\n\nlet inline _class       v = atr \"class\"       v\nlet inline _type        v = atr \"type\"        v\nlet inline _style       v = atr \"style\"       v\nlet inline _placeholder v = atr \"placeholder\" v\nlet inline textV        v = tag  Html.text    v\n\nlet inline htmlElement   name ch = HtmlElement  (name, ch           )\nlet inline htmlAttribute name v  = HtmlAttribute(name, Val.fixit v  )\nlet inline htmlText      txt     = HtmlText     (      Val.fixit txt)\nlet inline someElt       elt     = SomeDoc      (elt :> Doc         )    \n  \nlet inline br          ch = htmlElement   \"br\"          ch\nlet inline hr          ch = htmlElement   \"hr\"          ch\nlet inline h1          ch = htmlElement   \"h1\"          ch\nlet inline h2          ch = htmlElement   \"h2\"          ch\nlet inline h3          ch = htmlElement   \"h3\"          ch\nlet inline h4          ch = htmlElement   \"h4\"          ch\nlet inline h5          ch = htmlElement   \"h5\"          ch\nlet inline h6          ch = htmlElement   \"h6\"          ch\nlet inline div         ch = htmlElement   \"div\"         ch\nlet inline img         ch = htmlElement   \"img\"         ch\nlet inline span        ch = htmlElement   \"span\"        ch\nlet inline form        ch = htmlElement   \"form\"        ch\nlet inline table       ch = htmlElement   \"table\"       ch\nlet inline thead       ch = htmlElement   \"thead\"       ch\nlet inline th          ch = htmlElement   \"th\"          ch\nlet inline tr          ch = htmlElement   \"tr\"          ch\nlet inline td          ch = htmlElement   \"td\"          ch\nlet inline tbody       ch = htmlElement   \"tbody\"       ch\nlet inline label       ch = htmlElement   \"label\"       ch\nlet inline button      ch = htmlElement   \"button\"      ch\nlet inline script      sc = htmlElement   \"script\"      sc\nlet inline styleH      st = htmlElement   \"style\"       st\nlet inline fieldset    ch = htmlElement   \"fieldset\"    ch\nlet inline link        sc = htmlElement   \"link\"        sc\nlet inline iframe      at = htmlElement   \"iframe\"      at\n     \nlet inline href        v  = htmlAttribute \"href\"        v\nlet inline rel         v  = htmlAttribute \"rel\"         v\nlet inline src         v  = htmlAttribute \"src\"         v\nlet inline ``class``   v  = htmlAttribute \"class\"       v\nlet inline ``type``    v  = htmlAttribute \"type\"        v\nlet inline width       v  = htmlAttribute \"width\"       v\nlet inline title       v  = htmlAttribute \"title\"       v\nlet inline Id          v  = htmlAttribute \"id\"          v\nlet inline frameborder v  = htmlAttribute \"frameborder\" v\n\nlet inline classIf cls v = ``class`` <| Val.map (fun b -> if b then cls else \"\") (Val.fixit v)\n\nlet inline ``xclass`` v  = \n    match Val.fixit v with\n    | Constant c  -> Attr.Class        c       \n    | Dynamic  cw -> Attr.DynamicClass \"class_for_view_not_implemented\" cw      ((<>)\"\")\n    | DynamicV cv -> Attr.DynamicClass cv.Value                         cv.View ((<>)\"\")\n    |> SomeAttr\n\nlet style2pairs (ss:string) : (string * string) [] =\n    ss.Split(';') \n    |> Array.map   (fun s -> s.Split(':') ) \n    |> Array.filter(fun d -> d.Length = 2 )\n    |> Array.map   (fun d -> d.[0].Trim(), d.[1].Trim() )\n\nlet string2Styles = style2pairs >> Array.map (fun (n, v) -> Attr.Style n v |> SomeAttr)\n\nlet inline style     v  = htmlAttribute \"style\"    v\nlet inline style1  n v  = Val.fixit v |> Val.toView |> Attr.DynamicStyle n |> SomeAttr\n\nlet composeDoc elt dtl dtlVal = dtlVal |> Val.toView |> Doc.BindView (Seq.append dtl >> elt >> renderDoc) |> SomeDoc\n\nlet inline bindHElem hElem v  = Doc.BindView (hElem >> renderDoc)  (Val.toView <| Val.fixit v)            |> SomeDoc\n\n\nlet createIFrame f =\n    let cover = Var.Create true\n    div [ style           \"position: relative; overflow: hidden; height: 100%; width: 100%;\" \n          iframe \n            [ style       \"position: absolute; width:100%; height:100%;\"\n              frameborder \"0\"\n              SomeAttr <| on.afterRender f\n              SomeAttr <| on.mouseLeave (fun _ _ -> cover.Value <- true)\n            ]\n          div \n            [ style       \"position: absolute;\"\n              classIf     \"iframe-cover\" (Val.map id cover)               \n              SomeAttr <| on.mouseEnter (fun _ _ -> Input.Mouse.MousePressed \n                                                    |> View.Get (fun pressed -> if not pressed then cover.Value <- false))\n            ]          \n          styleH [ htmlText \".iframe-cover { top:0; left:0; right:0; bottom:0; background: blue; opacity: 0.04; z-index: 2; }\" ]\n        ]\n","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"d9124644-0af6-4a7f-a711-ef76ca77f0de"}],"companions":[],"id":{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"},"expanded":true},{"name":"","content":"\n\n[< Inline \"CIPHERSpaceLoadFiles($files, $cb)\" >]\nlet LoadFiles (files: string []) (cb: unit -> unit) : unit = X<_>","parent":{"$":0,"Item":"495bce0a-4fb6-48fa-9158-c242d5965baa"},"predecessors":[{"$":0,"Item":"02d3bc50-4aa0-41ce-a37e-5b90a943481f"}],"companions":[],"id":{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},"expanded":true},{"name":"","content":"open HtmlNode","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"c3755c07-1385-495d-bad7-a5b0fa54ac9b"}],"companions":[],"id":{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},"expanded":true},{"name":"","content":"[<JavaScript>]\nmodule Template =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"11ecbe45-3d0c-4121-a8fd-7c126b96f4a3"}],"companions":[],"id":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"expanded":false},{"name":"","content":"let container content = div <| [ ``class`` \"container\" ] @ content","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"8fb54777-3046-4aae-9282-33401a45c280"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Button = {\n    _class  : Val<string>\n    _type   : Val<string>\n    style   : Val<string>\n    text    : Val<string>\n    onClick : Dom.Element -> Dom.MouseEvent -> unit\n    disabled: Val<bool>\n    id      : string\n} with\n  static member inline New txt = \n      { _class   = Val.fixit \"btn\" \n        _type    = Val.fixit \"button\" \n        style    = Val.fixit \"\" \n        text     = Val.fixit txt\n        onClick  = fun _ _ -> ()\n        disabled = Val.fixit false\n        id       = \"\"\n      }\n  member        this.Render     =         \n    button [ ``type``  <| this._type\n             ``class`` <| this._class\n             Id        <| this.id  \n             style     <| this.style\n             SomeAttr  <| attr.disabledDynPred (View.Const \"\") (this.disabled |> Val.toView)\n             SomeAttr  <| on.click <@ this.onClick @>\n             HtmlText  <| this.text \n           ]\n  member inline this.Id          id   = { this with id       = id             }\n  member inline this.Class       clas = { this with _class   = Val.fixit clas }\n  member inline this.Type        typ  = { this with _type    = Val.fixit typ  }\n  member inline this.Style       sty  = { this with style    = Val.fixit sty  }\n  member inline this.Text        txt  = { this with text     = Val.fixit txt  }\n  member inline this.Disabled    dis  = { this with disabled = Val.fixit dis  }\n  member inline this.OnClick     f    = { this with onClick  = f              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Input = {\n    _type       : Val<string>\n    _class      : Val<string>\n    style       : Val<string>\n    placeholder : Val<string>\n    id          : string\n    var         : IRef<string>\n    prefix      : HtmlNode\n    suffix      : HtmlNode\n    content     : Attr seq\n    prefixAdded : bool\n    suffixAdded : bool\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\" \n                              _type       = Val.fixit \"text\" \n                              style       = Val.fixit \"\" \n                              placeholder = Val.fixit \"Enter text:\"\n                              id          = \"\"\n                              content     = []\n                              prefix      = HtmlEmpty\n                              prefixAdded = false\n                              suffix      = HtmlEmpty\n                              suffixAdded = false\n                              var         = var   \n                            }\n  static member  New(v)   = Input.New(Var.Create v)\n  member        this.Render    =         \n    let groupClass det = match det with HtmlText _  -> \"input-group-addon\" | _ -> \"input-group-btn\"\n    div [\n        if this.prefixAdded || this.suffixAdded then\n            yield ``class`` \"input-group\"\n        if this.prefixAdded then\n            yield  span     [ ``class`` <| groupClass this.prefix \n                              this.prefix       ]\n        yield Doc.Input ([_type            this._type\n                          _class           this._class\n                          _style           this.style\n                          attr.id          this.id  \n                          _placeholder     this.placeholder ] |> Seq.append this.content)\n                          this.var\n              :> Doc |> SomeDoc\n        if this.suffixAdded then\n            yield  span     [ ``class`` <| groupClass this.suffix \n                              this.suffix       ]\n      ]\n  member inline this.Class       clas = { this with _class      = Val.fixit clas                  }\n  member inline this.Type        typ  = { this with _type       = Val.fixit typ                   }\n  member inline this.Style       sty  = { this with style       = Val.fixit sty                   }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc                   }\n  member inline this.Id          id   = { this with id          =       id                        }\n  member inline this.Content     c    = { this with content     =       c                         }\n  member inline this.Prefix      p    = { this with prefix      =       p    ; prefixAdded = true }\n  member inline this.Suffix      s    = { this with suffix      =       s    ; suffixAdded = true }\n  member inline this.SetVar      v    = { this with var         = v                               }\n  member inline this.Var              = this.var","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Hoverable = {\n    hover      : IRef<bool>\n    content    : HtmlNode seq\n} with\n  static member  New   = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n        content    = []\n    }\n  static member  Demo  = \n    let hover      = Var.Create false\n    { \n        hover      = hover     \n        content    = [ style \"flex-flow: column;\"\n                     ]\n    }\n  member        this.Render          =\n    [ classIf \"hovering\" this.hover\n      SomeAttr <| on.mouseEnter (fun _ _ -> this.hover.Value <- true )\n      SomeAttr <| on.mouseLeave (fun _ _ -> this.hover.Value <- false)\n    ] \n    |> Seq.append  this.content\n    |> div\n  member inline this.Content    c = { this with content    =       c }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype Panel = {\n    _class   : Val<string>\n    _style   : Val<string>\n    title    : Val<string>\n    header   : HtmlNode seq\n    content  : HtmlNode seq\n    disabled : Val<bool>\n} with\n  static member  New   = { _class   = Val.fixit <| \"panel panel-default shadow\"\n                           _style   = Val.fixit <| \"text-align:center\" \n                           title    = Val.fixit <| \"Panel\"        \n                           header   =          [ htmlText \"Some text\"    ] \n                           content  =          [ htmlText \"Some Content\" ] \n                           disabled = Val.fixit <| Var.Create false\n                         }\n  member        this.Render          =  \n    fieldset [ SomeAttr <| attr.disabledDynPred (View.Const \"\")  (this.disabled |> Val.toView)\n               div [ ``class`` this._class\n                     div (Seq.append\n                              [ ``class`` \"panel-heading\"\n                                label [ ``class``  \"panel-title text-center\" ; htmlText this.title ]\n                              ]\n                              this.header)\n\n                     div (Seq.append\n                              [ ``class`` \"panel-body\"\n                                style     this._style \n                              ]\n                              this.content)\n                   ] \n             ]\n  member inline this.Class       clas = { this with _class   = Val.fixit clas                                        }\n  member inline this.Style       sty  = { this with _style   = Val.fixit sty                                         }\n  member inline this.Title       txt  = { this with title    = Val.fixit txt                                         }\n  member inline this.Header      h    = { this with header   =       h                                           }\n  member inline this.Content     c    = { this with content  =       c                                           }\n  member inline this.Disabled    dis  = { this with disabled =       dis                                         }\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"}],"companions":[],"id":{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype TextArea = {\n    _class      : Val<string>\n    placeholder : Val<string>\n    title       : Val<string>\n    id          : string\n    var         : IRef<string>\n} with\n  static member  New(var) = { _class      = Val.fixit \"form-control\"\n                              placeholder = Val.fixit \"Enter text:\"\n                              title       = Val.fixit \"\"\n                              id          = \"\"\n                              var         = var   \n                            }\n  static member  New(v)   = TextArea.New(Var.Create v)\n  member        this.Render    =    \n    someElt \n    <| Doc.InputArea\n        [ \n          _class       this._class\n          attr.id      this.id  \n          atr \"title\"  this.title\n          _placeholder this.placeholder ]\n        this.var\n  member inline this.Class       clas = { this with _class      = Val.fixit clas }\n  member inline this.Placeholder plc  = { this with placeholder = Val.fixit plc  }\n  member inline this.Title       ttl  = { this with title       = Val.fixit ttl  }\n  member inline this.Id          id   = { this with id          =       id       }\n  member inline this.SetVar      v    = { this with var         = v              }\n  member inline this.Var              = this.var\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},"expanded":true},{"name":"","content":"let codeMirrorIncludes =\n   [| \"/EPFileX/codemirror/scripts/codemirror/codemirror.js\"             \n      \"/EPFileX/codemirror/scripts/intellisense.js\"                      \n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-intellisense.js\"\n      \"/EPFileX/codemirror/scripts/codemirror/codemirror-compiler.js\"    \n      \"/EPFileX/codemirror/scripts/codemirror/mode/fsharp.js\"            \n      \"/EPFileX/codemirror/scripts/addon/search/searchcursor.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/search.js\"          \n      \"/EPFileX/codemirror/scripts/addon/search/jump-to-line.js\"          \n      \"/EPFileX/codemirror/scripts/addon/dialog/dialog.js\"          \n      \"/EPFileX/codemirror/scripts/addon/edit/matchbrackets.js\"          \n      \"/EPFileX/codemirror/scripts/addon/selection/active-line.js\"       \n      \"/EPFileX/codemirror/scripts/addon/display/fullscreen.js\"          \n      \"/EPFileX/codemirror/scripts/codemirror/mode/markdown.js\"                 \n   |]","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype CodeMirror = {\n    _class      : Val<string>\n    id          : string\n    var         : IRef<string>\n    onChange    : (unit -> unit)\n} with\n\n  [< Inline \"setupEditor($elt)\"             >]\n  static member SetupEditor elt                               : CodeMirror = X<_>\n  [< Inline \"$this.getValue()\"              >]\n  member this.GetValue()                                      : string     = X<_>\n  [< Inline \"$this.setValue($v)\"            >]\n  member this.SetValue (v:string)                             : unit       = X<_>\n  [< Inline \"$this.getDoc().clearHistory()\" >]\n  member this.ClearHistory()                                  : unit       = X<_>\n  [< Inline \"$this.on($event, $f)\"          >]\n  member this.On(event: string, f:(CodeMirror * obj) -> unit) : unit     = X<_>\n\n  static member  New(var) = \n      { _class   = Val.fixit \"\" \n        id       = \"\"\n        var      = var \n        onChange = ignore\n      }\n  static member  New(v)   = CodeMirror.New(Var.Create v)\n  member        this.Render    =\n    div [ \n          ``class``            this._class\n          SomeAttr <| attr.id  this.id \n          style \"position: relative; height: 300px\"\n          div [\n                style \"height: 100%; width: 100%; position: absolute;\"\n                SomeAttr <| on.afterRender (fun el ->\n                  LoadFiles codeMirrorIncludes\n                    (fun () ->                       \n                       let editor = CodeMirror.SetupEditor el\n                       editor.On(\"change\", fun (cm, change) -> \n                           let v = editor.GetValue() \n                           if this.var.Value <> v then this.var.Value <- v; this.onChange() )\n                       this.var.View |> View.Sink (fun v -> if editor.GetValue() <> v then editor.SetValue v ; editor.ClearHistory())\n                    )\n                )    \n              ]\n          link [ href \"/EPFileX/codemirror/content/editor.css\"                   ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/codemirror.css\"               ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/content/theme/rubyblue.css\"           ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/display/fullscreen.css\" ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n          link [ href \"/EPFileX/codemirror/scripts/addon/dialog/dialog.css\"      ; ``type`` \"text/css\" ; rel \"stylesheet\" ]\n     ]\n  member inline this.Class    clas = { this with _class    = Val.fixit clas }\n  member inline this.Id       id   = { this with id        =       id       }\n  member inline this.SetVar   v    = { this with var       = v              }\n  member inline this.OnChange f    = { this with onChange  = f              }\n  member inline this.Var           = this.var\n","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[{"$":0,"Item":"1f1aa135-fd74-42cc-b9a5-87f380c113a9"},{"$":0,"Item":"4180353c-9dc5-438d-862d-851539b02075"}],"companions":[],"id":{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},"expanded":true},{"name":"","content":"[<NoComparison ; NoEquality>]\ntype SplitterBar = {\n    value            : IRef<float>\n    min              : Val<float>\n    max              : Val<float>\n    vertical         : Val<bool>\n    node             : HtmlNode\n    after            : bool\n    mutable dragging : bool\n    mutable startVer : bool \n    mutable startP   : float \n    mutable start    : float \n    mutable size     : float \n    mutable domElem  : Dom.Element option\n}\nwith\n    static member New = \n        {\n            value    = Var.Create 30.0\n            min      = Val.fixit  10.0\n            max      = Val.fixit  75.0\n            vertical = Val.fixit  true  \n            node     = div [ ``class`` \"Splitter\" ]\n            after    = true\n            dragging = false\n            startVer = true\n            startP   = 0.0\n            start    = 0.0\n            size     = 0.0\n            domElem  = None\n        }\n    member        this.GetValue = this.value |> Val.map2 max this.min |> Val.map2 min this.max\n    member        this.Render   =\n        let mouseCoord (ev: Dom.MouseEvent) = if this.startVer then float ev.ClientX else float ev.ClientY\n        let size () : float =\n            match this.domElem with\n            | None    -> 100.0\n            | Some el -> \n             el.ParentElement.GetBoundingClientRect() \n             |> fun r -> \n                 match this.startVer, this.after with\n                 | true , true  ->  r.Width  \n                 | true , false -> -r.Width \n                 | false, true  ->  r.Height\n                 | false, false -> -r.Height\n        let drag (ev: Dom.Event) =\n            ev :?> Dom.MouseEvent\n            |> mouseCoord\n            |> fun m   -> (m - this.start) * 100.0 / this.size + this.startP\n            |> fun v   -> this.value.Value <- v // ; JS.Inline(\"console.log($0)\", this)\n           \n        let rec finishDragging (_: Dom.Event) =\n            if this.dragging then\n                this.dragging <- false\n                JS.Window.RemoveEventListener(\"mousemove\", drag          , false) \n                JS.Window.RemoveEventListener(\"mouseup\"  , finishDragging, false) \n                //printfn \"mouseup\"\n        let startDragging _ (ev: Dom.MouseEvent) =\n            if not this.dragging then\n                Val.map2 (fun startP dirV ->\n                    this.dragging <- true\n                    this.startVer <- dirV\n                    this.startP   <- startP\n                    this.start    <- mouseCoord ev\n                    this.size     <- size()\n                    JS.Window.AddEventListener(\"mousemove\", drag          , false) \n                    JS.Window.AddEventListener(\"mouseup\"  , finishDragging, false) \n                    ev.PreventDefault()\n                ) this.GetValue this.vertical\n                |> Val.iter id\n        this.node\n          .AddChildren [\n            SomeAttr <| on.mouseDown startDragging\n            SomeAttr <| on.afterRender (fun el -> this.domElem <- Some el)\n          ]  \n    member inline this.Value       v = this.value.Value    <- v    ; this\n    member inline this.Node     node = { this with node         = node                        }\n    member inline this.Min         v = { this with min          = Val.fixit v                 }\n    member inline this.Max         v = { this with max          = Val.fixit v                 }\n    member inline this.Vertical    v = { this with vertical     = Val.fixit v                 }\n    member inline this.Horizontal  v = { this with vertical     = Val.fixit v |> Val.map not  }\n    member inline this.Var         v = { this with value        =           v                 }\n    member inline this.Vertical   () = { this with vertical     = Val.fixit true              }\n    member inline this.Horizontal () = { this with vertical     = Val.fixit false             }\n    member inline this.Before        = { this with after        =           false             }\n    member inline this.After         = { this with after        =           true              }","parent":{"$":0,"Item":"e9ac2d66-474a-46a6-95fa-d369e6d703d1"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},"expanded":true},{"name":"module RunCode =","content":"[<JavaScript>]\nmodule RunCode =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"1095ae38-19fc-4195-840c-c368a3a486c4"}],"companions":[],"id":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"expanded":false},{"name":"","content":"#r @\"ZafirTranspiler.dll\"\nmodule EditorRpc =\n    let callRPC asy callback =\n        async {\n            let! res = asy\n            callback res\n        } |> Async.Start\n\n    let checkSource  source          callback = CIPHERPrototype.Editor.checkSource  source          |> callRPC <| callback\n    let methods      source line col callback = CIPHERPrototype.Editor.methods      source line col |> callRPC <| callback\n    let declarations source line col callback = CIPHERPrototype.Editor.declarations source line col |> callRPC <| callback\n    let translate    source minified callback = CIPHERPrototype.Editor.translate    source minified |> callRPC <| callback\n\nlet completeJS js = \n  \"\"\"\n    CIPHERSpaceLoadFileGlobalFileRef = null;\n    CIPHERSpaceLoadFile = function (filename, callback) {\n        if (filename.slice(-3) == \".js\" || filename.slice(-4) == \".fsx\" || filename.slice(-3) == \".fs\") { //if filename is a external JavaScript file\n            var fileRef = null;\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement('script')\n                fileRef.setAttribute(\"type\", \"text/javascript\")\n                fileRef.setAttribute(\"src\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-4) == \".css\") { //if filename is an external CSS file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"stylesheet\")\n                fileRef.setAttribute(\"type\", \"text/css\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        else if (filename.slice(-5) == \".html\") { //if filename is an external HTML file\n            var pre = document.querySelector('script[src=\"' + filename + '\"]')\n            if (!pre) {\n                fileRef = document.createElement(\"link\")\n                fileRef.setAttribute(\"rel\", \"import\")\n                fileRef.setAttribute(\"type\", \"text/html\")\n                fileRef.setAttribute(\"href\", filename)\n            }\n            else callback();\n        }\n        if (!!fileRef) {\n            CIPHERSpaceLoadFileGlobalFileRef = fileRef;\n\t\t\tfileRef.onload = function () { fileRef.onload = null;  callback(); }\n            document.getElementsByTagName(\"head\")[0].appendChild(fileRef);\n        }\n    }\n    CIPHERSpaceLoadFiles = function (files, callback) {\n        var newCallback = callback\n        if (!!CIPHERSpaceLoadFileGlobalFileRef && !!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n            var oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n            CIPHERSpaceLoadFileGlobalFileRef.onload = null;\n            newCallback = function () {\n                callback();\n                oldCallback();\n            }\n        }\n        var i = 0;\n        loadNext = function () {\n            if (i < files.length) {\n                var file = files[i];\n                i++;\n                CIPHERSpaceLoadFile(file, loadNext);\n            }\n            else newCallback();\n        };\n        loadNext();\n\t}\n    CIPHERSpaceLoadFiles(['https://code.jquery.com/jquery-3.1.1.min.js'], function() {}); \n\tCIPHERSpaceLoadFilesDoAfter = function (callback) {\n\t\tvar newCallback = callback\n\t\tif (!!CIPHERSpaceLoadFileGlobalFileRef) {\n\t\t\tif (!!(CIPHERSpaceLoadFileGlobalFileRef.onload)) {\n\t\t\t\tvar oldCallback = CIPHERSpaceLoadFileGlobalFileRef.onload;\n\t\t\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = null;\n\t\t\t\tnewCallback = function () {\n\t\t\t\t\toldCallback();\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse CIPHERSpaceLoadFileGlobalFileRef = {};\n\t\tCIPHERSpaceLoadFileGlobalFileRef.onload = newCallback;\n\t}\n\nCIPHERSpaceLoadFilesDoAfter(function() { \n  if (typeof IntelliFactory !=='undefined')\n    IntelliFactory.Runtime.Start();\n  for (key in window) { \n    if (key.startsWith(\"StartupCode$\")) \n      try { window[key].$cctor(); } catch (e) {} \n  } \n})\n                 \"\"\" + js\n\nlet compile fThen fFail code =\n    EditorRpc.translate code false <|\n         (fun (jsO, msgs) ->\n             jsO\n             |> Option.map completeJS\n             |> function\n             | Some js -> fThen  msgs   js\n             | None    -> fFail  msgs\n          )\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},"expanded":true},{"name":"","content":"type RunNode(nodeName, ?clearNode: bool) =\n  let bClearNode    = defaultArg clearNode true\n  let createBaseNode () =\n      let el = JS.Document.CreateElement \"div\"\n      el.SetAttribute(\"id\", nodeName)\n      JS.Document.Body.AppendChild el |> ignore\n      el\n  let baseNode = \n      match JS.Document.GetElementById nodeName with\n      | null -> createBaseNode()\n      | node -> node\n  let runNode =\n      match baseNode.ShadowRoot with\n      | null -> let e = JS.Document.CreateElement \"div\"\n                baseNode.AttachShadow(Dom.ShadowRootInit(Dom.ShadowRootMode.Open)).AppendChild e |> ignore\n                e?style <- \"height: 100%; width: 100%;\"\n                e\n      | root -> root.FirstChild :?> Dom.Element\n  do if bClearNode then runNode.InnerHTML <- \"\"\nwith\n  new(?clearNode: bool) = RunNode(\"TestNode\", defaultArg clearNode true)\n  member this.RunNode   = runNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},"expanded":true},{"name":"AddBootstrap","content":"  member this.AddBootstrap =\n    JS.Document.CreateElement \"div\"\n    |> fun el -> \n        el.InnerHTML <- \n            @\"<script src='http://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript' charset='UTF-8'></script>\n            <script src='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js' type='text/javascript' charset='UTF-8'></script>\n            <link type='text/css' rel='stylesheet' href='http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>\n            <link type='text/css' rel='stylesheet' href='/EPFileX/css/main.css'>\n            \"\n        runNode.AppendChild el |> ignore\n    this","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"}],"companions":[],"id":{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},"expanded":true},{"name":"RunDoc","content":"  member inline this.RunDoc  doc  = doc  :> Doc       |> Doc.Run this.RunNode","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"f2571ac9-37ec-4d7c-9ead-9e5f79ae1be1"},{"$":0,"Item":"aba6c516-0ac9-4abe-95a2-7257d077e338"}],"companions":[],"id":{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"},"expanded":true},{"name":"RunHtml","content":"  member inline this.RunHtml node = node |> renderDoc |> this.RunDoc","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"c110a9c9-bc3b-4be7-8e5d-f43cc75f93ed"}],"companions":[],"id":{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"},"expanded":true},{"name":"RunHtmlPlusFree","content":"  member        this.RunHtmlPlusFree node =\n    let freeHtml    = Var.Create \"\"\n    let freeCSS     = Var.Create \"\"\n    let freeFS      = Var.Create \"\"\n    let freeJS      = Var.Create \"\"\n    let freeMsgs    = Var.Create \"\"\n    let sendMsg msg = \n        freeMsgs.Value  <- \n            match freeMsgs.Value, msg with\n            | null, m \n            | \"\"  , m\n            | m   , null\n            | m   , \"\"   -> m\n            | m1  , m2   -> m1 + \"\\n\" + m2\n    let runJS () =\n        sendMsg \"Running JavaScript...\"\n        try JS.Eval(freeJS.Value) |> (fun v -> sendMsg \"Done!\"; v.ToString())\n        with e -> sendMsg \"Failed!\"; e.ToString()\n        |> sendMsg\n    let runFS () =\n        freeMsgs.Value <- \"Compiling to JavaScript...\"\n        freeJS.Value   <- \"\"\n        compile (fun msgs js -> freeJS.Value <- js ; runJS() ) sendMsg freeFS.Value\n    div [ style \"height: 100%\"\n          node\n          Template.Button.New(\"Eval F#\").Style(\"vertical-align:top\").OnClick(fun _ _ -> runFS()                        ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"F#:\"         ; attr.title \"Add F# code and invoke with Eval F#\" ] freeFS\n          someElt <| Doc.InputArea [ attr.placeholder \"HTML:\"       ; attr.title \"Enter HTML tags and text\"            ] freeHtml \n          someElt <| Doc.InputArea [ attr.placeholder \"CSS:\"        ; attr.title \"Test your CSS styles dynamically\"    ] freeCSS \n          someElt <| Doc.InputArea [ attr.placeholder \"JavaScript:\" ; attr.title \"Add JS code and invoke with Eval JS\" ] freeJS\n          Template.Button.New(\"Eval JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> freeMsgs.Value <- \"\" ; runJS() ).Render  \n          someElt <| Doc.InputArea [ attr.placeholder \"Output:\"     ; attr.title \"Messages\"                            ] freeMsgs\n          SomeDoc <| tag Doc.Verbatim (Val.map2 (sprintf \"%s<style>%s</style>\") freeHtml freeCSS)\n    ]\n    |> this.RunHtml","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"companions":[],"id":{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},"expanded":true},{"name":"ShowHtmlResult","content":"  member inline this.ShowHtmlResult res =\n    this.AddBootstrap |> ignore\n    div [ ``class`` \"container\"\n          Template.Panel.New\n            .Title(\"Result:\")\n            .Header([])\n            .Content([ h3 res ; style \"font-family:monospace;\" ])\n            .Render\n     ] |> this.RunHtml\n  member inline this.ShowHtmlResult res = this.ShowHtmlResult [res]\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"0a11766b-f227-4b38-88a3-919d964387bf"},{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"3038cd62-093c-4385-aa9b-799297bd379c"}],"companions":[],"id":{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"},"expanded":true},{"name":"ShowResult","content":"  member inline this.ShowResult res = htmlText (sprintf \"%A\" res) |> this.ShowHtmlResult\n","parent":{"$":0,"Item":"e2ca8cb1-fb1e-4793-855f-55e3ca07b8f5"},"predecessors":[{"$":0,"Item":"bf400a85-8264-4540-9381-f3be0c968c94"}],"companions":[],"id":{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"},"expanded":true},{"name":"","content":"[<JavaScript>]\nmodule CodeEditor =\n","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"3709b431-1507-48ed-9487-dd49ce7be748"},{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"expanded":false},{"name":"","content":"type CodeSnippetId = CodeSnippetId of System.Guid        \nwith static member New = CodeSnippetId <| System.Guid.NewGuid()\n\nlet snippetName name (content: string) =\n        if name <> \"\" then name else \n        content.Trim()\n        |> (fun s -> if   s.StartsWith(\"[<\") \n                     then s.Split([| \">]\" |], System.StringSplitOptions.RemoveEmptyEntries) \n                          |> Array.tryItem 1 \n                     else Some s )\n        |> Option.bind (fun s ->\n             s.Trim()\n              .Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n             |> Seq.tryHead\n           )\n        |> Option.map (fun s -> s.Trim())\n        |> Option.defaultValue \"<empty>\"\n\ntype CodeSnippet = {\n    name         : string\n    content      : string\n    parent       : CodeSnippetId option\n    predecessors : CodeSnippetId list\n    companions   : CodeSnippetId list\n    id           : CodeSnippetId\n    expanded     : bool\n} with\n    member this.Name = snippetName this.name this.content\n\nlet codeSnippetsStorage = WebSharper.UI.Next.Storage.LocalStorage \"CodeSnippets\" Serializer.Typed<CodeSnippet>\nlet codeSnippets        = ListModel.CreateWithStorage<CodeSnippetId, CodeSnippet> (fun s -> s.id) codeSnippetsStorage\n//    let codeSnippets        = ListModel.Create<CodeSnippetId, CodeSnippet> (fun s -> s.id) []\n\nlet tryPickI f s = s |> Seq.indexed |> Seq.filter f |> Seq.tryHead\n\ntype CodeSnippet \n    with\n    static member PickIO id = codeSnippets.Value |> tryPickI (fun (_, snp) -> snp.id = id)\n    static member FetchO id = codeSnippets.TryFindByKey id\n    static member FetchL id = CodeSnippet.FetchO id |> Option.toList\n    static member New(            pred    , cnt) = CodeSnippet.New(\"\", None   , pred, [], cnt)\n    static member New(        pa, pred    , cnt) = CodeSnippet.New(\"\", Some pa, pred, [], cnt)\n    static member New(        pa,           cnt) = CodeSnippet.New(\"\", Some pa, []  , [], cnt)\n    static member New(                      cnt) = CodeSnippet.New(\"\", None   , []  , [], cnt)\n    static member New(    nm, pa, pred, co, cnt) = CodeSnippet.New(codeSnippets.Length, nm, pa, pred, co, cnt)\n    static member New(od, nm, pa, pred, co, cnt) =\n        let newS =\n            {\n                name         = nm\n                content      = cnt\n                parent       = pa\n                predecessors = pred\n                companions   = co\n                id           = CodeSnippetId.New\n                expanded     = true\n            }\n        match od, codeSnippets.Length with\n        | _, 0            -> codeSnippets.Append newS\n        | 0, _            -> codeSnippets.Set <| Seq.append [| newS |] codeSnippets.Value\n        | i, n when i < n -> codeSnippets.Value \n                                |> Seq.toArray\n                                |> Array.splitAt od\n                                |> fun (fst, snd) -> Array.append fst <| Array.append [| newS |] snd\n                                |> codeSnippets.Set \n        | _, _            -> codeSnippets.Append newS\n        newS\n    member this.UniquePredecesors() =\n        let rec preds (ins : CodeSnippetId list) outs : CodeSnippetId list =\n            match ins with\n            | []         -> outs\n            | hd :: rest -> List.collect id [ rest ; hd |> CodeSnippet.FetchL |> List.collect (fun s -> s.parent |> Option.toList |> List.append <| s.predecessors) ]\n                            |> preds <| if outs |> Seq.contains hd then outs else hd::outs\n        preds [ this.id ] []\n    member this.Level() =\n        let rec level snp out = \n            snp.parent\n            |> Option.bind CodeSnippet.FetchO\n            |> Option.map (fun p -> level p <| out + (if p.content.StartsWith \"namespace \" then 0 else 1)) \n            |> Option.defaultValue out\n        level this 0\n    member this.NameSanitized =\n        //let illegal = System.IO.Path.GetInvalidFileNameChars()\n        let illegal = [|'\"'   ; '<'   ; '>'   ; '|'   ; '\\000'; '\\001'; '\\002'; '\\003'; '\\004'; '\\005'; '\\006';\n                        '\\007'; '\\b'  ; '\\009'; '\\010'; '\\011'; '\\012'; '\\013'; '\\014'; '\\015';\n                        '\\016'; '\\017'; '\\018'; '\\019'; '\\020'; '\\021'; '\\022'; '\\023'; '\\024';\n                        '\\025'; '\\026'; '\\027'; '\\028'; '\\029'; '\\030'; '\\031'; ':'   ; '*'   ; '?';\n                        '\\\\'  ; '/'|]\n        this.Name\n        |> String.filter (fun c -> not <| Array.contains c illegal)\n        |> (fun c -> \"F# \" + c + \".fsx\")\n    member this.ContentIndented() =\n        let lvl = this.Level()\n        if lvl = 0 then this.content \n        else this.content.Split('\\n')\n                |> Array.map (fun l -> if l.StartsWith \"#\" then l else  (String.replicate lvl \"  \") + l)\n                |> String.concat \"\\n\"\n        |> sprintf \"# 1 @\\\"%s %s\\\"\\n%s\" (if lvl = 0 then \"\" else sprintf\"(%d)\" (lvl * 2)) this.NameSanitized\n    member this.Code() =\n        let preds = this.UniquePredecesors() |> Seq.toArray\n        codeSnippets.Value\n        |> Seq.filter (fun snp -> preds |> Array.contains snp.id)\n        |> Seq.map    (fun snp -> snp.ContentIndented()         )\n        |> String.concat \"\\n\"\n    member this.IsDescendantOf antId =\n        let rec isDescendantOf snp =\n            match snp.parent with\n            | None       -> false\n            | Some parId ->\n            if parId = antId then true else\n            CodeSnippet.FetchO parId\n            |> Option.map isDescendantOf\n            |> Option.defaultValue false\n        isDescendantOf this\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"},"expanded":true},{"name":"currentCodeSnippetId","content":"let missingVar  = Var.Create \"\"\nlet missing find lens k =\n    match find k with\n    | Some _ -> lens k\n    | None   -> missingVar.Lens (fun _ -> \"\") (fun _ _ -> \"\")\n    \nlet currentCodeSnippetId  = Var.Create <| CodeSnippetId.New\n\nlet refresh       = Var.Create()\nlet refreshView b = refresh.Value <- b\n\nlet currentCodeSnippetO = Val.map2 (fun k () -> codeSnippets.TryFindByKey k) currentCodeSnippetId refresh\n\nlet curSnippetNameOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.Name   ) (fun s n -> { s with name    = n }) <| k\nlet curSnippetCodeOf k = missing codeSnippets.TryFindByKey <| codeSnippets.LensInto (fun s -> s.content) (fun s n -> { s with content = n }) <| k\n    \ntype Position =\n    | Below\n    | Right\n    | Tab\n    | NewBrowser\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\"\n    \nlet position = Var.Create Below\n\nlet directionVertical    = \n    Val.map (fun pos -> \n        match pos with\n        | Right -> true\n        | _     -> false\n    ) position\n    \n    ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"2deb54e7-009e-4297-b2bc-1c86d04203a4"}],"companions":[],"id":{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"},"expanded":true},{"name":"CodeEditorMain","content":"let noSelection cur = CodeSnippet.FetchO cur = None\nlet noSelectionVal  = Val.map noSelection currentCodeSnippetId\n\nlet dirty    = Var.Create false \nlet codeFS   = Var.Create \"\"\nlet codeJS   = Var.Create \"\"\nlet codeMsgs = Var.Create \"\"\nlet sendMsg msg = \n    codeMsgs.Value  <- \n        match codeMsgs.Value, msg with\n        | null, m \n        | \"\"  , m\n        | m   , null\n        | m   , \"\"   -> m\n        | m1  , m2   -> m1 + \"\\n\" + m2\n\ndo Val.sink (fun m -> \n    JS.Window.Onbeforeunload <- \n        if m then System.Action<Dom.Event>(fun (e:Dom.Event) -> e?returnValue  <- \"Changes you made may not be saved.\")\n        else null\n    ) dirty \n\nlet setDirty() = dirty.Value <- true\nlet setClean() = dirty.Value <- false\n\nlet getFSCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> codeFS.Value <- snp.Code())\n\nlet evalIFrameJS success failure js =\n    createIFrame (fun frame ->\n        try\n             let window   = frame?contentWindow\n             let eval   s = JS.Apply window \"eval\" [| s |]\n             eval js           |> success\n        with e -> e.ToString() |> failure\n    )\n    |> RunCode.RunNode().RunHtml\n\nlet evalWindowJS success failure js =\n    let window       = JS.Apply JS.Window \"open\" [| JS.Window.Location.Origin + \"/Main.html\" ; \"NewWindow\" |]\n    match window with\n    | null -> failure \"could not open new browser. Popup blocker may be active.\"\n    | _    ->\n    600 \n    |> JS.SetTimeout (fun () -> \n        try\n             let eval   s = JS.Apply window   \"eval\" [| s |]\n             printfn \"Evaluating...\"\n             JS.Apply window   \"focus\" [|  |]\n             eval js           |> success\n        with e -> e.ToString() |> failure)\n    |> ignore\n                               \nlet runJS msgs js =\n    sendMsg \"Running JavaScript...\"\n    match position.Value with\n    | NewBrowser -> evalWindowJS\n    | _          -> evalIFrameJS\n    <| (fun res  -> sendMsg \"Done!\"   ; sendMsg res ; sendMsg msgs) \n    <| (fun res  -> sendMsg \"Failed!\" ; sendMsg res ; sendMsg msgs)\n    <| js\n\nlet compileSnippet fThen fFail =\n    CodeSnippet.FetchO currentCodeSnippetId.Value \n    |> Option.iter (fun snp -> \n        codeMsgs.Value <- \"Compiling to JavaScript...\"\n        codeJS.Value   <- \"\"\n        let code = snp.Code()\n        codeFS.Value   <- code\n        RunCode.compile (fun msgs js -> codeJS.Value <- js ; fThen msgs js) fFail code\n    )\n\nlet compileRun  () = compileSnippet runJS                                              sendMsg\nlet justCompile () = compileSnippet (fun msgs _ -> sendMsg \"Compiled!\" ; sendMsg msgs) sendMsg\n\nlet reorderSnippet toId fromId =\n    let trySnippet id = tryPickI (fun (_, snp) -> snp.id = id) \n    let moving, others = codeSnippets.Value |> Seq.toArray |> Array.partition (fun snp -> snp.id = fromId || snp.IsDescendantOf fromId)\n    match trySnippet fromId moving, trySnippet toId others with\n    | Some(_, snp), Some(ti, tsn) ->\n        [| others.[0..ti - 1] ; moving ; others.[ti..] |]\n        |> Array.collect id\n        |> codeSnippets.Set\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = tsn.parent }) snp.id\n    | _ -> ()\n    setDirty()\n    refreshView()\n\nlet indentCodeIn () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.iter (fun (j, snp) ->\n        let rec doPriorUntil f i =\n            if i < 0 then () else\n            if codeSnippets.Value |> Seq.item i |> f then () else\n            doPriorUntil f (i - 1)\n        j - 1 |> doPriorUntil (fun pri ->\n            if pri.parent = snp.parent \n            then codeSnippets.UpdateBy (fun c -> Some { c with parent = Some pri.id }) snp.id\n                 true\n            else false\n        )\n        setDirty()\n        refreshView()\n    )\n\nlet indentCodeOut () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp ->\n        let newP = snp.parent\n                   |> Option.bind CodeSnippet.FetchO\n                   |> Option.bind (fun p -> p.parent)\n        codeSnippets.UpdateBy (fun c -> Some { c with parent = newP }) snp.id\n        setDirty()\n        refreshView()\n    )\n\nlet mutable draggedId   = CodeSnippetId.New\nlet inline  draggable v = htmlAttribute \"draggable\"    v\n\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"79f8f6c6-d1f5-4593-9775-60ba2863e94d"},{"$":0,"Item":"a28fe808-236e-4b7e-9509-51ebe21e35fc"},{"$":0,"Item":"987560b0-1fe6-4835-ad99-aed93db7da1a"}],"companions":[],"id":{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"},"expanded":true},{"name":"let listEntry code =","content":"let isDirectPredecessor pre curO =\n    curO\n    |> Option.map (fun snp -> snp.predecessors |> List.contains pre)\n    |> Option.defaultValue false\n\nlet curPredecessors =\n    Val.map (   Option.map          (fun (snp:CodeSnippet) -> snp.UniquePredecesors())\n              >> Option.defaultValue [])  currentCodeSnippetO  \n\nlet isIndirectPredecessor pre predecessors = predecessors |> List.contains pre\n    \nlet togglePredecessorForCur (pre:CodeSnippet) curO =\n    curO |> Option.iter (fun cur ->\n        if cur = pre || isIndirectPredecessor cur.id (pre.UniquePredecesors()) then () else\n        let preds = \n            if cur.predecessors |> List.contains pre.id\n            then List.filter ((<>) pre.id)\n            else fun l -> pre.id :: l\n            <| cur.predecessors\n        codeSnippets.UpdateBy  (fun c -> Some { c with predecessors = preds }) cur.id\n        setDirty()\n        refreshView()\n    )\n\nlet toggleExpanded snp =\n    codeSnippets.UpdateBy  (fun c -> Some { c with expanded = not c.expanded }) snp.id\n    refreshView()\n\nlet listEntry isParent isExpanded code =\n    Template.Hoverable.New\n        .Content( [ \n                    ``class`` \"code-editor-list-tile\"\n                    classIf   \"selected\"              <| Val.map ((=)                   code.id) currentCodeSnippetId\n                    classIf   \"direct-predecessor\"    <| Val.map (isDirectPredecessor   code.id) currentCodeSnippetO\n                    classIf   \"indirect-predecessor\"  <| Val.map (isIndirectPredecessor code.id) curPredecessors\n                    draggable \"true\"\n                    SomeAttr <| on.dragOver(fun _ ev -> ev.PreventDefault()                                              )\n                    SomeAttr <| on.drag    (fun _ _  ->                                              draggedId <- code.id)\n                    SomeAttr <| on.drop    (fun _ ev -> ev.PreventDefault() ; reorderSnippet code.id draggedId           )\n                    span    [ ``class`` \"node\"\n                              classIf   \"parent\"   isParent\n                              classIf   \"expanded\" isExpanded\n                              SomeAttr <| on.click(fun _ _ -> if isParent then toggleExpanded code)\n                              title    <| if isParent then (if isExpanded then \"collapse\" else \"expand\") else \"\"\n                              htmlText <| if isParent then (if isExpanded then \"v\"        else \">\"     ) else \"\"\n                            ]\n                    div     [ ``class`` \"code-editor-list-text\"\n                              style1 \"text-indent\" (sprintf \"%dem\" <| code.Level())\n                              htmlText <| Val.map2 snippetName (curSnippetNameOf code.id) (curSnippetCodeOf code.id)\n                              SomeAttr <| on.click (fun _ _ -> currentCodeSnippetId.Value <- code.id)\n                            ]\n                    span    [ ``class``   \"predecessor\"\n                              title       \"toggle predecessor\"\n                              SomeAttr <| on.click(fun _ _ -> Val.iter (togglePredecessorForCur code) currentCodeSnippetO)\n                              htmlText    \"X\"\n                            ]\n                    ])\n        .Render\n\nlet listEntries snps =\n    snps\n    |> Seq.indexed\n    |> Seq.mapFold (fun expanded (i, snp) ->\n        if snp.parent |> Option.map (fun p -> Set.contains p expanded) |> Option.defaultValue true then \n            let isParent    = codeSnippets |> Seq.tryItem (i + 1) |> Option.map (fun nxt -> nxt.parent = Some snp.id) |> Option.defaultValue false\n            let isExpanded  = isParent && snp.expanded\n            (listEntry isParent isExpanded snp |> Some, if isExpanded then Set.add snp.id expanded else expanded)\n        else  (None, expanded)\n    )  (Set [])\n    |> fst\n    |> Seq.choose (Option.map renderDoc)\n    |> Doc.Concat","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"c7841be7-5cd5-40f3-b91c-c107b487bc0c"},{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"companions":[],"id":{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},"expanded":true},{"name":"","content":"let addCode () =\n    CodeSnippet.PickIO currentCodeSnippetId.Value\n    |> Option.map (fun (i, snp) -> CodeSnippet.New(i + 1, \"\", snp.parent, [], [], \"\"))\n    |> Option.defaultWith (fun _ -> CodeSnippet.New \"\")\n    |> fun n -> currentCodeSnippetId.Value <- n.id\n    setDirty()\n    refreshView()\n\n\nlet deleteCode () =\n    CodeSnippet.FetchO currentCodeSnippetId.Value\n    |> Option.iter (fun snp -> \n        if JS.Confirm (sprintf \"Do you want to delete %s?\" snp.Name) then\n            currentCodeSnippetId.Value <- CodeSnippetId.New\n            codeSnippets.Remove snp\n            setDirty()\n            refreshView()\n    )\n    \nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nlet fileName  = Var.Create \"\"\nlet emptyFile = Val.map (fun v -> v = \"\") fileName\n\nlet loadTextFile element (f: string -> unit) =\n    let files = element |> FileList.OfElement \n    if files.Length > 0 then\n        let  reader  = TextFileReader()\n        reader.Onload <- (fun e -> f e.Target?result)\n        reader.ReadAsText files.[0] \n\nlet fileInputElementId = \"CodeEditorFileSel\"\nlet loadFile (e: Dom.Element) =\n    if (not dirty.Value) || JS.Confirm \"Changes have not been saved, do you really want to load?\" then    \n      loadTextFile ((e.GetRootNode().FirstChild :?> Dom.Element).QuerySelector(\"#\" + fileInputElementId))\n        (fun txt ->\n            try\n                txt\n                |> Json.Deserialize<CodeSnippet[]>\n                |> codeSnippets.Set\n                setClean()\n                refreshView()\n            with e -> JS.Alert <| e.ToString()\n        )\n\n[< Inline \"saveAs(new Blob([$txt], {type: 'text/plain;charset=utf-8'}), $name)\" >]\nlet saveAs (txt:string) (name:string) = ()\n\nlet downloadFile() =\n    codeSnippets.Value\n        |> Seq.toArray\n        |> Json.Serialize\n        |> saveAs <| match justFileName fileName.Value with | \"\" -> \"snippets.fsjson\" | fname -> fname\n    setClean()\n\nlet loadFileElement =\n    Template.Input.New(fileName.Lens justFileName (fun prev n -> prev) )\n        .Prefix( label [ ``class`` \"btn btn-primary\" ; htmlText \"Load File...\" \n                         Template.Input.New(fileName)\n                                 .Type(\"file\")\n                                 .Style(\"display: none\")\n                                 .Content([ on.change (fun el _ -> loadFile el   )\n                                            on.click  (fun el _ -> el?value <- \"\")\n                                          ])\n                                 .Id(fileInputElementId)\n                                 .Render \n                        ]\n                )\n\nlet Do f = (fun _ _ -> f())","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"07e477d3-fb6e-4c83-bb89-b4b2cce55d7b"}],"companions":[],"id":{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},"expanded":true},{"name":"let styleEditor =","content":"let splitterV1 =\n    Template.SplitterBar.New.Value(20.0)\n      .Node(div [ ``class`` \"sliderv\"\n                  style \"width : 5px; grid-column: 2  ; grid-row: 2/4; margin-left: -7px; border: 0px; padding: 0px;\" ])\n\nlet splitterV2 =\n    Template.SplitterBar.New.Value(50.0).Max(Val.map ((-) 92.0) splitterV1.GetValue)\n      .Node(div [ ``class`` \"sliderv\"\n                  style \"width : 5px; grid-column: 3  ; grid-row: 3  ; margin-left: -7px; border: 0px; padding: 0px;\" ])\n      \nlet splitterH3 =\n    Template.SplitterBar.New.Value(17.0).Horizontal().Before\n      .Node(div [ ``class`` \"sliderh\"\n                  style \"height: 5px; grid-column: 2/4; grid-row: 3  ; margin-top : -7px; border: 0px; padding: 0px;\" ])\n\nlet styleEditorF sp1 sp2 sp3 =\n    sprintf \"\"\"\ndiv textarea {\nfont-family: monospace;\n}\n.code-editor-list-tile {\nwhite-space: nowrap; \nborder-style: solid none none;\nborder-color: white;\nborder-width: 1px;\nbackground-color: #D8D8D8;\ndisplay: flex;\n}\n.code-editor-list-text{\npadding: 1px 10px 1px 5px;\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\nflex: 1;\n}\n\n.code-editor-list-tile.direct-predecessor {\nfont-weight: bold;\n}\n.code-editor-list-tile.indirect-predecessor {\ncolor: blue;\n}\n.code-editor-list-tile.selected {\nbackground-color: #77F;\ncolor: white;\n}\n.code-editor-list-tile.hovering {\nbackground: lightgray;\n}\n.code-editor-list-tile.hovering.selected {\nbackground:  blue;\n}\n.code-editor-list-tile>.predecessor {\nfont-weight: bold;\nborder-style: inset;\nborder-width: 1px;\ntext-align: center;\ncolor: transparent;\n}\n.code-editor-list-tile.direct-predecessor>.predecessor {\ncolor: blue;\n}\n\n\n.CodeEditor {\n    display: grid;\n    grid-template-columns: %f%% %f%% minmax(0px, 97%%);\n    grid-template-rows: 4%% minmax(0px, 96%%) %f%% 10%%;\n    grid-template-areas:\n    \"header0 header   header\"\n    \"sidebar content1 content1\"\n    \"sidebar content2 content3\"\n    \"footer  footer   footer2\";\n    color: #333;\n    height: 100%%;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.CodeEditor > :nth-child(2){  grid-area: header  ; overflow: hidden;               }\n#Snippets                  {  grid-area: sidebar ; overflow: auto  ;               }\n#Code                      {  grid-area: content1; overflow: auto  ;               }\n#Output                    {  grid-area: content2; overflow: auto  ; resize: none; }\n#JScript                   {  grid-area: content3; overflow: auto  ; resize: none; }\n#AllCode                   {  grid-area: footer2 ; overflow: auto                  }\n#Buttons                   {  grid-area: footer  ;                                 }\n\n\n#Buttons { \n        display: grid;\n        grid-template-columns: repeat(8, 12.1%%);\n        bxackground-color: #eee;\n        padding : 5px;\n        grid-gap: 5px;\n}\n\n#Buttons > div       { grid-column: 4/6; grid-row: 1 }\n#Buttons > #Position { grid-column: 7  ; grid-row: 2 }\n#SaveAs              { grid-column: 4  ; grid-row: 2 }\n\n.CodeMirror {\n    height: 100%%;\n}\n\n.sliderv {\n    background-color: #eef;\n    cursor: col-resize;\n}\n.sliderh {\n    background-color: #eef;\n    cursor: row-resize;   \n}\n.node {\n    background-color:white; \n    width: 2ch; \n    color: #A03; \n    font-weight:bold; \n    text-align: center;\n    font-family: arial;\n}\n\n    \"\"\" sp1 sp2 sp3\n        \nlet styleEditor = htmlText <| Val.map3 styleEditorF splitterV1.GetValue splitterV2.GetValue splitterH3.GetValue\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"companions":[],"id":{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"},"expanded":true},{"name":"","content":"let CodeEditor() =\n  div [ ``class`` \"CodeEditor\"\n        div [ Id \"Snippets\"\n              codeSnippets.View\n              |> View.SnapshotOn codeSnippets.Value refresh.View\n              |> View.Map listEntries\n              |> Doc.BindView id |> SomeDoc\n            ]                     \n        Template.Input     .New(Val.bindIRef curSnippetNameOf currentCodeSnippetId).Prefix(htmlText \"name:\")                     .Render\n        Template.CodeMirror.New(Val.bindIRef curSnippetCodeOf currentCodeSnippetId).OnChange(setDirty ).Id(\"Code\"   )            .Render.AddChildren([style1 \"height\" \"100%\"])\n        Template.TextArea  .New(codeMsgs).Placeholder(\"Output:\"    ).Title(\"Messages\"                 ).Id(\"Output\" )            .Render\n        Template.TextArea  .New(codeFS  ).Placeholder(\"F# code:\"   ).Title(\"F# code assembled\"        ).Id(\"AllCode\")            .Render\n        Template.TextArea  .New(codeJS  ).Placeholder(\"Javascript:\").Title(\"JavaScript code generated\").Id(\"JScript\")            .Render\n        div [ Id \"Buttons\"\n              Template.Button.New(\"Add code\"       ).Class(\"btn btn-xs\"     ).OnClick(Do addCode      )                          .Render\n              Template.Button.New(\"<<\"             ).Class(\"btn btn-xs\"     ).OnClick(Do indentCodeOut).Disabled(noSelectionVal) .Render\n              Template.Button.New(\">>\"             ).Class(\"btn btn-xs\"     ).OnClick(Do indentCodeIn ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Compile\"        ).Class(\"btn btn-xs\"     ).OnClick(Do justCompile  ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Execute F#\"     ).Class(\"btn btn-xs\"     ).OnClick(Do compileRun   ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Get F# code -->\").Class(\"btn btn-xs\"     ).OnClick(Do getFSCode    ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Delete code\"    ).Class(\"btn btn-xs\"     ).OnClick(Do deleteCode   ).Disabled(noSelectionVal) .Render\n              Template.Button.New(\"Save as...\"     ).Class(\"btn            \").OnClick(Do downloadFile ).Id(\"SaveAs\")             .Render.AddChildren([classIf \"btn-primary\" dirty])\n              loadFileElement                                                                                                    .Render\n              Doc.Select [ attr.id \"Position\" ] positionTxt [ Below ; Right ; NewBrowser ] position |> someElt\n            ]\n        script [ src \"/EPFileX/FileSaver/FileSaver.js\" ; ``type`` \"text/javascript\" ] \n        styleH [ styleEditor                                                        ]\n        splitterV1                                                                                                               .Render\n        splitterV2                                                                                                               .Render\n        splitterH3                                                                                                               .Render\n     ]\n","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"93f32df7-da8b-472f-8bad-e82cc58ec52b"},{"$":0,"Item":"60191ea0-da20-4fbf-96b8-3871338a66d8"},{"$":0,"Item":"b417f7b1-5e53-4c51-a23f-6f2c8c5a77b7"},{"$":0,"Item":"3234a0bf-4541-4f2c-8bbf-b5ab3a0e415b"},{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"},{"$":0,"Item":"fa5b4506-b26d-4387-8e04-ac7a5a90861a"}],"companions":[],"id":{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"},"expanded":true},{"name":"CodeEditor page","content":"\n\nlet style1h = \"height : 5px; grid-column: 1/2  ; grid-row   : 2/3; margin-top : -7px; border: 0px; padding: 0px; background-color: #eef; cursor: row-resize\"\nlet style2h = \"height : 5px; grid-column: 1/2  ; grid-row   : 3/4; margin-top : -7px; border: 0px; padding: 0px; background-color: #eef; cursor: row-resize\"\nlet style1v = \"width  : 5px; grid-row   : 1/2  ; grid-column: 2/3; margin-left: -7px; border: 0px; padding: 0px; background-color: #eef; cursor: col-resize\"\nlet style2v = \"width  : 5px; grid-row   : 1/2  ; grid-column: 3/4; margin-left: -7px; border: 0px; padding: 0px; background-color: #eef; cursor: col-resize\"\n\nlet horizontalSplit : Printf.StringFormat<_> = \"\"\"\nbody {\n    display              : grid;\n    grid-template-rows   : %f%% %f%% %f%%;\n    grid-template-columns: 100%%;\n    grid-gap             :   9px;   \n    height               : 100vh;\n    overflow             : hidden;\n}\n\n#CodeEditor              { grid-row   : 2; overflow: hidden; }\n#TestNode                { grid-row   : 3; overflow: auto  ; }\nbody > div:first-of-type { grid-row   : 1; overflow: hidden; }\nbody > div               { grid-column: 1;                   }\n                               \"\"\"\nlet verticalSplit : Printf.StringFormat<_> = \"\"\"\nbody {\n    display              : grid;\n    grid-template-columns: %f%% %f%% %f%%;\n    grid-template-rows   : 100%%;\n    grid-gap             :   9px;   \n    height               : 100vh;\n    overflow             : hidden;\n}\n\n#CodeEditor              { grid-column: 2; overflow: hidden; }\n#TestNode                { grid-column: 3; overflow: auto  ; }\nbody > div:first-of-type { grid-column: 1; overflow: hidden; }\nbody > div               { grid-row   : 1;                   }\n                               \"\"\"\n\nlet style1 =\n    directionVertical\n    |> Val.map (fun dir ->\n        if dir then style1v\n        else        style1h)\n\nlet style2 = \n    directionVertical\n    |> Val.map (fun dir ->\n        if dir then style2v\n        else        style2h)\n\nlet styleSplit  = \n    directionVertical\n    |> Val.map (fun dir ->\n        if dir then verticalSplit\n        else        horizontalSplit)\n\nlet splitterMain1 =\n    Template.SplitterBar.New.Value( 0.0).Vertical(directionVertical).Min( 0.0).Max(35.0)\n      .Node(div [ style style1 ])\n\nlet splitterMain2 =\n    Template.SplitterBar.New.Value(24.0).Vertical(directionVertical).Min( 0.5).Max(Val.map (fun pos -> if pos = NewBrowser then 0.1 else 50.0) position).Before\n      .Node(div [ style style2 ])\n\nlet pageStyle =\n    Val.map3 (fun fmt v1 v2 -> \n        sprintf fmt v1 (98.0 - v1 - v2) v2) \n        styleSplit splitterMain1.GetValue splitterMain2.GetValue\n        \nlet addNodeById name (node:HtmlNode) =\n    match JS       .Document.GetElementById   name with\n    | null -> JS   .Document.CreateElement    \"div\"\n              |> JS.Document.Body.AppendChild :?> Dom.Element\n    | node -> node\n    |> fun el -> \n        Doc.RunReplace el (node.AddChildren [ Id name ] |> renderDoc)  \n        \nRunCode.RunNode(\"CodeEditor\").AddBootstrap.RunHtml <| CodeEditor()\naddNodeById \"pageStyle\"                            <| styleH [ htmlText pageStyle ]\naddNodeById \"splitterMain1\"                        <| splitterMain1.Render\naddNodeById \"splitterMain2\"                        <| splitterMain2.Render\n          ","parent":{"$":0,"Item":"c2188026-a06a-4963-a95a-93075e5f5b6e"},"predecessors":[{"$":0,"Item":"081bac32-e739-4124-87eb-eb7d6f2220bc"},{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"75c3d033-99b5-409f-8ecb-cd9bd8b101ab"}],"companions":[],"id":{"$":0,"Item":"07f11803-2084-4a0a-9066-a43fd11be1c7"},"expanded":true},{"name":"","content":"[< JavaScript >]\nmodule FSharpPlus =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"expanded":false},{"name":"","content":"//   <Compile Include=\"Extensions.fs\" />\n//   <Compile Include=\"Internals.fs\" />\n//   <Compile Include=\"Converter.fs\" />\n//   <Compile Include=\"Numeric.fs\" />\n//   <Compile Include=\"Monoid.fs\" />\n//   <Compile Include=\"Functor.fs\" />\n//   <Compile Include=\"Foldable.fs\" />\n//   <Compile Include=\"Traversable.fs\" />\n//   <Compile Include=\"Indexable.fs\" />\n//   <Compile Include=\"MonadTrans.fs\" />\n//   <Compile Include=\"Collection.fs\" />\n//   <Compile Include=\"Tuple.fs\" />\n//   <Compile Include=\"Operators.fs\" />\n//   <Compile Include=\"Builders.fs\" />\n//   <Compile Include=\"Identity.fs\" />\n//   <Compile Include=\"List.fs\" />\n//   <Compile Include=\"Seq.fs\" />\n//   <Compile Include=\"Option.fs\" />\n//   <Compile Include=\"Error.fs\" />\n//   <Compile Include=\"Cont.fs\" />\n//   <Compile Include=\"Reader.fs\" />\n//   <Compile Include=\"Writer.fs\" />\n//   <Compile Include=\"State.fs\" />\n//   <Compile Include=\"Monoids.fs\" />\n//   <Compile Include=\"Lens.fs\" />\n//   <Compile Include=\"NonEmptyList.fs\" />\n//   <Compile Include=\"ZipList.fs\" />\n//   <Compile Include=\"ParallelArray.fs\" />\n//   <Compile Include=\"Kleisli.fs\" />\n//   <Compile Include=\"Compatibility.fs\" />\n//   <None Include=\"SamplesFromFsControl\\Functions.fsx\" />\n//   <None Include=\"SamplesFromFsControl\\Haskell.fsx\" />\n//   <None Include=\"SamplesFromFsControl\\Collections.fsx\" />\n//   <None Include=\"SamplesFromFsControl\\Converter.fsx\" />\n//   <None Include=\"SamplesFromFsControl\\Numerics.fsx\" />\n//   <None Include=\"Samples\\Collections.fsx\" />\n//   <None Include=\"Samples\\Split-Join.fsx\" />\n//   <None Include=\"Samples\\Conversions.fsx\" />\n//   <None Include=\"Samples\\Applicatives.fsx\" />\n//   <None Include=\"Samples\\Monads.fsx\" />\n//   <None Include=\"Samples\\Comonads.fsx\" />\n//   <None Include=\"Samples\\MonadTransformers.fsx\" />\n//   <None Include=\"Samples\\ParallelArrays.fsx\" />\n//   <None Include=\"Samples\\ZipLists.fsx\" />\n//   <None Include=\"Samples\\Learn You a Haskell.fsx\" />\n//   <None Include=\"Samples\\Haskell.fsx\" />\n//   <None Include=\"Samples\\GenericMath.fsx\" />\n//   <None Include=\"Samples\\Lens.fsx\" />\n//   <None Include=\"Samples\\Prism.fsx\" />\n//   <None Include=\"Samples\\Fold.fsx\" />\n//   <None Include=\"Samples\\Traversal.fsx\" />\n//   <None Include=\"Samples\\Iso.fsx\" />\n//   <None Include=\"paket.references\" />\n//   <None Include=\"paket.template\" />\n//   <Content Include=\"App.config\" />\n// </ItemGroup>\n//   <Reference Include=\"mscorlib\" />\n//   <Reference Include=\"System\" />\n//   <Reference Include=\"System.Core\" />\n//   <Reference Include=\"System.Numerics\" />\n//#r \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.6.1\\System.Numerics.dll\"\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\net20\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\net40\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\net45\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\netstandard1.6\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\portable-net45+monoandroid10+monotouch10+xamarinios10\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\portable-net45+netcore45\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\portable-net45+netcore45+wp8\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\portable-net45+netcore45+wpa81+wp8\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\FSharp.Core\\lib\\portable-net45+sl5+netcore45\\FSharp.Core.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Collections\\ref\\netstandard1.0\\System.Collections.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Collections\\ref\\netstandard1.3\\System.Collections.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Collections.Concurrent\\lib\\netstandard1.3\\System.Collections.Concurrent.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Console\\ref\\netstandard1.3\\System.Console.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Diagnostics.DiagnosticSource\\lib\\netstandard1.3\\System.Diagnostics.DiagnosticSource.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Globalization\\ref\\netstandard1.0\\System.Globalization.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Globalization\\ref\\netstandard1.3\\System.Globalization.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Globalization.Calendars\\ref\\netstandard1.3\\System.Globalization.Calendars.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Globalization.Extensions\\ref\\netstandard1.3\\System.Globalization.Extensions.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.IO\\lib\\net462\\System.IO.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.IO\\ref\\netstandard1.0\\System.IO.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.IO\\ref\\netstandard1.3\\System.IO.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.IO\\ref\\netstandard1.5\\System.IO.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.IO.FileSystem\\ref\\netstandard1.3\\System.IO.FileSystem.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.IO.FileSystem.Primitives\\lib\\netstandard1.3\\System.IO.FileSystem.Primitives.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Linq\\lib\\netstandard1.6\\System.Linq.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Linq.Expressions\\lib\\netstandard1.6\\System.Linq.Expressions.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Linq.Queryable\\lib\\netstandard1.3\\System.Linq.Queryable.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Net.WebHeaderCollection\\lib\\netstandard1.3\\System.Net.WebHeaderCollection.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.ObjectModel\\lib\\netstandard1.3\\System.ObjectModel.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection\\lib\\net462\\System.Reflection.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection\\ref\\netstandard1.0\\System.Reflection.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection\\ref\\netstandard1.3\\System.Reflection.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection\\ref\\netstandard1.5\\System.Reflection.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection.Emit\\lib\\netstandard1.3\\System.Reflection.Emit.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection.Emit.ILGeneration\\lib\\netstandard1.3\\System.Reflection.Emit.ILGeneration.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection.Emit.Lightweight\\lib\\netstandard1.3\\System.Reflection.Emit.Lightweight.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection.Primitives\\ref\\netstandard1.0\\System.Reflection.Primitives.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Reflection.TypeExtensions\\lib\\netstandard1.5\\System.Reflection.TypeExtensions.dll</HintPath>\n//       <Reference Include=\"System.ComponentModel.Composition\">\n//       <Reference Include=\"System.ComponentModel.Composition\">\n//         <HintPath>..\\..\\packages\\System.Runtime\\lib\\net462\\System.Runtime.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Runtime\\ref\\netstandard1.0\\System.Runtime.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Runtime\\ref\\netstandard1.2\\System.Runtime.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Runtime\\ref\\netstandard1.3\\System.Runtime.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Runtime\\ref\\netstandard1.5\\System.Runtime.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Runtime.Handles\\ref\\netstandard1.3\\System.Runtime.Handles.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Runtime.Numerics\\lib\\netstandard1.3\\System.Runtime.Numerics.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.Algorithms\\ref\\netstandard1.6\\System.Security.Cryptography.Algorithms.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.Cng\\ref\\netstandard1.6\\System.Security.Cryptography.Cng.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.Csp\\ref\\netstandard1.3\\System.Security.Cryptography.Csp.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.Encoding\\ref\\netstandard1.3\\System.Security.Cryptography.Encoding.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.OpenSsl\\lib\\netstandard1.6\\System.Security.Cryptography.OpenSsl.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.Primitives\\lib\\netstandard1.3\\System.Security.Cryptography.Primitives.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Security.Cryptography.X509Certificates\\ref\\netstandard1.4\\System.Security.Cryptography.X509Certificates.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Text.Encoding\\ref\\netstandard1.0\\System.Text.Encoding.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Text.Encoding\\ref\\netstandard1.3\\System.Text.Encoding.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Text.RegularExpressions\\lib\\netstandard1.6\\System.Text.RegularExpressions.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Threading\\lib\\netstandard1.3\\System.Threading.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Threading.Tasks\\ref\\netstandard1.0\\System.Threading.Tasks.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Threading.Tasks\\ref\\netstandard1.3\\System.Threading.Tasks.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Threading.Tasks.Parallel\\lib\\netstandard1.3\\System.Threading.Tasks.Parallel.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Threading.Thread\\lib\\netstandard1.3\\System.Threading.Thread.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.Threading.ThreadPool\\lib\\netstandard1.3\\System.Threading.ThreadPool.dll</HintPath>\n//         <HintPath>..\\..\\packages\\System.ValueTuple\\lib\\portable-net40+sl4+win8+wp8\\System.ValueTuple.dll</HintPath>\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},"expanded":true},{"name":"Extensions","content":"\nopen System\n\n/// Additional operations on Option\nmodule Option =\n    let apply f x =\n            match (f,x) with \n            | Some f, Some x -> Some (f x) \n            | _              -> None\n\n\n/// Additional operations on Error\n[<RequireQualifiedAccess>]\nmodule Error =\n    let map f = function Choice1Of2 x -> Choice1Of2(f x) | Choice2Of2 x -> Choice2Of2 x\n    let apply f x =\n        match (f,x) with\n        | (Choice1Of2 a, Choice1Of2 b) -> Choice1Of2 (a b)\n        | (Choice2Of2 a, _)            -> Choice2Of2 a\n        | (_, Choice2Of2 b)            -> Choice2Of2 b :Choice<'b,'e>\n    let result x = Choice1Of2 x\n    let throw  x = Choice2Of2 x\n    let bind  (f:'t -> Choice<'v,'e>) = function Choice1Of2 v  -> f v | Choice2Of2 e -> Choice2Of2 e\n    let inline catch (f:'t -> Choice<'v,'e>) = function Choice1Of2 v  -> Choice1Of2 v | Choice2Of2 e -> f e\n\n\n/// Additional operations on Seq\nmodule Seq =\n    let bind (f:'a->seq<'b>) x = Seq.collect f x\n    let apply f x = bind (fun f -> Seq.map ((<|) f) x) f\n    let foldBack f x z = Array.foldBack f (Seq.toArray x) z\n\n    let chunkBy projection (source : _ seq) = seq {\n        use e = source.GetEnumerator()\n        if e.MoveNext() then\n            let g = ref (projection e.Current)\n            let members = ref (ResizeArray())\n            (!members).Add(e.Current)\n            while (e.MoveNext()) do\n                let key = projection e.Current\n                if !g = key then (!members).Add(e.Current)\n                else\n                    yield (!g, !members)\n                    g := key\n                    members := ResizeArray()\n                    (!members).Add(e.Current)\n            yield (!g, !members)}\n\n    // http://codebetter.com/matthewpodwysocki/2009/05/06/functionally-implementing-intersperse/\n    let intersperse sep list = seq {\n        let notFirst = ref false\n        for element in list do \n            if !notFirst then yield sep\n            yield element\n            notFirst := true}\n\n    let intercalate separator source = seq {\n        let notFirst = ref false\n        for element in source do \n            if !notFirst then yield! separator\n            yield! element\n            notFirst := true}\n\n    let split separators source =\n        let split options = seq {\n            match separators |> Seq.map Seq.toList |> Seq.toList with\n            | []         -> yield source\n            | separators ->\n                let buffer = ResizeArray()\n                let candidate = separators |> List.map List.length |> List.max |> ResizeArray\n                let mutable i = 0\n                for item in source do\n                    candidate.Add item\n                    match separators |> List.filter (fun sep -> sep.Length > i && item = sep.[i]) with\n                    | [] ->\n                        i <- 0\n                        buffer.AddRange candidate\n                        candidate.Clear()                    \n                    | seps ->\n                        if seps |> List.exists (fun sep -> sep.Length = i + 1) then\n                            i <- 0\n                            if options = StringSplitOptions.None || buffer.Count > 0 then yield buffer.ToArray() :> seq<_>\n                            buffer.Clear()\n                            candidate.Clear()                        \n                        else i <- i + 1\n                if candidate.Count > 0 then buffer.AddRange candidate\n                if options = StringSplitOptions.None || buffer.Count > 0 then yield buffer :> seq<_> }\n        split StringSplitOptions.None\n\n    let replace (oldValue:seq<'t>) (newValue:seq<'t>) (source:seq<'t>) :seq<'t> = seq {\n        let old = oldValue |> Seq.toList\n        if (old.Length = 0) then\n            yield! source\n        else\n            let candidate = ResizeArray(old.Length)\n            let mutable sindex = 0\n            for item in source do\n                candidate.Add(item)\n                if (item = old.[sindex]) then\n                    sindex <- sindex + 1\n                    if (sindex >= old.Length) then\n                        sindex <- 0\n                        yield! newValue\n                        candidate.Clear()                    \n                else\n                    sindex <- 0\n                    yield! candidate\n                    candidate.Clear()                \n            yield! candidate}\n\n    let drop i (source:seq<_>) =\n        let mutable count = i\n        use e = source.GetEnumerator()\n        while (count > 0 && e.MoveNext()) do count <- count-1\n        seq {while (e.MoveNext()) do yield e.Current}\n\n    let replicate count initial = Linq.Enumerable.Repeat(initial, count)\n\n\n/// Additional operations on List\nmodule List =\n    let singleton x = [x]\n    let cons x y = x :: y\n    let apply f x = List.collect (fun f -> List.map ((<|) f) x) f\n    let tails x = let rec loop = function [] -> [] | _::xs as s -> s::(loop xs) in loop x\n    let take i list = Seq.take i list |> Seq.toList\n\n    let skip i list =\n        let rec listSkip lst = function \n            | 0 -> lst \n            | n -> listSkip (List.tail lst) (n-1)\n        listSkip list i\n\n    let drop i list = \n        let rec loop i lst = \n            match (lst, i) with\n            | ([] as x, _) | (x, 0) -> x\n            | x, n -> loop (n-1) (List.tail x)\n        if i > 0 then loop i list else list\n\n    let intercalate (separator:list<_>) (source:seq<list<_>>) = source |> Seq.intercalate separator |> Seq.toList\n    let intersperse element source = source |> List.toSeq |> Seq.intersperse element |> Seq.toList                              : list<'T>\n    let split (separators:seq<list<_>>) (source:list<_>) = source |> List.toSeq |> Seq.split separators |> Seq.map Seq.toList\n    let replace oldValue newValue source = source |> List.toSeq |> Seq.replace oldValue newValue |> Seq.toList                  : list<'T>\n\n\n/// Additional operations on Array\nmodule Array =\n    let intercalate (separator:_ []) (source:seq<_ []>) = source |> Seq.intercalate separator |> Seq.toArray\n    let intersperse element source = source |> Array.toSeq |> Seq.intersperse element |> Seq.toArray                            : 'T []\n    let split (separators:seq<_ []>) (source:_ []) = source |> Array.toSeq |> Seq.split separators |> Seq.map Seq.toArray\n    let replace oldValue newValue source = source |> Array.toSeq |> Seq.replace oldValue newValue |> Seq.toArray                : 'T []\n\n\n/// Additional operations on String\nmodule String =\n    let split (separators:seq<string>) (source:string) = source.Split(Seq.toArray separators, StringSplitOptions.None) :> seq<_>\n    let replace (oldValue: string) newValue (source: string) = if oldValue.Length = 0 then source else source.Replace(oldValue, newValue)\n\n\n\n/// Module containing F#+ Extension Methods  \nmodule Extensions =\n\n    type Collections.Generic.IEnumerable<'T>  with\n        member this.GetSlice = function\n            | None  , None   -> this\n            | Some a, None   -> this |> Seq.skip a\n            | None  , Some b -> this |> Seq.take b\n            | Some a, Some b -> this |> Seq.skip a |> Seq.take (b-a+1)\n\n\n    type List<'T> with\n        \n        member this.GetSlice = function\n            | None  , None   -> this\n            | Some a, None   when a < 0 -> this |> List.skip (this.Length + a)\n            | Some a, None              -> this |> List.skip                a \n            | None  , Some b when b < 0 -> this |> List.take (this.Length + b)\n            | None  , Some b            -> this |> List.take                b\n            | Some a, Some b when a >= 0 && b >= 0 -> this |> List.skip a |> List.take b\n            | Some a, Some b -> \n                let l = this.Length\n                let f i = if i < 0 then l + i else i\n                let a = f a\n                this |> List.skip a |> List.take (f b - a + 1)\n\n         \n\n","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"}],"companions":[],"id":{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"},"expanded":true},{"name":"Internals","content":"//namespace FsControl.Internals\n\ntype Default5 = class end\ntype Default4 = class inherit Default5 end\ntype Default3 = class inherit Default4 end\ntype Default2 = class inherit Default3 end\ntype Default1 = class inherit Default2 end\n\nmodule Prelude =\n    let inline flip f x y = f y x\n    let inline const' k _ = k\n    let inline either f g = function Choice2Of2 x -> f x | Choice1Of2 y -> g y\n    let inline option n f = function None -> n | Some x -> f x\n    let inline isNull (value : 'T) =  match value with null -> true | _ -> false\n\n\n\n[<RequireQualifiedAccess>]\nmodule Implicit = \n    [<Inline>]\n    let inline Invoke (x : ^t) = ((^R or ^t) : (static member op_Implicit : ^t -> ^R) x) :^R\n\nmodule Errors =\n    let exnDivByZero      = new System.Exception \"Divide by Zero.\"\n    let exnNoDivision     = new System.Exception \"These numbers are not divisible in this domain.\"\n    let exnSqrtOfNegative = new System.Exception \"Cannot calculate square root of a negative number\"\n    let exnNoSqrt         = new System.Exception \"No square root defined for this value in this domain.\"\n    let exnNoSubtraction  = new System.Exception \"No subtraction defined for these values in this domain.\"\n\n\nmodule Rational =\n    [<Inline>] \n    let inline numerator   x = (^F: (member Numerator  : 'R) x)\n    [<Inline>] \n    let inline denominator x = (^F: (member Denominator: 'R) x)\n\n// Dummy types\n\ntype Id<'t>(v:'t) =\n   let value = v\n   member this.getValue = value\n\n[<RequireQualifiedAccess>]\nmodule Id =\n    let run   (x:Id<_>) = x.getValue\n    let map f (x:Id<_>) = Id (f x.getValue)\n    let create x = Id (x)\n\ntype Id0(v:string) =\n   let value = v\n   member this.getValue = value\n\ntype Either<'L,'R> = L of 'L | R of 'R\n\ntype DmStruct = struct end","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"e620b2e0-e518-4992-86f3-bc9623015345"},{"$":0,"Item":"1d18fdb5-2488-4ac9-813a-c96a66b9cd13"}],"companions":[],"id":{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"},"expanded":true},{"name":"Converter","content":"#nowarn \"77\" \n// Warn FS0077 -> Member constraints with the name 'op_Explicit' are given special status by the F# compiler as certain .NET types are implicitly augmented with this member. This may result in runtime failures if you attempt to invoke the member constraint from your own code.\n// But all simulated types are being handled so here Explicit is SAFE from runtime errors.\n\n\nopen System\nopen System.Runtime.CompilerServices\nopen System.Collections.Generic\nopen System.Text\nopen Microsoft.FSharp.Quotations\n//open FsControl.BaseLib\n//open FsControl.Internals\nopen FSharpPlus.Prelude\nopen FSharpPlus\n\n\ntype Explicit =\n    inherit Default1\n    static member inline Explicit (_:'R        , _:Default1) = fun (x : ^t) -> ((^R or ^t) : (static member op_Explicit : ^t -> ^R) x)\n    static member inline Explicit (_:^t when ^t: null and ^t: struct, _:Default1) = ()\n    static member inline Explicit (_:byte      , _:Explicit) = fun x -> byte            x\n    static member inline Explicit (_:sbyte     , _:Explicit) = fun x -> sbyte           x\n    static member inline Explicit (_:int16     , _:Explicit) = fun x -> int16           x\n    static member inline Explicit (_:uint16    , _:Explicit) = fun x -> uint16          x\n    static member inline Explicit (_:int32     , _:Explicit) = fun x -> int             x\n    static member inline Explicit (_:uint32    , _:Explicit) = fun x -> uint32          x\n    static member inline Explicit (_:int64     , _:Explicit) = fun x -> int64           x\n    static member inline Explicit (_:uint64    , _:Explicit) = fun x -> uint64          x\n    static member inline Explicit (_:nativeint , _:Explicit) = fun x -> nativeint  (int x)\n    static member inline Explicit (_:unativeint, _:Explicit) = fun x -> unativeint (int x)\n    static member inline Explicit (_:float     , _:Explicit) = fun x -> float           x\n    static member inline Explicit (_:float32   , _:Explicit) = fun x -> float32         x    \n    static member inline Explicit (_:decimal   , _:Explicit) = fun x -> decimal         x\n    static member inline Explicit (_:char      , _:Explicit) = fun x -> char            x\n\n    static member inline Invoke   value:'T      =\n        let inline call_2 (a:^a, b:^b) = ((^a or ^b) : (static member Explicit: _*_ -> _) b, a)\n        let inline call (a:'a) = fun (x:'x) -> call_2 (a, Unchecked.defaultof<'r>) x :'r\n        call Unchecked.defaultof<Explicit> value\n\ntype OfBytes =\n    static member OfBytes (_:bool   , _:OfBytes) = fun (x, i, _) -> BitConverter.ToBoolean(x, i)\n    static member OfBytes (_:char   , _:OfBytes) = fun (x, i, e) -> BitConverter.ToChar   (x, i, e)\n    static member OfBytes (_:float  , _:OfBytes) = fun (x, i, e) -> BitConverter.ToDouble (x, i, e)\n    static member OfBytes (_: int16 , _:OfBytes) = fun (x, i, e) -> BitConverter.ToInt16  (x, i, e)\n    static member OfBytes (_: int   , _:OfBytes) = fun (x, i, e) -> BitConverter.ToInt32  (x, i, e)\n    static member OfBytes (_:int64  , _:OfBytes) = fun (x, i, e) -> BitConverter.ToInt64  (x, i, e)\n    static member OfBytes (_:float32, _:OfBytes) = fun (x, i, e) -> BitConverter.ToSingle (x, i, e)\n    static member OfBytes (_:string , _:OfBytes) = fun (x, i, _) -> BitConverter.ToString (x, i)\n    static member OfBytes (_:uint16 , _:OfBytes) = fun (x, i, e) -> BitConverter.ToUInt16 (x, i, e)\n    static member OfBytes (_:uint32 , _:OfBytes) = fun (x, i, e) -> BitConverter.ToUInt32 (x, i, e)\n    static member OfBytes (_:uint64 , _:OfBytes) = fun (x, i, e) -> BitConverter.ToUInt64 (x, i, e)\n\n    static member inline Invoke (isLtEndian:bool) (startIndex:int) (value:byte[]) =\n        let inline call_2 (a:^a, b:^b) = ((^a or ^b) : (static member OfBytes: _*_ -> _) b, a)\n        let inline call (a:'a) = fun (x:'x) -> call_2 (a, Unchecked.defaultof<'r>) x :'r\n        call Unchecked.defaultof<OfBytes> (value, startIndex, isLtEndian)\n\n\n[<Extension;Sealed>]\ntype ToBytes =\n    [<Extension>]static member ToBytes (x:bool   , _, _:ToBytes) = BitConverter.GetBytes(x)\n    [<Extension>]static member ToBytes (x:char   , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x:float  , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x: int16 , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x: int   , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x:int64  , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x:float32, e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x:string , _, _:ToBytes) = Array.map byte (x.ToCharArray())\n    [<Extension>]static member ToBytes (x:uint16 , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x:uint32 , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n    [<Extension>]static member ToBytes (x:uint64 , e, _:ToBytes) = BitConverter.GetBytes(x, BitConverter.IsLittleEndian = e)\n\n    static member inline Invoke (isLittleEndian:bool) value :byte[] =\n        let inline call_2 (a:^a, b:^b, e) = ((^a or ^b) : (static member ToBytes: _*_*_ -> _) b, e, a)\n        let inline call (a:'a, b:'b, e) = call_2 (a, b, e)\n        call (Unchecked.defaultof<ToBytes>, value, isLittleEndian)\n\n\nopen System.Globalization\n\ntype TryParse =\n    static member inline TryParse (_:'t     option, _:TryParse) = fun x -> \n        let mutable r = Unchecked.defaultof< ^R>\n        if (^R: (static member TryParse: _ * _ -> _) (x, &r)) then Some r else None\n\n    static member TryParse (_:string        option, _:TryParse) = fun x -> Some x                             :option<string>\n    static member TryParse (_:StringBuilder option, _:TryParse) = fun x -> Some (new StringBuilder(x:string)) :option<StringBuilder>\n\n    static member inline Invoke (value:string) =\n        let inline call_2 (a:^a, b:^b) = ((^a or ^b) : (static member TryParse: _*_ -> _) b, a)\n        let inline call (a:'a) = fun (x:'x) -> call_2 (a, Unchecked.defaultof<'r>) x :'r\n        call Unchecked.defaultof<TryParse> value\n\n\ntype Parse =\n    inherit Default1\n    static member inline Parse (_:^R                  , _:Default1) = fun (x:string) -> (^R: (static member Parse: _ -> ^R) x)\n    static member inline Parse (_:^R                  , _:Parse   ) = fun (x:string) -> (^R: (static member Parse: _ * _ -> ^R) (x, CultureInfo.InvariantCulture))\n#if NET35\n#else\n    static member        Parse (_:'T when 'T : enum<_>, _:Parse   ) = fun x ->\n        (match Enum.TryParse(x) with\n            | (true, v) -> v\n            | _         -> invalidArg \"value\" (\"Requested value '\" + x + \"' was not found.\")\n        ):'enum\n#endif\n    static member Parse (_:bool         , _:Parse) = fun x -> Boolean.Parse(x)\n    static member Parse (_:char         , _:Parse) = fun x -> Char   .Parse(x)\n    static member Parse (_:string       , _:Parse) = id :string->_\n    static member Parse (_:StringBuilder, _:Parse) = fun x -> new StringBuilder(x:string)\n\n    static member inline Invoke    (value:string) =\n        let inline call_2 (a:^a, b:^b) = ((^a or ^b) : (static member Parse: _*_ -> _) b, a)\n        let inline call (a:'a) = fun (x:'x) -> call_2 (a, Unchecked.defaultof<'r>) x :'r\n        call Unchecked.defaultof<Parse> value\n\n\ntype ToString =\n    static member ToString (x:bool          , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:char          , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:byte          , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:sbyte         , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:float         , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:int16         , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:int           , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:int64         , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:float32       , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:string        , _:ToString) = fun (_:CultureInfo) -> if isNull x then \"null\" else x\n    static member ToString (x:Uri           , _:ToString) = fun (_:CultureInfo) -> if isNull x then \"null\" else x.ToString()\n    static member ToString (x:Id0           , _:ToString) = fun (_:CultureInfo) -> x.getValue\n    static member ToString (x:uint16        , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:uint32        , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:uint64        , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:decimal       , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:DateTime      , _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:DateTimeOffset, _:ToString) = fun (k:CultureInfo) -> x.ToString k\n    static member ToString (x:StringBuilder , _:ToString) = fun (_:CultureInfo) -> if isNull x then \"null\" else x.ToString()\n\n    static member inline Invoke (culture:CultureInfo) value : string =\n        let inline call_2 (a:^a, b:^b) = ((^a or ^b) : (static member ToString: _*_ -> _) b, a)\n        let inline call (a:'a, b:'b) = fun (x:'x) -> call_2 (a, b) x\n        call (Unchecked.defaultof<ToString>, value) culture\n\n\ntype ToString with \n    static member inline ToString (KeyValue(a,b), _:ToString) = fun (k:CultureInfo) -> \"(\" + ToString.Invoke k a + \", \" + ToString.Invoke k b + \")\"\n    static member inline ToString ((a,b)        , _:ToString) = fun (k:CultureInfo) -> \"(\" + ToString.Invoke k a + \", \" + ToString.Invoke k b + \")\"\n    static member inline ToString ((a,b,c)      , _:ToString) = fun (k:CultureInfo) -> \"(\" + ToString.Invoke k a + \", \" + ToString.Invoke k b + \", \" + ToString.Invoke k c + \")\"\n    static member inline ToString ((a,b,c,d)    , _:ToString) = fun (k:CultureInfo) -> \"(\" + ToString.Invoke k a + \", \" + ToString.Invoke k b + \", \" + ToString.Invoke k c + \", \" + ToString.Invoke k d + \")\"\n    static member inline ToString ((a,b,c,d,e)  , _:ToString) = fun (k:CultureInfo) -> \"(\" + ToString.Invoke k a + \", \" + ToString.Invoke k b + \", \" + ToString.Invoke k c + \", \" + ToString.Invoke k d + \", \" + ToString.Invoke k e + \")\"\n\n\ntype ToString with\n    static member inline internal seqToString (k:CultureInfo) sepOpen sepClose x (b: StringBuilder) =\n        let inline append (s:string) = b.Append s |> ignore\n        append sepOpen\n        let withSemiColons = Seq.intersperse \"; \" (Seq.map (ToString.Invoke k) x)\n        Seq.iter append withSemiColons\n        append sepClose\n        ToString.Invoke k b\n\ntype ToString with static member inline ToString (x:_ list, _:ToString) = fun (k:CultureInfo) ->\n                    let b = StringBuilder()\n                    ToString.seqToString k \"[\" \"]\" x b\n\ntype ToString with static member inline ToString (x:_ array, _:ToString) = fun (k:CultureInfo) ->\n                    let b = StringBuilder()\n                    ToString.seqToString k \"[|\" \"|]\" x b\n\ntype ToString with \n    static member inline ToString (x:_ ResizeArray, _:ToString) = fun (k:CultureInfo) ->\n                    let b = StringBuilder()\n                    b.Append \"ResizeArray \" |> ignore\n                    ToString.seqToString k \"[\" \"]\" x b\n    static member ToString (x:Expr<_>        , _:ToString) = fun (_:CultureInfo) -> x.ToString()\n\ntype ToString with static member inline ToString (x:_ seq, _:ToString) = fun (k:CultureInfo) ->\n                    let b = StringBuilder()\n                    b.Append \"seq \" |> ignore\n                    ToString.seqToString k \"[\" \"]\" x b\n\ntype ToString with static member inline ToString (x:_ ICollection, _:ToString) = fun (k:CultureInfo) ->\n                    ToString.Invoke k (x :> _ seq)\n\ntype ToString with static member inline ToString (x:_ IList      , _:ToString) = fun (k:CultureInfo) ->\n                    ToString.Invoke k (x :> _ seq)\n\ntype ToString with static member inline ToString (x:Map<_,_>     , _:ToString) = fun (k:CultureInfo) ->\n                    let b = StringBuilder()\n                    b.Append \"map \" |> ignore\n                    ToString.seqToString k \"[\" \"]\" x b\n\ntype ToString with \n    static member inline ToString (x:Dictionary<_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    ToString.Invoke k (x :> seq<KeyValuePair<_,_>>)\n\n    static member inline ToString (x:_ Set, _, _:ToString) = fun (k:CultureInfo) ->\n                    let b = StringBuilder()\n                    b.Append \"set \" |> ignore\n                    ToString.seqToString k \"[\" \"]\" x b\n\ntype ToString with static member inline ToString (x:IDictionary<_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    ToString.Invoke k (x :> seq<KeyValuePair<_,_>>)\n\ntype ToString with static member inline ToString (x:_ option, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Some a -> \"Some \" + ToString.Invoke k a\n                    | None   -> \"None\"\n\ntype ToString with static member inline ToString (x:Choice<_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Choice1Of2 a -> \"Choice1Of2 \" + ToString.Invoke k a\n                    | Choice2Of2 b -> \"Choice2Of2 \" + ToString.Invoke k b\n\ntype ToString with static member inline ToString (x:Choice<_,_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Choice1Of3 a -> \"Choice1Of3 \" + ToString.Invoke k a\n                    | Choice2Of3 b -> \"Choice2Of3 \" + ToString.Invoke k b\n                    | Choice3Of3 c -> \"Choice3Of3 \" + ToString.Invoke k c\n\ntype ToString with static member inline ToString (x:Choice<_,_,_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Choice1Of4 a -> \"Choice1Of4 \" + ToString.Invoke k a\n                    | Choice2Of4 b -> \"Choice2Of4 \" + ToString.Invoke k b\n                    | Choice3Of4 c -> \"Choice3Of4 \" + ToString.Invoke k c\n                    | Choice4Of4 d -> \"Choice4Of4 \" + ToString.Invoke k d\n\n\ntype ToString with static member inline ToString (x:Choice<_,_,_,_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Choice1Of5 a -> \"Choice1Of5 \" + ToString.Invoke k a\n                    | Choice2Of5 b -> \"Choice2Of5 \" + ToString.Invoke k b\n                    | Choice3Of5 c -> \"Choice3Of5 \" + ToString.Invoke k c\n                    | Choice4Of5 d -> \"Choice4Of5 \" + ToString.Invoke k d\n                    | Choice5Of5 e -> \"Choice5Of5 \" + ToString.Invoke k e\n\ntype ToString with static member inline ToString (x:Choice<_,_,_,_,_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Choice1Of6 a -> \"Choice1Of6 \" + ToString.Invoke k a\n                    | Choice2Of6 b -> \"Choice2Of6 \" + ToString.Invoke k b\n                    | Choice3Of6 c -> \"Choice3Of6 \" + ToString.Invoke k c\n                    | Choice4Of6 d -> \"Choice4Of6 \" + ToString.Invoke k d\n                    | Choice5Of6 e -> \"Choice5Of6 \" + ToString.Invoke k e\n                    | Choice6Of6 f -> \"Choice6Of6 \" + ToString.Invoke k f\n\ntype ToString with static member inline ToString (x:Choice<_,_,_,_,_,_,_>, _:ToString) = fun (k:CultureInfo) ->\n                    match x with\n                    | Choice1Of7 a -> \"Choice1Of7 \" + ToString.Invoke k a\n                    | Choice2Of7 b -> \"Choice2Of7 \" + ToString.Invoke k b\n                    | Choice3Of7 c -> \"Choice3Of7 \" + ToString.Invoke k c\n                    | Choice4Of7 d -> \"Choice4Of7 \" + ToString.Invoke k d\n                    | Choice5Of7 e -> \"Choice5Of7 \" + ToString.Invoke k e\n                    | Choice6Of7 f -> \"Choice6Of7 \" + ToString.Invoke k f\n                    | Choice7Of7 g -> \"Choice7Of7 \" + ToString.Invoke k g","parent":{"$":0,"Item":"4b9d8a3e-9910-4c51-8c34-f29782866424"},"predecessors":[{"$":0,"Item":"3d704638-8ba4-4bc8-b810-29e023a222fc"}],"companions":[],"id":{"$":0,"Item":"bd716e89-0546-4d6b-8964-26473ddcd121"},"expanded":true},{"name":"module Snippets =","content":"[< JavaScript >]\nmodule Tests =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"456562f7-0757-4431-9aeb-d58b050cecf7"},{"$":0,"Item":"c47adc01-4550-4830-8df5-e1ebedaee7d0"}],"companions":[],"id":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"expanded":false},{"name":"SlowlyChangingDimensions","content":"[< JavaScript >]\nmodule SlowlyChangingDimensions =","parent":{"$":0,"Item":"7479dc9d-94cd-4762-a1b8-cf6e09436c3f"},"predecessors":[{"$":0,"Item":"60bffe71-edde-4971-8327-70b9f5c578bb"}],"companions":[],"id":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"expanded":true},{"name":"","content":"let strOption: string -> string option =\n           fun txt    -> match txt.Trim() with\n                         | \"\" -> None\n                         | f  -> Some f\n\nlet tfldOption: TargetField -> TargetField option =\n            fun fld         -> match fld with | Nil  -> None | _ -> Some fld\n\nlet sfldOption: FinTransViewField -> FinTransViewField option =\n            fun fld         -> match fld with | Nil_ -> None | _ -> Some fld\n\nlet SurrogateKey  name           : Field =  name                   |> SurrogateKey \nlet BusinessKey   name           : Field =  name                   |> BusinessKey  \nlet SourceDate    name           : Field =  name                   |> SourceDate   \nlet IntraDayOrder name           : Field =  name                   |> IntraDayOrder   \nlet SCD2BeginDate name           : Field =  name                   |> SCD2BeginDate\nlet SCD2EndDate   name           : Field =  name                   |> SCD2EndDate  \nlet SCD2Current   name           : Field =  name                   |> SCD2Current  \nlet ChangeReason  name           : Field =  name                   |> ChangeReason  \nlet SCD0          name           : Field =  name                   |> SCD0         \nlet SCD1          name      scd0 : Field = (name, tfldOption scd0) |> SCD1         \nlet SCD2          name scd1 scd0 : Field = (name, tfldOption scd1                   \n                                                , tfldOption scd0) |> SCD2\n    \nlet fieldNames      :  Field -> string list =\n                   fun f     -> match f with \n                                | SCD2         (_, Some scd1, Some scd0) -> [ f.Name ; scd1.Name ; scd0.Name ]\n                                | SCD2         (_, _        , Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | SCD1         (_,            Some scd0) -> [ f.Name             ; scd0.Name ]\n                                | _                                      -> [ f.Name                         ]\n\nlet fieldSource     :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _\n                                | SCD2BeginDate _\n                                | SCD2EndDate   _\n                                | ChangeReason  _\n                                | SCD2Current   _            -> []\n                                | _                          -> [ f.Name ]\n\nlet fieldTarget    :  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  tfield\n                                | SCD2BeginDate tfield\n                                | SCD2EndDate   tfield\n                                | ChangeReason  tfield\n                                | SCD2Current   tfield                   -> [ tfield.Name            ]\n                                | SCD2         (_, Some scd1, Some scd0) -> [ scd1  .Name ; scd0.Name]\n                                | SCD2         (_, _        , Some scd0) -> [               scd0.Name]\n                                | SCD1         (_,            Some scd0) -> [               scd0.Name]\n                                | _                                      -> []\n\nlet fieldAlias      :  Field -> string =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> \"SurrogateKey_ \"\n                                | BusinessKey   _ -> \"BusinessKey_  \"\n                                | SourceDate    _ -> \"SourceDate_   \"\n                                | IntraDayOrder _ -> \"IntraDayOrder_\"\n                                | SCD2BeginDate _ -> \"SourceDate_   \"\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> \"\" \n                                | _               -> f.Name\nlet fieldAliasValue :  Field -> string -> string = \n                   fun f        v      -> sprintf \"%s = %s\" (pad4 (fieldAlias f)) v\n\nlet fieldSelectTable:  Field -> string list =\n                   fun f     -> match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f f.Name ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SCD2BeginDate _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> [] \n                                | _               -> [ f.Name ]\n\nlet fieldSelectSource: (string -> string) -> Field -> string list =\n                   fun transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAliasValue f \"NULL\"  ]\n                                | BusinessKey   _ -> [ fieldAliasValue f f.Name ]\n                                | SourceDate    _ -> [ fieldAliasValue f f.Name ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _\n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldSelectTogether1: (string -> string) -> Field -> string list =\n                   fun    transform             f     ->\n                                match f with \n                                | SurrogateKey  _ -> [ fieldAlias f |> transform ]\n                                | BusinessKey   _ -> [ fieldAlias f              ]\n                                | SourceDate    _ -> [ fieldAlias f              ]\n                                | IntraDayOrder _\n                                | SCD2BeginDate _ \n                                | ChangeReason  _\n                                | SCD2Current   _ \n                                | SCD2EndDate   _ -> []\n                                | _               -> [ transform f.Name ]\n\nlet fieldInsert     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f\n\nlet fieldValues     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (sprintf \"S.%s\")\n\nlet fieldUpdate     :  Field -> string list =\n                   fun f     -> match f with \n                                | SourceDate    _ \n                                | IntraDayOrder _\n                                | BusinessKey   _\n                                | SurrogateKey  _ -> []\n                                | _               -> fieldNames f |> List.map (fun n -> sprintf \"T.%s = S.%s\" (pad4 n) n)\n\nlet fieldSCD2Equal   : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _ -> [ sprintf \"S.%s = P.%s\" ( pad4 f.Name) f.Name ]\n                                | _      -> []\n                                \nlet fieldSCD2        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2 _             -> [ sprintf \"S.%s\" f.Name ]\n                                | _                  -> []\n\nlet fieldSCD0        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD1(_,    Some scd0) \n                                | SCD2(_, _, Some scd0) -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 scd0.Name) f.Name ]\n                                | SCD0 _                -> [ sprintf \"%s = FIRST_VALUE(S.%s) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\nlet fieldSCD1        : Field -> string list =\n                   fun f     -> match f with \n                                | SCD2(_, Some scd1, _) -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 scd1.Name) f.Name ]\n                                | SCD1 _                -> [ sprintf \"%s = LAST_VALUE(S.%s ) OVER (PARTITION BY S.BusinessKey_ ORDER BY S.NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 f.Name   ) f.Name ]\n                                | _                     -> []\n\ntype SQLTableView = {\n    db       : string option\n    schema   : string option\n    sqlObject: string\n    where    : string option\n    parms    : string option\n}\nwith member this.Reference   : string =\n                               match this.db, this.schema with\n                               | None   , None    -> sprintf \"%s\"\n                               | Some db, None    -> sprintf \"%s..%s\"   (nameS db)\n                               | Some db, Some sc -> sprintf \"%s.%s.%s\" (nameS db) (nameS sc)\n                               | None   , Some sc -> sprintf \"%s.%s\"               (nameS sc)\n                               <| nameS this.sqlObject\n     member this.Call        : string =\n                               match this.parms with\n                               | None    -> sprintf \"%s\"\n                               | Some ps -> fun r -> sprintf \"%s(%s)\" r ps\n                               <| this.Reference\n     member this.FromWhere   : string =\n                               match this.where with\n                               | None    -> sprintf \"%s\"\n                               | Some wh -> fun c -> sprintf \"%s WHERE %s \" c wh\n                               <| this.Call\n\n     static member New: string -> string ->  string  -> string -> string -> SQLTableView =\n                    fun db        schema     sobject    where     parms  -> {\n                                                                                db        = strOption db\n                                                                                schema    = strOption schema\n                                                                                sqlObject = sobject.Trim()\n                                                                                where     = strOption where \n                                                                                parms     = strOption parms\n                                                                            }\n\nlet indent : string  -> string =\n         fun content -> content.Split[| '\\n' |] |> String.concat \"\\n    \"\n\nlet indent2: string  -> string =\n         fun content -> \"    \" + (indent content)\n\ntype SQLWith = { \n    name   : string \n    content: string \n}\nwith override this.ToString()  = sprintf \"%s as (\\n%s\\n)\" this.name this.content\n     static member New: string -> string  -> SQLWith =\n                    fun name      content -> { name = name.Trim() ; content = indent2 content }\n\nlet sqlSelectP: string -> string -> string seq -> string =\n    fun         select    from      fields     -> \n        fields \n        |> String.concat \"\\n     , \"\n        |> sprintf \"%s %s\\n  FROM %s\" select <| from\n\nlet sqlSelect : string -> string seq -> string = sqlSelectP \"SELECT\"\nlet sqlSelectD: string -> string seq -> string = sqlSelectP \"SELECT Distinct\"\n\nlet sqlProcedure: string -> string  -> string  -> string=\n              fun name      parms      content -> \n                  sqlDropCreate PROCEDURE name\n                  |> sprintf \"%s %s\\n as \\n %s \\nGO\" <| parms <| content\n\nlet bSurrogateKey  = function | SurrogateKey  _ -> true | _ -> false\nlet bBusinessKey   = function | BusinessKey   _ -> true | _ -> false\nlet bSourceDate    = function | SourceDate    _ -> true | _ -> false\nlet bIntraDayOrder = function | IntraDayOrder _ -> true | _ -> false\nlet bSCD2BeginDate = function | SCD2BeginDate _ -> true | _ -> false\nlet bSCD2EndDate   = function | SCD2EndDate   _ -> true | _ -> false\nlet bChangeReason  = function | ChangeReason  _ -> true | _ -> false\nlet bSCD2Current   = function | SCD2Current   _ -> true | _ -> false\nlet bSCD2          = function | SCD2          _ -> true | _ -> false\n\ntype Dimension( tableBase : SQLTableView\n              , source    : SQLTableView\n              , fields    : Field  seq\n              , snowflakes: string seq\n              , extra     : Printf.StringFormat<_>) =\n     let isSnowflaked   = snowflakes |> Seq.isEmpty |> not\n     let countF filter  = fields |> Seq.filter filter |> Seq.length\n     let cSurrogateKey  = countF bSurrogateKey \n     let cBusinessKey   = countF bBusinessKey  \n     let cSourceDate    = countF bSourceDate   \n     let cIntraDayOrder = countF bIntraDayOrder\n     let cSCD2BeginDate = countF bSCD2BeginDate\n     let cSCD2EndDate   = countF bSCD2EndDate  \n     let cChangeReason  = countF bChangeReason  \n     let cSCD2Current   = countF bSCD2Current  \n     let cSCD2          = countF bSCD2\n     let table          = if isSnowflaked then { tableBase with sqlObject = \"SV_\" + tableBase.sqlObject } else tableBase\n     let duplicates     = fields |> Seq.collect fieldNames |> Seq.countBy (fun n -> n.Trim().ToUpper()) |> Seq.choose (fun (n, i) -> if i > 1 then sprintf \"Field %s appears more than once\" n |> Some else None) |> Seq.toList\n     let errors         = [\n                             if              cSurrogateKey  = 0 then yield \"A SurrogateKey  must be specified\"\n                             if              cBusinessKey   = 0 then yield \"A BusinessKey   must be specified\"\n                             if cSCD2 > 0 && cSourceDate    = 0 then yield \"A SourceDate    must be specified\"\n                             if cSCD2 > 0 && cIntraDayOrder = 0 then yield \"A IntraDayOrder must be specified\"\n                             if cSCD2 > 0 && cSCD2BeginDate = 0 then yield \"A SCD2BeginDate must be specified\"\n                             if cSCD2 > 0 && cSCD2EndDate   = 0 then yield \"A SCD2EndDate   must be specified\"\n                             if              cSurrogateKey  > 1 then yield \"Only 1 SurrogateKey  can be specified\"\n                             if              cBusinessKey   > 1 then yield \"Only 1 BusinessKey   can be specified\"\n                             if              cSourceDate    > 1 then yield \"Only 1 SourceDate    can be specified\"\n                             if              cIntraDayOrder > 1 then yield \"Only 1 IntraDayOrder can be specified\"\n                             if              cSCD2BeginDate > 1 then yield \"Only 1 SCD2BeginDate can be specified\"\n                             if              cSCD2EndDate   > 1 then yield \"Only 1 SCD2EndDate   can be specified\"\n                             if              cSCD2Current   > 1 then yield \"Only 1 SCD2Current   can be specified\"\n                             if              cChangeReason  > 1 then yield \"Only 1 ChangeReason  can be specified\"\n                             if cSCD2 = 0 && cSourceDate    = 1 then yield \"No SCD2 fields, SourceDate    cannot be specified\"\n                             if cSCD2 = 0 && cIntraDayOrder = 1 then yield \"No SCD2 fields, IntraDayOrder cannot be specified\"\n                             if cSCD2 = 0 && cSCD2BeginDate = 1 then yield \"No SCD2 fields, SCD2BeginDate cannot be specified\"\n                             if cSCD2 = 0 && cSCD2EndDate   = 1 then yield \"No SCD2 fields, SCD2EndDate   cannot be specified\"\n                             if cSCD2 = 0 && cSCD2Current   = 1 then yield \"No SCD2 fields, SCD2Current   cannot be specified\"\n                          ] @ duplicates\n     do if not errors.IsEmpty then failwith (errors |> String.concat \"\\n\")\n     let find  : (Field -> bool) -> string =\n             fun  ft             -> fields |> Seq.find ft |> fun f -> f.Name\n     let surrogateKey   = find bSurrogateKey\n     let businessKey    = find bBusinessKey\n     let sourceDateO    = if cSourceDate    = 1 then find bSourceDate    |> Some else None\n     let intraDayOrderO = if cIntraDayOrder = 1 then find bIntraDayOrder |> Some else None\n     let sCD2BeginDateO = if cSCD2BeginDate = 1 then find bSCD2BeginDate |> Some else None\n     let sCD2EndDateO   = if cSCD2EndDate   = 1 then find bSCD2EndDate   |> Some else None\n     let sCD2CurrentO   = if cSCD2Current   = 1 then find bSCD2Current   |> Some else None\n     let changeReasonO  = if cChangeReason  = 1 then find bChangeReason  |> Some else None \n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\n     let lastOfDay    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY %s, %s ORDER BY %s ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n businessKey (sourceDateO |> Option.defaultValue \"\") (intraDayOrderO |> Option.defaultValue \"\")\n     let together1    n = sprintf \"%s = LAST_VALUE(%s) OVER (PARTITION BY BusinessKey_, SourceDate_ ORDER BY SurrogateKey_ ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\" (pad4 n) n \nwith\n     new(table, source, fields            ) = Dimension(table, source, fields, []        , \"%s\")\n     new(table, source, fields, snowflakes) = Dimension(table, source, fields, snowflakes, \"%s\")\n     member this.TableReference     = table    .Reference\n     member this.TableBase          = tableBase\n     member this.Fields: (Field -> string list) -> string seq =\n                     fun chooser                  -> fields |> Seq.sort |> Seq.collect chooser\n     member this.AllFields          = this.Fields <| fieldNames\n     member this.FinTransViewFields = this.Fields <| fieldSource\n     member this.TargetFields       = this.Fields <| fieldTarget\n     member this.Existing           = this.Fields <| fieldSelectTable\n     member this.Source             = this.Fields <| fieldSelectSource    (if cSCD2 > 0 then lastOfDay else id)\n     member this.Together1          = this.Fields <| fieldSelectTogether1 (if cSCD2 > 0 then together1 else id)\n     member this.Together2          = [\n                                        sprintf \"NRec_  = ROW_NUMBER() OVER (PARTITION BY BusinessKey_ ORDER BY %s)\" <| if cSCD2 > 0 then \"SourceDate_, ISNULL(SurrogateKey_, 2147483647)\" else \"ISNULL(SurrogateKey_, 2147483647)\"\n                                        \"*\"\n                                      ]\n     member this.NewRec             = if cSCD2 > 0 then \n                                          this.Fields fieldSCD2Equal\n                                          |> String.concat \"\\n                 AND \"  \n                                          |> sprintf \"NewRec_ = IIF (%s, 0, 1)\"\n                                       else          \"NewRec_ = IIF (P.BusinessKey_ is NULL                  , 1, 0) \"\n     member this.Ordered            = [\n                                        yield                    \"S.SurrogateKey_ \"\n                                        yield                    \"S.BusinessKey_  \"\n                                        yield                    \"S.NRec_         \"\n                                        yield                    this.NewRec      \n                                        if cSCD2 > 0 then yield  \"S.SourceDate_   \"\n                                        yield!                   this.Fields fieldSCD2\n                                        yield!                   this.Fields fieldSCD1\n                                        yield!                   this.Fields fieldSCD0\n                                      ]\n     member this.SCD2Records        = [\n                                        \"SCD2Record_ = SUM(NewRec_    ) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\"\n                                        \"NextDate_   = MAX(SourceDate_) OVER (PARTITION BY BusinessKey_ ORDER BY NRec_ ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\"\n                                        \"LastRec_    = MAX(NRec_      ) OVER (PARTITION BY BusinessKey_)\"\n                                        \"*\"\n                                      ]\n     member this.VersBeg            = [\n                                        sCD2BeginDateO.Value |> pad4 |> sprintf \"%s = MIN(SourceDate_) OVER (PARTITION BY BusinessKey_, SCD2Record_)\"\n                                        sCD2EndDateO  .Value |> pad4 |> sprintf \"%s = DATEADD(d, -1, MAX(IIF(NRec_ = LastRec_, '9999-12-31', NextDate_)) OVER (PARTITION BY BusinessKey_, SCD2Record_))\"\n                                        \"*\"\n                                      ]\n     member this.RKeys              = [\n                                        if sCD2CurrentO.IsSome then \n                                           yield sCD2CurrentO.Value  |> pad4 |> sprintf \"%s = IIF(%s = '9999-12-30', 'Y', 'N')\"                       <| sCD2EndDateO.Value\n                                        yield    surrogateKey        |> pad4 |> sprintf \"%s = MAX(SurrogateKey_) OVER (PARTITION BY BusinessKey_ %s)\" <| if sCD2BeginDateO.IsSome  then  \", \" + sCD2BeginDateO.Value else \"\"\n                                        yield    businessKey         |> pad4 |> sprintf \"%s = BusinessKey_\"\n                                        if changeReasonO.IsSome then\n                                           yield changeReasonO.Value |> pad4 |> sprintf \"%s = '---'\"\n                                        yield    \"*\"\n                                      ]\n     member this.fromTogether2      = \"    Together2 S\n LEFT JOIN Together2 P ON P.BusinessKey_ = S.BusinessKey_\n                      AND P.NRec_        = S.NRec_ - 1\"\n     member this.Withs              =\n         [\n             yield    SQLWith.New \"Existing     \" <| sqlSelect  table .FromWhere              this.Existing \n             yield    SQLWith.New \"Source       \" <| sqlSelectD source.FromWhere              this.Source   \n             yield    SQLWith.New \"Together0    \" <| \"SELECT *  FROM Existing UNION ALL SELECT * FROM Source\"\n             yield    SQLWith.New \"Together1    \" <| sqlSelectD \"Together0\"                   this.Together1\n             yield    SQLWith.New \"Together2    \" <| sqlSelect  \"Together1          \"         this.Together2\n             yield    SQLWith.New \"Ordered      \" <| sqlSelect  this.fromTogether2            this.Ordered     \n             if cSCD2 > 0 then                                  \n                yield SQLWith.New \"SCD2Records  \" <| sqlSelect  \"Ordered            \"         this.SCD2Records \n                yield SQLWith.New \"VersBeg      \" <| sqlSelect  \"SCD2Records        \"         this.VersBeg     \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"VersBeg            \"         this.RKeys     \n             else                                               \n                yield SQLWith.New \"RKeys        \" <| sqlSelect  \"Ordered            \"         this.RKeys     \n         ]\n     member this.LastWith           = this.Withs |> Seq.last\n     member this.SelectIntoTemp     = if isSnowflaked then sprintf \"    , NewSurrogateKey_ = NEXT VALUE FOR Seq_%s\\n\" this.TableBase.sqlObject else \"\"\n                                      |> sprintf \"SELECT * \\n%s   INTO #TEMP\\n  FROM %s \\n WHERE NewRec_ = 1\" <| this.LastWith.name                                       \n     member this.Insert             = this.Fields fieldInsert\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   INSERT(%s %s)\" (if isSnowflaked then sprintf \"%s\\n,\" surrogateKey  else \"\")\n                                      |> indent  |> indent\n     member this.Values             = this.Fields fieldValues\n                                      |> String.concat \"\\n, \"\n                                      |> sprintf \"   VALUES(%s %s)\\n\" (if isSnowflaked then \"NewSurrogateKey_\\n,\" else \"\")\n                                      |> indent  |> indent\n     member this.Update             = this.Fields fieldUpdate\n                                      |> String.concat \"\\n, \"\n                                      |> indent |> indent\n     member this.WhenNotMatched     = sprintf \"WHEN NOT MATCHED BY TARGET THEN\\n%s\\n%s\" \n                                      <| this.Insert            <| this.Values\n     member this.WhenMatched        = (fun f -> if f <> \"\" then sprintf \"WHEN MATCHED THEN\\nUPDATE SET %s\" f else f)\n                                      <| this.Update\n     member this.Merge              = sprintf \"MERGE %s AS T\\nUSING #TEMP AS S\\nON (T.%s = S.%s)\\n%s\\n%s;\" \n                                      <| this.TableReference \n                                      <| surrogateKey        <| surrogateKey\n                                      <| this.WhenNotMatched\n                                      <| this.WhenMatched\n     member this.Query              = this.Withs\n                                      |> List.map (fun w -> w.ToString())\n                                      |> String.concat \", \"\n                                      |> sprintf \"WITH %s\"\n                                      |> sprintf \"%s \\n%s; \\n%s\" <| this.SelectIntoTemp <| this.Merge\n     member this.Procedure          = this.Query\n                                      |> sprintf \"BEGIN\\n  EXEC GENERIC.Log @SOURCE, '%s', 'Started Merge', '';\\n  %s\\n END\\n\" procedureName\n                                      |> sqlProcedure procedureName \"@SOURCE VARCHAR(30), @CURRENT_DTE DATE = NULL\" \n     member this.ProcedureName      = procedureName\n     member this.SurrogateKey       = surrogateKey\n     member this.BusinessKey        = businessKey\n     member this.SourceDateO        = sourceDateO\n     member this.SCD2BeginDateO     = sCD2BeginDateO\n     member this.SCD2EndDateO       = sCD2EndDateO  \n     member this.TableName          = table.sqlObject\n     member this.Verification       = sCD2BeginDateO \n                                      |> Option.map (fun b ->\n                                            let e = sCD2EndDateO.Value\n                                            sprintf \" AND (D.%s BETWEEN X.%s AND X.%s  OR D.%s BETWEEN X.%s AND X.%s ) \" b b e  e b e\n                                         )\n                                      |> defaultValue \"\"\n                                      |> sprintf \"SELECT * \\n  FROM %s D \\n WHERE EXISTS(SELECT * \\n         FROM %s X \\n      WHERE X.%s <> D.%s AND X.%s = D.%s %s) \\n ORDER BY %s %s\" \n                                            table.Reference table.Reference\n                                            surrogateKey    surrogateKey    \n                                            businessKey     businessKey\n                                      <| businessKey <| \"\"\n     member this.Snowflakes         = snowflakes\n                                      \n                                    \ntype FactField = \n    | Fact   of FinTransViewField\n    | OField of TargetField * value: string\n\nlet OField: TargetField -> string -> FactField = \n        fun fld            value  -> (fld, value.Trim()) |> OField\n\ntype DimRef =\n    | DimRef of Dimension * SurrogateKey: TargetField option * BusinesKey: FinTransViewField option\nwith\n     member this.Dim                = match this with                                      DimRef (dim, _   , _) -> dim\n     member this.FactSurrogateKey   = match this with | DimRef (dim, Some key, _) -> key.Name | DimRef (dim, None, _) -> dim.SurrogateKey\n     member this.FactBusinessKey    = match this with | DimRef (dim, _, Some key) -> key.Name | DimRef (dim, _, None) -> dim.BusinessKey\n     member this.FinTransViewFields = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! bKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.FinTransViewFields ]\n     member this.TargetFields       = match this with | DimRef (dim, sKO, bKO) -> seq [ yield! sKO |> Option.map (fun f -> f.Name) |> Option.toList ; yield! dim.TargetFields       ]\n     static member New dim                             = DimRef(dim, None             , None            )\n     static member New(dim, surrogateKey             ) = DimRef(dim, Some surrogateKey, None            )\n     static member New(dim, surrogateKey, businessKey) = DimRef(dim, Some surrogateKey, Some businessKey)\nlet dimension: Dimension -> TargetField -> FinTransViewField -> DimRef = \n           fun dim          surroK         businK      -> DimRef (dim, tfldOption surroK, sfldOption businK)\n\ntype FactTable( table  : SQLTableView\n              , source : SQLTableView\n              , dims   : DimRef    seq\n              , fields : FactField seq\n              , extra  : Printf.StringFormat<_>) =\n     let procedureName  = sprintf \"GENERIC.SP_LOAD_%s\" table.sqlObject\nwith \n     member this.SourceFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(_, f) -> f\n                                             )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.FinTransViewFields))\n                                  |> Seq.distinct\n     member this.TargetFields   = fields \n                                  |> Seq.collect (function \n                                                  | Fact f       -> []\n                                                  | OField(f, _) -> [ f.Name ]\n                                                 )\n                                  |> Seq.append (dims |> Seq.collect (function dimR -> dimR.TargetFields))\n                                  |> Seq.distinct\n     member this.Keys           = dims |> Seq.mapi(fun i dim -> sprintf \"D%d.%s\" i dim.Dim.SurrogateKey)\n     member this.Joins          = dims \n                                  |> Seq.mapi(fun i dim -> \n                                                    dim.Dim.SourceDateO\n                                                    |> Option.map (fun v -> sprintf \" AND S.%s BETWEEN D%d.%s AND D%d.%s\" v i dim.Dim.SCD2BeginDateO.Value i dim.Dim.SCD2EndDateO.Value)\n                                                    |> defaultValue \"\"\n                                                    |> sprintf \"%s D%d ON D%d.%s = S.%s %s\" (pad2 dim.Dim.TableBase.Reference) i i (pad2 dim.Dim.BusinessKey) (pad2 dim.FactBusinessKey)\n                                             )\n                                  |> Seq.toList                                                                 \n     member this.From           = sprintf \"%s S\" source.FromWhere\n                                  :: this.Joins\n                                  |> String.concat \"\\n LEFT JOIN \"\n     member this.Query          = fields \n                                  |> Seq.map (function \n                                              | Fact   f     -> sprintf \"S.%s\"    f.Name\n                                              | OField(f, v) -> sprintf \"%s = %s\" (pad2 f.Name) v\n                                             )\n                                  |> Seq.append this.Keys \n                                  |> sqlSelect this.From\n     member this.InsertFields   = fields \n                                  |> Seq.map (function \n                                              | Fact f       -> f.Name\n                                              | OField(f, _) -> f.Name\n                                             )\n                                  |> Seq.append (dims |> Seq.map (fun dim -> dim.FactSurrogateKey))\n                                  |> String.concat \"\\n     , \"\n     member this.Insert         = sprintf \"INSERT INTO %s\\n      (%s)\\n%s\" table.Reference this.InsertFields this.Query\n                                  |> sprintf extra\n     member this.Procedure      = sqlProcedure procedureName \"@SOURCE VARCHAR(30), @FROM DATE = NULL, @TO DATE = NULL\" this.Insert\n\nlet print: string -> unit =\n       fun txt    -> printf \"\\n\\n%s\\n\\n\" txt\n\nlet FinTransViewFields: FactTable -> Dimension seq -> string seq =\n    fun                 fTable       dims          -> \n        fTable.SourceFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.FinTransViewFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\nlet targetFields: FactTable -> Dimension seq -> string seq =\n    fun           fTable       dims          -> \n        fTable.TargetFields \n        |> Seq.append     (dims |> Seq.collect (fun dim -> dim.TargetFields))\n        |> Seq.filter     isIdentifier\n        |> Seq.distinctBy (fun f -> f.ToUpper())\n        |> Seq.sort\n\n\nlet getDecl: string -> (string * bool) option =\n         fun fname  -> FieldDecl.fieldDecl\n                       |> Seq.choose (fun (name, typeDecl, nullable) -> if name = fname.ToUpper() then (typeDecl, nullable = 1) |> Some else None)\n                       |> Seq.tryHead\n\nlet getDefault: string -> string option =\n            fun fname  -> FieldDefault.fieldDefault\n                          |> Array.tryPick (fun (name, value) -> if name = fname.ToUpper() then Some value else None)\n\nlet convert fName v =\n    getDecl fName \n    |> Option.map (fun (fType, nullable) -> fType.Trim())\n    |> Option.map (fun typeName -> sprintf \"CONVERT(%s, %s)\"  typeName v) \n    |> Option.defaultValue v\n\nlet applyDefault fName v =\n    getDecl fName \n    |> Option.bind (fun (fType, nullable) ->\n           if nullable then None\n           else getDefault fName\n           |> Option.map (sprintf \"ISNULL(%s, %s)\" v)\n    )\n    |> Option.defaultValue v\n\nlet equalField fName v =\n    fName\n    |> nameS\n    |> pad4 \n    |> sprintf \"%s = %s\"  <| v\n\ntype FinTransViewField\nwith \n    \n    member this.Convert      v = convert      this.Name v\n    member this.applyDefault v = applyDefault this.Name v\n    member this.equal        v = equalField   this.Name v\n    member this.DefaultO       = getDefault   this.Name\n\nlet cast: FinTransViewField -> string -> string =\n      fun field                value  ->\n          value\n          |> field.Convert\n          |> field.applyDefault \n          |> field.equal\n\ntype QueryField(target: FinTransViewField, value: string) =\n    let name = target.Name\nwith\n    member this.Entry = cast target value\n    member this.Name  = name\n\nlet vwField: FinTransViewField -> string -> QueryField = \n         fun fld                  value  -> QueryField(fld, value.Trim())\n\n\nlet inline getUnionNames typ =\n    Microsoft.FSharp.Reflection.FSharpType.GetUnionCases typ\n    |> Seq.map (fun e -> e.Name |> aNumeral)\n    |> Seq.filter ((<>)\"Nil_\")\n    |> Seq.sort\n    |> Seq.toArray\n\nlet finTransViewFieldNames = getUnionNames typeof<FinTransViewField>\nlet targetFieldNames   = getUnionNames typeof<TargetField>\n\nlet missingFields: QueryField seq -> string[] =\n    fun            fields         -> \n        finTransViewFieldNames\n        |> Array.filter (fun e -> fields |> Seq.exists (fun f -> f.Name = e) |> not)\n\nlet allFields() = missingFields (seq[])\n                  |> Seq.sort\n                  |> String.concat \"\\n        , \"\n\nlet setDefault: string -> string =\n            fun field  -> getDefault    field \n                          |> Option.defaultValue \"(NULL)\" \n                          |> convert    field\n                          |> equalField field\n\ntype FactView(name: SQLTableView, source: SQLTableView, fields: QueryField seq) =\n    let fieldsCached = fields |> Seq.toArray\n    let getFieldValue fName =\n        fieldsCached \n        |> Array.tryFind      (fun q -> q.Name    = fName)\n        |> Option.map         (fun q -> q.Entry          )\n        |> Option.defaultWith (fun _ -> setDefault  fName)\nwith\n     member this.Query = finTransViewFieldNames \n                         |> Array.map  getFieldValue\n                         |> String.concat \"\\n        , \"\n                         |> sprintf \"SELECT %s\\n FROM %s;\\n\" <| source.FromWhere\n                         |> sprintf \"%s\\n as %s; \\nGO\" (sqlDropCreate VIEW name.Call)\n\nlet missingDefaults() =\n    finTransViewFieldNames \n    |> Seq.map    (fun n -> n, getDecl n, getDefault n)\n    |> Seq.filter (fun (n, typeO, defO) -> \n         match typeO, defO with\n         | None               , _\n         | Some (_    , false), None -> true\n         | _                         -> false\n    )\n    |> Seq.map     (fun (n, typO, _) ->\n        (n, typO, \n            match typO with\n            | Some(\"int\"       , _) -> \"0\"\n            | Some(\"varchar(1)\", _)\n            | Some(\"varchar(2)\", _) -> \"'*'\"\n            | Some(\"date\"      , _) \n            | Some(\"datetime\"  , _) -> \"'1900-01-01'\"\n            | _                     -> \"'***'\"\n        )\n    )\n\nlet missingDecls () =\n    FieldDecl.fieldDecl\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    |> Array.filter(fun (n, typ, nullable) -> Seq.exists ((=)n) finTransViewFieldNames |> not)\n    \n\nlet inline str4 s = s |> sprintf \"%A\" |> pad4 \nlet inline str2 s = s |> sprintf \"%A\" |> pad2 \n\n(*          \n(*keep*)#load \"BetterFSI.fsx\"  // <<<==== Execute first in F# Interactive\nDo __SOURCE_FILE__ __LINE__ //\nDo __SOURCE_FILE__ __LINE__ //  missingDecls()    |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (printfn \"%A\")\nDo __SOURCE_FILE__ __LINE__ //  missingDefaults() |> Seq.iter (fun (n, _, d) -> printfn \"(%s, %s)\" (str4 n) (str2 d))\nDo __SOURCE_FILE__ __LINE__ //  finTransViewFieldNames |> Seq.filter (fun a -> a.StartsWith \"A#\" ) |>\n*)\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"0da8d01b-168f-4816-9895-99fb9f2e4a7b"},"expanded":true},{"name":"","content":"let isIdentifier: string -> bool =\n              fun txt    -> regexIdentifier.IsMatch txt\n\nlet nameS fName = \n    if isIdentifier fName \n    then fName \n    else sprintf \"[%s]\" fName\n\ntype TargetField\nwith\n     member this.Name = toString this\n\ntype FinTransViewField\nwith\n     member this.Name = toString this\n\ntype Field =\n    | SurrogateKey   of TargetField\n    | BusinessKey    of FinTransViewField\n    | SourceDate     of FinTransViewField\n    | IntraDayOrder  of  FinTransViewField\n    | SCD2BeginDate  of TargetField\n    | SCD2EndDate    of TargetField\n    | SCD2Current    of TargetField\n    | ChangeReason   of TargetField\n    | SCD2           of FinTransViewField * scd1:TargetField option * scd0:TargetField option /// Version  value\n    | SCD1           of FinTransViewField * scd0:TargetField option                           /// Current  value\n    | SCD0           of FinTransViewField                               /// SCD0 without accompanying SCD1 or 2\nwith member this.Name0 = \n        match this with\n        | SurrogateKey   tfield\n        | SCD2BeginDate  tfield\n        | SCD2EndDate    tfield\n        | ChangeReason   tfield\n        | SCD2Current    tfield        -> tfield.Name\n        | BusinessKey    sfield\n        | SourceDate     sfield\n        | IntraDayOrder  sfield\n        | SCD2          (sfield, _, _) \n        | SCD1          (sfield, _   ) \n        | SCD0           sfield        -> sfield.Name\n     member this.Name = this.Name0 |> nameS","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"10ce00fc-1e98-45e3-ba5b-96e0424e8c1c"},"expanded":true},{"name":"","content":"let sqlDropCreate: sqlObjectType -> string -> string =\n               fun sqlType          name   -> sprintf \"\"\"\nIF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'%s') AND type %s)\n    DROP %s %s;\nGO\n-- Machine-generated-code, DO NOT MODIFY HERE\n-- %s 'HPL', '2017-03-01'\nCREATE %s %s\n\"\"\"                                                name         sqlType.Condition \n                                                   sqlType.Name name \n                                                   name \n                                                   sqlType.Name name\n\n\nlet regexIdentifier = System.Text.RegularExpressions.Regex @\"^[\\p{L}_][\\p{L}\\p{N}@$#_]{0,127}$|^\\[.+\\]$\"\n                                                \nlet isIdentifier: string -> bool =\n              fun txt    -> regexIdentifier.IsMatch txt\n\nlet nameS fName = \n    if isIdentifier fName \n    then fName \n    else sprintf \"[%s]\" fName\n\ntype TargetField\nwith\n     member this.Name = toString this\n\ntype FinTransViewField\nwith\n     member this.Name = toString this\n\ntype Field =\n    | SurrogateKey   of TargetField\n    | BusinessKey    of FinTransViewField\n    | SourceDate     of FinTransViewField\n    | IntraDayOrder  of  FinTransViewField\n    | SCD2BeginDate  of TargetField\n    | SCD2EndDate    of TargetField\n    | SCD2Current    of TargetField\n    | ChangeReason   of TargetField\n    | SCD2           of FinTransViewField * scd1:TargetField option * scd0:TargetField option /// Version  value\n    | SCD1           of FinTransViewField * scd0:TargetField option                           /// Current  value\n    | SCD0           of FinTransViewField                               /// SCD0 without accompanying SCD1 or 2\nwith member this.Name0 = \n        match this with\n        | SurrogateKey   tfield\n        | SCD2BeginDate  tfield\n        | SCD2EndDate    tfield\n        | ChangeReason   tfield\n        | SCD2Current    tfield        -> tfield.Name\n        | BusinessKey    sfield\n        | SourceDate     sfield\n        | IntraDayOrder  sfield\n        | SCD2          (sfield, _, _) \n        | SCD1          (sfield, _   ) \n        | SCD0           sfield        -> sfield.Name\n     member this.Name = this.Name0 |> nameS\n","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"71d477dc-55cf-4d4f-89da-80549df011a2"},"expanded":true},{"name":"","content":"","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"7d941453-5c34-4a25-aacf-12da5c879586"},"expanded":true},{"name":"","content":"ghghghransViewField * scd1:TargetField option * scd0:TargetField option /// Version  value\n    | SCD1           of FinTransViewField * scd0:TargetField option                           /// Current  value\n    | SCD0           of FinTransViewField                               /// SCD","parent":{"$":0,"Item":"66a0107f-22a0-4825-a1d5-d36e1a44b5e3"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"6499d918-0d23-42e0-a066-998c076c40f9"},"expanded":true},{"name":"Demo Button","content":"\nTemplate.Button\n   .New(    \"Press me!\"                         )\n   .OnClick(fun _ _ -> JS.Alert \"Button pressed\")\n   .Style(  \"font-size: 48px\"                   )\n   .Render\n|> RunCode.RunNode().RunHtmlPlusFree\n   \n","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"companions":[],"id":{"$":0,"Item":"0a1fa320-b731-473a-93e2-dae49cc296f7"},"expanded":true},{"name":"Demo Input","content":"let inp = Template.Input.New(\"Type something...\")\n\nlet inline h1 ch = htmlElement \"h1\" ch\n\nh3 [\n  inp.Render\n  htmlText inp.Var\n  htmlElement \"h2\" [ htmlText inp.Var ]\n  h1 [ htmlText inp.Var ]\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"f3a7ead2-49e1-4ff4-b96e-6fe699a1c8a9"},"expanded":true},{"name":"Demo Code","content":"let code = Template.CodeMirror.New(\"Type something...\")\ndiv [ h1 [ htmlText code.Var ]\n      code.Render\n]\n|> RunCode.RunNode().RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"b03ba35c-a03c-4bbe-a373-1ce551524e56"}],"companions":[],"id":{"$":0,"Item":"f2cc3e92-5e61-47b2-982b-40f5c5784e6a"},"expanded":true},{"name":"Demo SplitterBar","content":"let styleT   p =\n  p |> sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% auto;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     : -7.5px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"\n\nlet min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\nlet splitter   = Template.SplitterBar.New\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     .Var(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"},{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"}],"companions":[],"id":{"$":0,"Item":"0aa90429-4e7c-42eb-b108-3dd70e710bf1"},"expanded":true},{"name":"","content":"\"[< hjhj >]\n  let name = \n\" \n   .Trim()\n   |> (fun s -> if s.StartsWith(\"[<\") \n                then s.Split([| \">]\" |], System.StringSplitOptions.RemoveEmptyEntries) |> Array.tryItem 1 \n                else Some s )\n   |> Option.bind (fun s ->\n        s.Trim()\n         .Split([| '\\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n        |> Seq.tryHead\n      )\n      |> Option.map (fun s -> s.Trim())\n      |> Option.defaultValue \"<empty>\"\n|> printfn \"%A\"//|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"a54701f2-1d68-4997-a1ea-62deaeb73e1b"},"expanded":true},{"name":"Test mouse","content":"//Template.Button.New(\"Run JS\").Style(\"vertical-align:top\").OnClick(fun _ _ -> JS.Eval(\"alert('hello')\") |> ignore).Render\n//|> getStyle\n//|> sprintf \"%A\"\n//|> RunCode.RunNode().ShowResult\nlet panel1 res =\n    Template.Panel.New\n      .Title(Val.map (fun pressed -> if pressed then \"PRESSED\" else \"---\") Input.Mouse.MousePressed)\n      .Header([])\n      .Content([ h3 [ htmlText <| sprintf \"%A\" res ; style \"font-family:monospace;\"] ])\n      .Render\n\n\ndiv [ ``class`` \"container\"\n      panel1 <| 7 * 7\n      div [ ``class`` \"container\"\n            div [ ``class`` \"container\"\n                  panel1 <| 7 * 8\n\n                ]\n          ]\n    ]\n|> RunCode.RunNode().AddBootstrap.RunHtml\n     ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"5e1dd5fc-a27c-4b0d-821a-06cc8a27bb82"}],"companions":[],"id":{"$":0,"Item":"4dc58ba1-75d1-4c96-9641-235ee7d8c2c2"},"expanded":true},{"name":"","content":"[1..10] |> Seq.take 5 |> Seq.toArray\n|> RunCode.RunNode().ShowResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"74b8570e-dcd4-4dff-87a5-cd7ec96b8527"},"expanded":true},{"name":"","content":"type Position =\n    | Below\n    | Right\n    | Tab\n    | NewBrowser\n    \nlet positionTxt v =\n    match v with\n    | Below      -> \"Below\"\n    | Right      -> \"Right\"\n    | Tab        -> \"In Tab\"\n    | NewBrowser -> \"New Browser\" \n\nlet position = Var.Create Below \n\nlet inp = Template.Input.New(position.Lens positionTxt (fun prev s -> \n    match s with\n    | \"Below\"        -> Below     \n    | \"Right\"        -> Right     \n    | \"In Tab\"       -> Tab       \n    | \"New Browser\"  -> NewBrowser\n    | _              -> prev\n    ) )\n\ndiv [\n  inp.Render\n  Doc.Select [] positionTxt [ Below ; Right ; Tab ; NewBrowser ] position |> someElt\n]\n|> RunCode.RunNode().RunHtml\n    ","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"38b21610-7350-4676-993b-88fea844314f"},"expanded":true},{"name":"Regex Pattern matching","content":"// from: https://github.com/intellifactory/websharper/blob/master/docs/ECMA-262.md\nlet str    = new String(\"Bob likes pineapples.\")\nlet regex  = new RegExp(@\"^\\w+\") // matches the first word\nlet newstr = str.Replace(regex,\"Alice\")\n\nlet (|REGEX|_|) (expr: string) (value: string) =\n    if value = null then None else\n    match String(value).Match expr with\n    | [| m ; _ |]  -> Some m\n    | _            -> None\n    \n    \nlet duple a b = a, b\nlet txt = @\"(6) casa\"\nlet rex = @\"(\\d+)\"\n    \n[ \"JavaScript RegExp:\"\n  sprintf \"String(%A).Match  %A: %A\" txt rex <| String(txt).Match rex\n  sprintf \"Active pattern: %A\" <|\n      match txt with\n      | REGEX rex m -> m\n      | _           -> \"<no match>\"\n]\n//|> List.map  (fun t -> div [ htmlText t ] )\n//|> fun lst -> List.Cons (style \"text-align: left\", lst)  // two different styles\n|> List.map  (htmlText >> List.singleton >> div )\n|> (duple (style \"text-align: left\") >> List.Cons) \n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[],"companions":[],"id":{"$":0,"Item":"7754c074-862e-4550-9d61-ea837adf6d85"},"expanded":true},{"name":"Load File","content":"let fileName = Var.Create \"\"\nlet justFileName (f:string) = f.Split [| '/' ; '\\\\' |] |> Seq.last\n\nTemplate.Input \n    .New(fileName.Lens justFileName (fun prev n -> prev) )\n    .Prefix(\n        label [ \n            ``class`` \"btn btn-primary\" \n            htmlText \"Browse...\" \n            Template.Input.New(fileName).Type(\"file\").Style(\"display: none\")\n              .Content([ on.change (fun el _ -> JS.Alert \"loading \" ) ]) \n              .Render \n        ])\n    .Render\n|> RunCode.RunNode().ShowHtmlResult","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"ee8fe0d0-14ad-4ae8-bd77-e0918817d67e"},"expanded":true},{"name":"Storage","content":"let min        = Template.Input.New(\"25.0\").Prefix(htmlText \"Min:  \")\nlet max        = Template.Input.New(\"75.0\").Prefix(htmlText \"Max:  \")\nlet value      = Template.Input.New(\"40.0\").Prefix(htmlText \"Value:\")\n\nlet settingsStorage = JS.Window.LocalStorage\n\nsettingsStorage.GetItem \"CodeEditor.min\"   |> fun v -> if v <> null then min  .Var.Value <- v\nsettingsStorage.GetItem \"CodeEditor.max\"   |> fun v -> if v <> null then max  .Var.Value <- v\nsettingsStorage.GetItem \"CodeEditor.value\" |> fun v -> if v <> null then value.Var.Value <- v\n\nVal.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.min\"  , v)) min  .Var\nVal.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.max\"  , v)) max  .Var\nVal.sink (fun v -> settingsStorage.SetItem (\"CodeEditor.value\", v)) value.Var\n\nlet styleT   p =\n  p |> sprintf \"\"\"\n.SplitterArea {\n    display: grid;\n    grid-template-columns: %f%% auto;\n    grid-template-areas:   \"left right\";\n    background-color: #41414d;\n    color: #444;\n    height: 50px;\n    grid-gap: 9px;\n    padding : 9px;\n}\n\n.SplitterArea > :nth-child(1){  grid-area: left  ; overflow: hidden; background-color: lightgreen; }\n.SplitterArea > :nth-child(2){  grid-area: right ; overflow: hidden; background-color: lightblue ; }\n\n.Splitter { \n    grid-column     :    2      ;\n    grid-row        :  1/2      ;\n    width           :    5px    ; \n    margin-left     : -7.5px    ; \n    border          :    0px    ; \n    padding         :    0px    ;\n    cursor          : col-resize;\n  \tbackground-color: #eef      ; \n}   \"\"\"\n\nlet splitter   = Template.SplitterBar.New\n                     .Min(Val.map float min.Var)\n                     .Max(Val.map float max.Var)\n                     .Var(value.Var.Lens (fun s -> float s) (fun prev f -> sprintf \"%f\" <| (f * 10. |> Math.Round |> float ) / 10. ) )\n\nlet bar =\n    div [\n      ``class`` \"SplitterArea\"\n      div    [ htmlText <| Val.map (             sprintf \"LEFT  %f\")  splitter.GetValue ]\n      div    [ htmlText <| Val.map (((-)100.) >>(sprintf \"RIGHT %f\")) splitter.GetValue ]\n      styleH [ htmlText <| Val.map styleT                             splitter.GetValue ]\n      splitter.Render\n    ]\n    \ndiv [\n  bar\n  min  .Render\n  max  .Render\n  value.Render\n]\n|> RunCode.RunNode().AddBootstrap.RunHtmlPlusFree","parent":{"$":0,"Item":"0268626d-d502-4981-a917-df659db5c0b6"},"predecessors":[{"$":0,"Item":"70030378-692d-431d-bed9-c839a7f95798"},{"$":0,"Item":"29c4d6ae-2bb7-457a-ba64-fcb7cce96a30"}],"companions":[],"id":{"$":0,"Item":"3d8bf6d2-a66b-4f18-aa83-8e74836e38e4"},"expanded":true}]